#!/usr/bin/python2
# PYTHON_ARGCOMPLETE_OK

import os
import logging
import argparse
import errno
from arc.control import *
from arc.utils import config

# Initialize logging
logger = logging.getLogger('ARCCTL')
logger.setLevel(logging.INFO)
log_handler_stderr = logging.StreamHandler()
log_handler_stderr.setFormatter(
    logging.Formatter('[%(asctime)s] [%(name)s] [%(levelname)s] [%(process)d] [%(message)s]'))
logger.addHandler(log_handler_stderr)

# Runconfig location
__runconfig = '/tmp/.arcctl.arc.run.conf'


# Define root parser for arcctl
def get_parser():
    parser = argparse.ArgumentParser(description='Nordugrid ARC Computing Element Control Tool')
    parser.add_argument('-c', '--config', action='store',
                        help='config file location (default is %(default)s)', default=config.arcconf_defpath())
    parser.add_argument('-d', '--debug', action='store',
                        help='verbosity level (default is %(default)s)', default='WARNING',
                        choices=['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'])

    # Register subparsers for defined arc.control components
    subparsers = parser.add_subparsers(title='ARC CE Components', metavar='COMPONENT', help='DESCRIPTION')
    for c in CTL_COMPONENTS:
        c.register_parser(subparsers)
    return parser


# Return parsed arc.conf (conditionally dump and load config with included defaults)
def get_arcconfig(conf_f):
    runconf_load = os.path.exists(__runconfig)
    try:
        logger.debug('Getting ARC configuration (config file: %s)', conf_f)
        if runconf_load:
            arcconf_mtime = os.path.getmtime(conf_f)
            default_mtime = os.path.getmtime(config.defaults_defpath())
            runconf_mtime = os.path.getmtime(__runconfig)
            if runconf_mtime < arcconf_mtime or runconf_mtime < default_mtime:
                runconf_load = False
        if runconf_load:
            logger.debug('Loading cached parsed configuration from %s', __runconfig)
            config.load_run_config(__runconfig)
        else:
            logger.debug('Parsing configuration options from %s (with defaults in %s)',
                         conf_f, config.defaults_defpath())
            config.parse_arc_conf(conf_f)
            config.save_run_config(__runconfig)
        arcconfig = config
    except IOError:
        logger.error('Failed to open ARC configuration file %s', conf_f)
        arcconfig = None
    return arcconfig

if __name__ == '__main__':
    args_parser = get_parser()

    # Try to import and use argcomplete if available
    try:
        import argcomplete
        argcomplete.autocomplete(args_parser)
    except ImportError:
        argcomplete = None
        logger.debug('Cannot import argcomplete module. '
                     'Consider to install python-argcomplete to take advantage of arcctl tab-completion')

    # Parse command line arguments
    cmd_args = args_parser.parse_args()
    # Set log level for both arcctl and config loggers
    logger.setLevel(cmd_args.debug)
    config.logger.setLevel(cmd_args.debug)
    # Define handler class
    ctl_class = cmd_args.handler_class

    # Invoke ARC control action
    try:
        ctl_class(get_arcconfig(cmd_args.config)).control(cmd_args)
    except IOError as e:
        # handle SIGPIPE termination
        if e.errno == errno.EPIPE:
            pass
        else:
            # Remove runconfig on any failures
            if os.path.exists(__runconfig):
                os.unlink(__runconfig)
            raise
