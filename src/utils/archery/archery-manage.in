#!@PYTHON@

from __future__ import print_function

import sys
import logging
import argparse
import ldap
import json
import hashlib
import re
import socket
import dns.resolver
import dns.update
import dns.query
import dns.tsig
import dns.tsigkeyring
from dns.exception import DNSException


#
# OUTPUT FORMATTING FUNCTIONS
#
def output_celist(archery_object, cmd_args):
    """Output the list of ARC CE hostnames (JSON capable)"""
    arcce_ids = [s['id'] for s in archery_services(archery_object, 'org.nordugrid.arex')]
    if cmd_args.json:
        print(json.dumps(arcce_ids))
    else:
        for ce in arcce_ids:
            print(ce)


def output_endpoints(archery_object, cmd_args):
    """Output the list of endpoints and its type (JSON capable)"""
    elist = archery_endpoints(archery_object)

    if cmd_args.json:
        print(json.dumps(elist))
    else:
        for e in elist:
            if 's' in e and e['s'] != '1':
                if not cmd_args.output_all:
                    continue
            print('{u:<60} : {t}'.format(**e))


def output_zonefile(archery_object, cmd_args, ttl=300):
    """Output the content of BIND zone file"""
    if cmd_args.json:
        logger.error('JSON format is not supported by zone file formatter')
    if cmd_args.output_all:
        logger.debug('ARCHERY zone file formatter includes all endpoints by default and ignore --output-all option')

    rrset = list(archery_txt_rrset(archery_object))
    rrset.sort()

    for rr in rrset:
        rr_mod = rr.split(' ', 1)
        print('{0:<64}{1:>6} TXT "{2}"'.format(rr_mod[0], ttl, rr_mod[1]))


_output_formatters = {
    'CEs': output_celist,
    'endpoints': output_endpoints,
    'zonefile': output_zonefile
}


#
# ENDPOINT FILTERING CLASSES
#
class EndpointFilter(object):
    """Abstract interface class for implementing endpoint filters"""
    def filter(self, endpoint_dict):
        raise NotImplementedError('Filter function should be implemented (return True is for filtering)')

    def help(self):
        raise NotImplementedError('Help function should be implemented')


class EndpointFilterType(EndpointFilter):
    """Filter endpoints by type"""
    _all_endpoint_types = [
        'org.nordugrid.gridftpjob',
        'org.nordugrid.ldapglue1',
        'org.nordugrid.ldapglue2',
        'org.nordugrid.ldapng',
        'org.nordugrid.wsrfglue2',
        'org.ogf.bes',
        'org.ogf.glue.emies.activitycreation',
        'org.ogf.glue.emies.activityinfo',
        'org.ogf.glue.emies.activitymanagement',
        'org.ogf.glue.emies.delegation',
        'org.ogf.glue.emies.resourceinfo',
        'org.nordugrid.arcrest',
        'resourceinfo'
    ]
    _resourseinfo_endpoint_types = [
        'org.nordugrid.ldapglue2',
        'org.nordugrid.ldapng',
        'org.ogf.glue.emies.resourceinfo'
    ]

    def __init__(self, args='resourceinfo'):
        self._allowed_endpoint_types = args.split(',')
        # handle resourceinfo alias for all information endpoint types
        if 'resourceinfo' in self._allowed_endpoint_types:
            self._allowed_endpoint_types += self._resourseinfo_endpoint_types
            self._allowed_endpoint_types.remove('resourceinfo')
        for e in self._allowed_endpoint_types:
            if e not in self._all_endpoint_types:
                logger.critical('Wrong endpoint type \'%s\' passed to filter. Possible values are %s',
                                e, ','.join(self._all_endpoint_types))
                sys.exit(1)
        logger.debug('Applying endpoints filtering with the following allowed types: %s',
                     ','.join(self._allowed_endpoint_types))

    def filter(self, endpoint_dict):
        logger.debug('Endpoint type filter: checking %s (type %s) complies filter definition',
                     endpoint_dict['u'], endpoint_dict['t'])
        if endpoint_dict['t'] not in self._allowed_endpoint_types:
            logger.info('Endpoint %s of type %s filtered (type filter)', endpoint_dict['u'], endpoint_dict['t'])
            return True
        return False

    def help(self):
        print('Endpoint type filter: \'-f type:<endpoint type>[,<endpoint type>[...]]\'')
        print('\tThe following types are supported:\n\t\t{}'.format(
            ',\n\t\t'.join(self._all_endpoint_types)))


class EndpointFilterPortscan(EndpointFilter):
    """Filter endpoints by port connectivity check"""
    __uri_re = re.compile(r'^(?P<uri>(?:ldap|gsiftp|https)://(?P<host>[^:/]+):(?P<port>[0-9]+))/*.*')

    def __init__(self, args=None):
        self.__args = args

    def filter(self, endpoint_dict):
        uri_data = self.__uri_re.match(endpoint_dict['u'])
        if uri_data:
            uri_parms = uri_data.groupdict()
            s = socket.socket()
            address = uri_parms['host']
            port = int(uri_parms['port'])
            try:
                logger.debug('Portscan Filter: testing %s:%s connectivity.', address, port)
                s.settimeout(5)
                s.connect((address, port))
            except Exception as err:
                logger.info('Endpoint %s of type %s filtered (port connectivity filter). Exception is %s',
                            endpoint_dict['u'], endpoint_dict['t'], err)
                return True
            finally:
                s.close()
            return False
        else:
            logger.error('Endpoint %s of type %s filtered (port connectivity filter). Failed to parse URI.',
                         endpoint_dict['u'], endpoint_dict['t'])
            return True

    def help(self):
        print('Endpoint port connectivity filter: \'-f portscan\'')


class EndpointFilterAllowedVO(EndpointFilter):
    """Filter endpoints by allowed VO information in LDAP"""
    __uri_re = re.compile(r'^(?P<uri>(?P<protocol>ldap|https)://(?P<host>[^:/]+)(?P<port>:[0-9]+))/*.*')
    __ldap_uri_re = re.compile(r'^(?P<uri>ldap://(?P<host>[^:/]+)(?::[0-9]+))/(?P<basedn>.*)')

    def __init__(self, args=''):
        self._allowed_vos = args.split(',')

    def filter(self, endpoint_dict):
        ldap_uri = endpoint_dict['u']
        if endpoint_dict['t'] == 'org.nordugrid.ldapglue2':
            ldap_filter = '(&(objectClass=GLUE2AccessPolicy)(GLUE2AccessPolicyEndpointForeignKey={}))'.format(
                endpoint_dict['id'])
            ldap_attrs = ['GLUE2PolicyRule']
        elif endpoint_dict['t'] == 'org.nordugrid.ldapng':
            ldap_filter = '(objectClass=nordugrid-cluster)'
            ldap_attrs = ['nordugrid-cluster-acl']
        else:
            # for non-LDAP endpoints, like EMI-ES, LDAP GLUE2 queried for endpoint info
            uri_data = self.__uri_re.match(endpoint_dict['u'])
            if uri_data:
                uri_parms = uri_data.groupdict()
                ldap_uri = 'ldap://{}:2135/o=glue'.format(uri_parms['host'])
                ldap_filter = '(&(objectClass=GLUE2AccessPolicy)(GLUE2AccessPolicyEndpointForeignKey={}))'.format(
                    endpoint_dict['id'])
                ldap_attrs = ['GLUE2PolicyRule']
            else:
                logger.error('Endpoint %s of type %s filtered (allowed VO filter). Failed to parse URI.',
                             endpoint_dict['u'], endpoint_dict['t'])
                return True

        parse_ldap_uri = self.__ldap_uri_re.match(ldap_uri)
        if parse_ldap_uri:
            aris_params = parse_ldap_uri.groupdict()
            ldap_uri = aris_params['uri']
            ldap_basedn = aris_params['basedn']
            try:
                logger.debug('Allowed VO Filter: querying ARIS %s for allowed VOs', ldap_uri)
                ldap_conn = ldap.initialize(ldap_uri)
                # TODO: configurable ldap timeouts
                ldap_conn.set_option(ldap.OPT_NETWORK_TIMEOUT, 5)
                ldap_conn.set_option(ldap.OPT_TIMEOUT, 5)
                ldap_conn.set_option(ldap.OPT_PROTOCOL_VERSION, ldap.VERSION3)

                search_r = ldap_conn.search_s(ldap_basedn, ldap.SCOPE_SUBTREE, ldap_filter, ldap_attrs)
                if search_r is None:
                    # it should not happens but just in case
                    return True
                for (_, volist) in search_r:
                    if ldap_attrs[0] not in volist:
                        return True
                    volist = [v.split(':', 1)[1] for v in volist[ldap_attrs[0]]]
                    for vo in self._allowed_vos:
                        if vo not in volist:
                            logger.info('Endpoint %s of type %s filtered (allowed VO filter)', endpoint_dict['u'],
                                        endpoint_dict['t'])
                            return True
            except ldap.LDAPError as err:
                logger.error('Endpoint %s of type %s filtered (allowed VO filter). '
                             'Failed to query LDAP endpoint %s to apply VO filter. Error: %s',
                             endpoint_dict['u'], endpoint_dict['t'], ldap_uri, err)
                return True
        return False

    def help(self):
        print('Endpoint allowed VO filter: \'-f vo:<voname>[,<voname>[...]]\'')


_filters = {
    'type': EndpointFilterType,
    'vo': EndpointFilterAllowedVO,
    'portscan': EndpointFilterPortscan
}


#
# ARCHERY DATA PROCESSING
#

def archery_endpoints(archery_object, etype=None):
    """Returns list of endpoint data from ARCHERY object tree"""
    endpoints = []
    # add endpoint records
    if 'endpoints' in archery_object:
        for edata in archery_object['endpoints']:
            # filter by endtpoint type if requested
            if etype is not None:
                if edata['t'] != etype:
                    continue
            endpoints.append(edata)
    # process child records
    if 'contains' in archery_object:
        for cdata in archery_object['contains']:
            endpoints += archery_endpoints(cdata, etype)
    return endpoints


def archery_services(archery_object, stype=None):
    """Returns list of services data from ARCHERY object tree"""
    services = []
    if 'object' not in archery_object:
        return services
    if archery_object['object'] == 'group':
        if 'contains' in archery_object:
            for cdata in archery_object['contains']:
                services += archery_services(cdata, stype)
    elif archery_object['object'] == 'service':
        # filter by service type
        if stype is not None:
            if 'type' not in archery_object:
                logger.debug('There is no service type defined for service object at %s. Skipping.',
                             archery_object['rr_owner'])
                return services
            if archery_object['type'] != stype:
                logger.debug('Skipping service object at %s (type %s does not match requested %s).',
                             archery_object['rr_owner'], archery_object['type'], stype)
                return services
        # check for service id
        if 'id' not in archery_object:
            logger.debug('There is no ID defined for service object at %s. Skipping.',
                         archery_object['rr_owner'])
            return services
        # append service
        services.append({
            'id': archery_object['id'],
            'type': archery_object['type'] if 'type' in archery_object else None,
        })
    return services


def archery_txt_rrset(archery_object):
    """Returns set of TXT RRs for ARCHERY object tree"""
    rrset = set()
    rr_owner = archery_object['rr_owner']
    # construct object record
    if 'object' in archery_object:
        rr = ' o=' + archery_object['object']
        if 'type' in archery_object:
            rr += ' t=' + archery_object['type']
        if 'id' in archery_object:
            rr += ' id=' + archery_object['id']
        # group object without type and id is the default
        if rr != ' o=group':
            rrset.add(rr_owner + rr)
    # add endpoint records
    if 'endpoints' in archery_object:
        for edata in archery_object['endpoints']:
            estatus = ''
            if 's' in edata and edata['s'] != 1:
                estatus = ' s={0}'.format(edata['s'])
            rrset.add('{0} u={1} t={2}{3}'.format(rr_owner, edata['u'], edata['t'], estatus))
    # add child records
    if 'contains' in archery_object:
        for cdata in archery_object['contains']:
            estatus = ''
            if 'status' in cdata and cdata['status'] != 1:
                estatus = ' s={0}'.format(cdata['status'])
            rrset.add('{0} u=dns://{1} t=org.nordugrid.archery{2}'.format(rr_owner, cdata['rr_owner'], estatus))
            rrset |= archery_txt_rrset(cdata)
    return rrset


#
# INFORMATION SOURCES PROCESSING FUNCTIONS
#
def get_file_celist(fpath):
    """Load hostnames from static list stored in file"""
    ce_list = []
    try:
        with open(fpath, 'r') as fd:
            ce_list = [line.strip() for line in fd]
            return ce_list
    except EnvironmentError:
        logger.error('Failed to open file %s to read CE list', fpath)
    return ce_list


def get_egiis_celist(egiis_uri, ldap_timeout=5):
    """Fetch CE hostnames from EGIIS (for migration)"""
    ce_list = []
    ldap_uri_re = re.compile(r'^(?P<uri>ldap://[^:/]+(?::[0-9]+))/(?P<basedn>.*)')
    parse_egiis_uri = ldap_uri_re.match(egiis_uri)
    if parse_egiis_uri:
        egiis_params = parse_egiis_uri.groupdict()
        ldap_uri = egiis_params['uri']
        ldap_basedn = egiis_params['basedn']
    else:
        logger.error('Failed to parse provided EGIIS URL %s. '
                     'Expected format ldap://<egiishost>:<port>/mds-vo-name=<Country>,o=grid. ', egiis_uri)
        return ce_list

    try:
        ldap_conn = ldap.initialize(ldap_uri)
        ldap_conn.set_option(ldap.OPT_NETWORK_TIMEOUT, ldap_timeout)
        ldap_conn.set_option(ldap.OPT_TIMEOUT, ldap_timeout)
        ldap_conn.set_option(ldap.OPT_PROTOCOL_VERSION, ldap.VERSION3)

        logger.debug('Querying EGIIS: %s', egiis_uri)
        egiis_entries = ldap_conn.search_s(ldap_basedn, ldap.SCOPE_BASE)

        if egiis_entries is None:
            logger.error('Querying EGIIS %s returns empty result set.', egiis_uri)
            return ce_list

        for egiis_dn, egiis_entry in egiis_entries:
            if egiis_dn.startswith('nordugrid-cluster-name='):
                ce_list.append(egiis_entry['Mds-Service-hn'][0])
            else:
                ce_list += get_egiis_celist('ldap://{Mds-Service-hn[0]}:2135/'
                                            '{Mds-Service-Ldap-suffix[0]}'.format(**egiis_entry), ldap_timeout)

    except ldap.LDAPError as err:
        logger.warning('Failed to query EGIIS %s. Error: %s', egiis_uri, err)
    return list(set(ce_list))


#
# ARIS ENDPOINTS PARSING FUNCTION
#
def get_arc_ce_endpoints_ldapglue2(hostname, port=2135, ldap_timeout=5, filters=None):
    """Get CE endpoints by querying ARIS GLUE2"""
    if filters is None:
        filters = []
    endpoints = []

    ldap_uri = 'ldap://{}:{}'.format(hostname, port)
    ldap_basedn = 'o=glue'
    ldap_filter = '(objectClass=GLUE2ComputingEndpoint)'
    ldap_attrs = ['GLUE2EndpointID', 'GLUE2EndpointURL', 'GLUE2EndpointHealthState', 'GLUE2EndpointInterfaceName']

    try:
        ldap_conn = ldap.initialize(ldap_uri)
        ldap_conn.set_option(ldap.OPT_NETWORK_TIMEOUT, ldap_timeout)
        ldap_conn.set_option(ldap.OPT_TIMEOUT, ldap_timeout)
        ldap_conn.set_option(ldap.OPT_PROTOCOL_VERSION, ldap.VERSION3)

        ldap_endpoints_list = ldap_conn.search_s(ldap_basedn, ldap.SCOPE_SUBTREE, ldap_filter, ldap_attrs)
        if ldap_endpoints_list is None:
            logger.error('Querying LDAP GLUE2 for %s returns empty result set.', hostname)
            return endpoints

        for ldap_dn, ldap_ee in ldap_endpoints_list:
            if 'GLUE2EndpointURL' not in ldap_ee:
                logger.warning(
                    'Failed to find endpoint URL in LDAP response for DN %s. '
                    'It seams GLUE2 rendering is broken for %s.', ldap_dn, ldap_uri)
                continue
            # get endpoint data
            e_id = ldap_ee['GLUE2EndpointID'][0]
            e_url = ldap_ee['GLUE2EndpointURL'][0]
            e_type = ldap_ee['GLUE2EndpointInterfaceName'][0]
            e_entry = {'id': e_id, 'u': e_url, 't': e_type}
            if ldap_ee['GLUE2EndpointHealthState'][0].upper() != 'OK':
                e_entry['s'] = '0'
            # apply filters if any
            for fo in filters:
                if fo.filter(e_entry):
                    break
            else:
                # add endpoint if not filtered
                logger.debug('Found endpoint %s (type %s) for CE %s', e_url, e_type, hostname)
                endpoints.append(e_entry)
    except ldap.LDAPError as err:
        logger.error('Failed to query LDAP GLUE2 for %s. Error: %s', hostname, err)
    return endpoints


def get_arc_ce_group(ce_list, rr_owner='_archery', applied_filters=None):
    """Create ARCHERY data object that represent ARC CE services group"""
    archery_object = {
        'object': 'group',
        'rr_owner': rr_owner,
        'contains': [],
    }

    for ce in ce_list:
        logger.info('Fetching endpoints info from CE\'s %s LDAP GLUE2', ce)
        service_object = {
            'object': 'service',
            'type': 'org.nordugrid.arex',
            'id': ce
        }
        service_hash = hashlib.sha1(json.dumps(service_object)).hexdigest()[:10]

        service_object['rr_owner'] = service_hash + '.' + rr_owner
        service_object['endpoints'] = get_arc_ce_endpoints_ldapglue2(ce, filters=applied_filters)

        archery_object['contains'].append(service_object)

    return archery_object



#
# ARCHERY DNS PROCESSING
#
_tsig_algorithms = {
    'HMAC-MD5': dns.tsig.HMAC_MD5,
    'HMAC-SHA1': dns.tsig.HMAC_SHA1,
    'HMAC-SHA224': dns.tsig.HMAC_SHA224,
    'HMAC-SHA256': dns.tsig.HMAC_SHA256,
    'HMAC-SHA384': dns.tsig.HMAC_SHA384,
    'HMAC-SHA512': dns.tsig.HMAC_SHA512,
}

def parse_archery_txt(txtstr):
    """Get data dict from ARCHERY DNS TXT string representation"""
    rrdata = {}
    for kv in txtstr.split(' '):
        if kv[1] == '=':
            rrdata[kv[0]] = kv[2:]
        else:
            logger.debug('Malformed archery TXT entry %s (%s does not match k=value)', txtstr, kv)
    return rrdata


def fetch_archery_dns_data(dns_name, nameserver=None, resolver=None):
    """Get ARCHERY data from DNS endpoint"""
    archery_object = {
        'contains': [],
        'endpoints': []
    }
    # construct archery exact domain name to query
    if dns_name[0:6] == 'dns://':
        dns_name = dns_name[6:]
    else:
        dns_name = '_archery.' + dns_name
    # create DNS resolver
    if resolver is None:
        resolver = dns.resolver.Resolver()
        if nameserver is not None:
            resolver.nameservers = [nameserver]
    # query TXT RRSet
    logger.debug('Querying ARCHERY data from: %s', dns_name)
    try:
        archery_rrs = resolver.query(dns_name, 'TXT')
        archery_object['rr_owner'] = str(archery_rrs.rrset.name)
        guess_object_kind = 'group'
        for rr in archery_rrs:
            txt = ''.join(rr.strings)
            rrdata = parse_archery_txt(txt)
            # object description resource record found
            if 'o' in rrdata:
                archery_object['object'] = rrdata['o']
                # type and id for the object if available
                if 't' in rrdata:
                    archery_object['type'] = rrdata['t']
                if 'id' in rrdata:
                    archery_object['id'] = rrdata['id']
            # other records that contains endpoint/grouping data
            elif 'u' in rrdata:
                if 't' in rrdata:
                    if rrdata['t'] == 'org.nordugrid.archery':
                        child_object = fetch_archery_dns_data(rrdata['u'], resolver=resolver)
                        if 's' in rrdata and rrdata['s'] != '1':
                            child_object['status'] = 0
                        archery_object['contains'].append(child_object)
                    else:
                        guess_object_kind = 'service'
                        archery_object['endpoints'].append(rrdata)
                else:
                    logger.error('ARCHERY data in %s contains broken endpoint record without type: %s', dns_name, txt)
                    continue
        # object kind checks
        if 'object' in archery_object and archery_object['object'] != guess_object_kind:
            logger.warning('ARCHERY object defined by %s name is declared as %s kind but contains information '
                           'that should not be defined there', dns_name, archery_object['object'])
    except DNSException as err:
        logger.warning('Failed to query ARCHERY data from %s. Error: %s', dns_name, err)

    return archery_object


#
# HANDLE DDNS UPDATE
#
def archery_ddns_update(domain, nameserver, keyring_dict, new_archery_object, ttl=300,
                        keyalgorithm=dns.tsig.default_algorithm):
    """Incrementally updates ARCHERY data records in DNS"""
    keyring = dns.tsigkeyring.from_text(keyring_dict)
    main_rr_owner = '_archery.{}.'.format(domain.rstrip('.'))

    # new TXT data according to provided data object
    new_dns_rrset = archery_txt_rrset(new_archery_object)

    # old endpoints from querying the ARCHERY
    dns_archery_object = fetch_archery_dns_data('dns://' + main_rr_owner, nameserver=nameserver)
    old_dns_rrset = archery_txt_rrset(dns_archery_object)

    # print(json.dumps(list(new_dns_rrset), indent=2))
    # print(json.dumps(list(old_dns_rrset), indent=2))

    remove_rrs = old_dns_rrset - new_dns_rrset
    add_rrs = new_dns_rrset - old_dns_rrset

    try:
        update = dns.update.Update(domain, keyring=keyring,
                                   keyalgorithm=keyalgorithm)
        for r in remove_rrs:
            logger.debug('Going to REMOVE record by means of DDNS update: %s', r)
            rr = r.split(' ', 1)
            update.delete(rr[0], 'txt', rr[1].replace(' ', r'\ '))
        for a in add_rrs:
            logger.debug('Going to ADD record by means of DDNS update: %s', a)
            ar = a.split(' ', 1)
            update.add(ar[0], ttl, 'txt', ar[1].replace(' ', r'\ '))
        logger.info('Sending update to DNS master %s via DDNS protocol (using TSIG key %s)',
                    nameserver, list(keyring_dict.keys())[0])
        dns.query.tcp(update, nameserver)
        # if exception is not raised we have succeeded with update
        logger.info('ARCHERY information has been updated for zone %s', domain)
    except DNSException as e:
        logger.error('Failed in DDNS update. Error: %s', e)


#
# MAIN EXECUTION CYCLE
#
def get_parser():
    """Command line arguments parser"""
    parser = argparse.ArgumentParser(description='Nordugrid ARCHERY administration tool')
    parser.add_argument('-d', '--debug', action='store', default='INFO',
                        choices=['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'])
    parser.add_argument('-s', '--source', action='append', required=True,
                        help='Select CE list source (file: and egiis: sources are supported)')
    parser.add_argument('-f', '--filter', action='append', help='Add one or more filters to endpoint list. '
                                                                'Use \'-f help\' to show available filters')
    parser.add_argument('-o', '--output', choices=list(_output_formatters.keys()),
                        help='Output the value to stdout according to specified type')
    parser.add_argument('--json', action='store_true',
                        help='Change output format from plaintext to JSON')
    parser.add_argument('--output-all', action='store_true',
                        help='Output all CEs/endpoints including inactive (filters are still applied)')
    parser.add_argument('-u', '--ddns-update', action='store_true',
                        help='Invoke DNS zone direct update by means of DDNS with TSIG auth')
    parser.add_argument('--domain', help='domain name of the ARCHERY endpoint to use (required for DDNS update)')
    parser.add_argument('--ddns-master-ip', help='master NS IP address to contact (required for DDNS update)')
    parser.add_argument('--ddns-tsig-keyfile', help='TSIG keyfile (required for DDNS update)')
    parser.add_argument('--ddns-tsig-algorithm',
                        help='Cryptographic algorithm for TSIG',
                        choices=list(_tsig_algorithms.keys()), default='HMAC-MD5')
    return parser

# Initialize logger
logger = logging.getLogger('ARC.ARCHERY-Manage')
logger.setLevel(logging.WARNING)
log_handler_stderr = logging.StreamHandler()
log_handler_stderr.setFormatter(
    logging.Formatter('[%(asctime)s] [%(name)s] [%(levelname)s] [%(process)d] [%(message)s]'))
logger.addHandler(log_handler_stderr)

if __name__ == '__main__':
    # Process command line arguments
    parser = get_parser()
    cmd_args = parser.parse_args()
    # Set requested logging level
    logger.setLevel(getattr(logging, cmd_args.debug, 20))

    # Domain name to work with
    domain = cmd_args.domain
    # Check DDNS update required options before doing anything
    if cmd_args.ddns_update:
        # check for domain
        if domain is None:
            logger.error('Domain name (--domain) is required to use DDNS update')
            sys.exit(1)
        # check for master nameserver IP
        if cmd_args.ddns_master_ip is None:
            logger.error('Name server master IP to communicate (--ddns-master-ip) is required to use DDNS update')
            sys.exit(1)
        nameserver = cmd_args.ddns_master_ip
        # check for keyring
        if cmd_args.ddns_tsig_keyfile is None:
            logger.error('TSIG keyfile (--ddns-tsig-keyfile) is required to use DDNS update')
            sys.exit(1)
        else:
            try:
                logger.debug('Reading TSIG key from %s', cmd_args.ddns_tsig_keyfile)
                with open(cmd_args.ddns_tsig_keyfile, 'r') as tsig_f:
                    keyring_str = tsig_f.readline()
                    keyring_s = keyring_str.split(':')
                    if len(keyring_s) != 2:
                        logger.error('Failed to parse TSIG keyfile %s. Expected format is keyname:secret',
                                     cmd_args.ddns_tsig_keyfile)
                        sys.exit(1)
                    logger.debug('TSIG key %s has been successfully read', keyring_s[0])
                    keyring_dict = {keyring_s[0]: keyring_s[1]}
            except EnvironmentError as err:
                logger.error('Failed to read TSIG keyfile %s. Error: %s', cmd_args.ddns_tsig_keyfile, err)
                sys.exit(1)

    # Parse filters for fetching endpoints
    applied_filters = []
    if cmd_args.filter is not None:
        for f in cmd_args.filter:
            if f == 'help':
                print('Supported filters are:')
                for _, fclass in _filters.items():
                    fci = fclass()
                    fci.help()
                sys.exit(0)
            fdef = f.split(':', 1)
            ftype = fdef[0]
            fargs = fdef[1] if len(fdef) > 1 else ''
            if ftype not in list(_filters.keys()):
                logger.error('Ignoring bad filter definition: %s', f)
                continue
            fclass = _filters[ftype]
            fobj = fclass(fargs)
            applied_filters.append(fobj)

    # Get CE list from defined sources
    ce_list = []
    for source in cmd_args.source:
        if source.startswith('file:'):
            logger.info('Obtaining CE list from file: %s', source[5:])
            ce_list += get_file_celist(source[5:])
        elif source.startswith('egiis:'):
            logger.info('Obtaining CE list from EGIIS URL: %s', source[6:])
            ce_list += get_egiis_celist(source[6:])
        else:
            logger.error('Unsupported CE list source: %s', source)
    logger.debug('Fetched CE list to work with: %s', ', '.join(ce_list))

    # Base domain name to work with
    rr_owner = '_archery'
    if domain is not None:
        rr_owner += '.{0}.'.format(domain.rstrip('.'))

    archery_object = get_arc_ce_group(ce_list, rr_owner, applied_filters)

    # Invoke DDNS update if requested
    if cmd_args.ddns_update:
        logger.info('Sending update to DNS master %s via DDNS protocol (using TSIG key %s)',
                    nameserver, list(keyring_dict.keys())[0])
        archery_ddns_update(domain, nameserver, keyring_dict, archery_object)

    # Output information if requested
    if cmd_args.output:
        formatter_f = _output_formatters[cmd_args.output]
        formatter_f(archery_object, cmd_args)

