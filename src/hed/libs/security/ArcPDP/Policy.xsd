<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:policy-arc="http://www.nordugrid.org/schemas/policy-arc" xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.nordugrid.org/schemas/policy-arc" elementFormDefault="qualified" attributeFormDefault="unqualified">

<!--One Policy is composed of a few Rules; one Rule is composed of a tuple <Subjects, Resources, Actions, Conditions>, and each Rule 
 has one Effect: Permit or Deny.-->
<!--The policy definition is inspired by XACML and GACL;
It is not complicated as XACML, but not so adapatable and general as XACML as well. We need to implement a specific PDP for Arc in order to use it, just lik
e GACL does;
The element and attribute in the policy can only be understood by ArcPDP;
Because of the similiarity with XACML, the policy can be conventially translated into XACML by implemeting some special translating package. And then the ge
neral XACML policy expression and PDP can be used, if we need to use some standard XACML policy and do not want to write some complicated XACML policy;
Each servicei or resource can has one authorization policy file. 
It the policy enforcement point only includes one entity, then "Resources" can be omitted;
  -->

 <xsd:element name="Description" type="xsd:string"/>

 <xsd:element name="Policy" type="policy-arc:PolicyType"/>
 <xsd:complexType name="PolicyType">
  <xsd:sequence>
   <xsd:element ref="policy-arc:Description" minOccurs="0"/>
   <xsd:element ref="policy-arc:Rule" minOccurs="1" maxOccurs="unbounded"/>
  </xsd:sequence>
  <xsd:attribute name="PolicyId" type="xsd:anyURI" use="required"/>
  <!--RuleCombiningAlgId, Combining Algorithm for Rules,  e.g. "DenyOveride" means any "Deny" evaluation result from some Rule will overide 
  all "Permit" result from the other Rules. -->
  <xsd:attribute name="RuleCombiningAlgId" type="xsd:anyURI"/> 
 </xsd:complexType>


 <!--One rule is a unit of decision-making, which means there is implicit relationship among <Subjects, Resources, Actios, Conditions>. 
  There are some principles about the Rule definition:
   1. Each Rule has a tuple <Subjects, Resources, Actios, Conditions> (actually <Subjects, Resources, Actios, Conditions, Effect>). 
      The policy administrator should define the rules according to granuality of Actions and Resources, and constraints to Subjects. 
      For example, there is a Rule: <UserA/UserB, FileX, Read/List, 14:00, Permit>, if the administrator wants to add "Delete" permssion 
      for "UserA/UserB" to "FileX" at Condition "14:00", then the constraint can be added to the existing rule: <UserA/UserB, FileX, Read/List/Delete, 
      14:00, Permit>; Otherwise,if any of the other element (Subjects, Resources, Conditions, Effect) does not match, he should add a new Rule.
   2. Subjects is a must element for each Rule. Each Rule must have one and only one Requests element.
   3. Each Rule can have zero or one Resources, Actions, Conditions element. 
      If the policy is attached to some specified Resource, then Resources element is not necessary, just like GACL policy which is attached to each files;
      If the operation to the Resources are only one, then Actions element can be missing, just lile gridmap in which the operation is the all the
      permission of a specified system user.
      If there is no Conditions constrains, the Conditions element can be missing.
      Moreover, the absence of one or more elements can make the Rule more general, and then we can need less items of rules. But the price is more
      coarse granuality. -->
 <xsd:element name="Rule" type="policy-arc:RuleType"/>
 <xsd:complexType name="RuleType">
  <xsd:sequence> 
   <xsd:element ref="policy-arc:Description" minOccurs="0"/>
   <xsd:element ref="policy-arc:Subjects"/>
   <xsd:element ref="policy-arc:Resources" minOccurs="0"/>
   <xsd:element ref="policy-arc:Actions" minOccurs="0"/>
   <xsd:element ref="policy-arc:Conditions" minOccurs="0"/>
  </xsd:sequence>
  <xsd:attribute name="RuleId" type="xsd:string" use="required"/>
  <xsd:attribute name="Effect" type="policy-arc:EffectType" use="required"/>
 </xsd:complexType> 


 <!--Some common definition-->
 
 <xsd:simpleType name="EffectType">
  <xsd:restriction base="xsd:string">
   <xsd:enumeration value="Permit"/>
   <xsd:enumeration value="Deny"/>
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:element name="GroupIdRef" type="policy-arc:IdRefType"/>

 <xsd:complexType name="IdRefType">
  <xsd:simpleContent>
   <!--e.g. Specify the "Id" inside a file "Group" information-->
   <xsd:extension base="xsd:anyURI">
    <!--e.g. "Location" specifies the path of "Group" information file-->
    <xsd:attribute name="Location" type="xsd:anyURI" use="optional"/>
   </xsd:extension>
  </xsd:simpleContent>
 </xsd:complexType>

 

 <!--Definition of Subjects-->
 <xsd:element name="Subjects" type="policy-arc:SubjectsType"/>
 <xsd:complexType name="SubjectsType">
  <!-- -->
  <xsd:choice maxOccurs="unbounded">
   <xsd:element ref="policy-arc:GroupIdRef"/>   
   <xsd:element ref="policy-arc:Subject"/>
  </xsd:choice>
  <xsd:attribute name="Type" type="xsd:string"/>
 </xsd:complexType>

 <!--"SubjectGroup" information includes a few Subject, and is stored in a file independent to policy file--> 
 <xsd:element name="SubjectGroup" type="policy-arc:SubjectGroupType"/>
 <xsd:complexType name="SubjectGroupType">
  <xsd:sequence>
   <xsd:element ref="policy-arc:Subject" maxOccures="unbounded"/>
  </xsd:sequence>
  <xsd:attribute name="GroupId" type="xsd:anyURI" use="required"/>
 </xsd:complexType> 

 <xsd:element name="Subject" type="policy-arc:SubjectType"/>
 <xsd:complexType name="SubjectType">
  <!--One choice, if there are more than two fractions in one Subject, the request should match all of these fractions: 
      <Subject>
       <SubFraction Type="X500DN">/O=Grid/OU=KnowARC/CN=ABC</SubjectFraction>
       <SubFraction Type="ShibName">urn:mace:shibboleth:examples</SubjectFraction>
      </Subject>-->
  <xsd:sequence>
   <xsd:element ref="policy-arc:SubFraction" maxOccurs="unbounded"/>
  </xsd:sequence>
   <!-- The other choice:  <Subject Type="X509DN">/O=Grid/OU=KnowARC/CN=ABC</Subject>  -->
  <xsd:simpleContent>
   <xsd:extension base="xsd:string">
    <xsd:attribute name="Type" type="xsd:string"/>
   </xsd:extension>
  </xsd:simpleContent>
 </xsd:complexType>

 <xsd:element name="SubFraction" type="policy-arc:SubFractionType"/>
 <xsd:complexType name="SubFractionType">
  <xsd:simpleContent>
   <xsd:extension base="xsd:string">
    <xsd:attribute name="Type" type="xsd:string"/>
   </xsd:extension>
  </xsd:simpleContent>
 </xsd:complexType>
 
 
 <!--Definition of Resources, similar to the definition of Subjects-->
 <xsd:element name="Resources" type="policy-arc:ResourcesType"/>
 <xsd:complexType name="ResourcesType">
  <!-- -->
  <xsd:choice maxOccurs="unbounded">
   <xsd:element ref="policy-arc:GroupIdRef"/>
   <xsd:element ref="policy-arc:Resource"/>
  </xsd:choice>
 </xsd:complexType>

 <!--"ResourceGroup" information includes a few Resource, and is stored in a file independent to policy file-->
 <xsd:element name="ResourceGroup" type="policy-arc:ResourceGroupType"/>
 <xsd:complexType name="ResourceGroupType">
  <xsd:sequence>
   <xsd:element ref="policy-arc:Resource" maxOccures="unbounded"/>
  </xsd:sequence>
  <xsd:attribute name="GroupId" type="xsd:anyURI" use="required"/>
 </xsd:complexType>

 <xsd:element name="Resource" type="policy-arc:ResourceType"/>
 <xsd:complexType name="ResourceType">
  <xsd:simpleContent>
   <xsd:extension base="xsd:string">
    <xsd:attribute name="Type" type="xsd:string"/>
   </xsd:extension>
  </xsd:simpleContent>
 </xsd:complexType>


 <!--Definition of Actions-->
 <xsd:element name="Actions" type="policy-arc:ActionsType"/>
 <xsd:complexType name="ActionsType">
  <!-- -->
  <xsd:sequence maxOccurs="unbounded">
   <xsd:element ref="policy-arc:Action"/>
  </xsd:sequence>
 </xsd:complexType>

 <xsd:element name="Action" type="policy-arc:ActionType"/>
 <xsd:complexType name="ActionType">
   <!-- The "Type" is defined to distinguish different types of operations: e.g. Storage (read/write/list ...), Job(submit/list/kill/status ...) -->
   <!--  <Action Type="Storage">Read</Action>   -->
  <xsd:simpleContent>
   <xsd:extension base="xsd:string">
    <xsd:attribute name="Type" type="xsd:string" use="optional"/>
   </xsd:extension>
  </xsd:simpleContent>
 </xsd:complexType>


 <!--Definition of Conditions, Conditions is more complicated than Resouces, Subjects or Actions:
   The definition of Conditions is complicated, because there can be many types of conditions: Time, Duration, URI, etc.;
   The match-making of Conditions with Request.Contex (See schema definition of Request) is complicated, because for each types of Condition, the
   match-making algorithm should be different.  Not like the situation, we implicitly use simple "string1 == string2" for match-making. -->
 <!--The relationship between CondFractions is "and"; The relationship between Condition is "or" -->
 <xsd:element name="Conditions" type="policy-arc:ConditionsType"/>
 <xsd:complexType name="ConditionsType">
  <xsd:choice maxOccurs="unbounded">
   <xsd:element ref="policy-arc:GroupIdRef"/>
   <xsd:element ref="policy-arc:Condition"/>
  </xsd:choice>
 </xsd:complexType>

 <!--"ConditionGroup" information includes a few Conditions, and is stored in a file independent to policy file. It is reasonable when the 
 administrator wants to define some general condition constraints.-->
 <xsd:element name="ConditionGroup" type="policy-arc:ConditionGroupType"/>
 <xsd:complexType name="ConditionGroupType">
  <xsd:sequence>
   <xsd:element ref="policy-arc:Condition" maxOccures="unbounded"/>
  </xsd:sequence>
  <xsd:attribute name="GroupId" type="xsd:anyURI" use="required"/>
 </xsd:complexType>

 <xsd:element name="Condition" type="policy-arc:ConditionType"/>
 <xsd:complexType name="ConditionType">
  <!--One choice, if there are more than two fractions in one Condition, the request should match all of these fractions.-->
  <xsd:sequence minOccures="2">
   <xsd:element ref="policy-arc:CondFraction" maxOccurs="unbounded"/>
  </xsd:sequence>

  <!-- The other choice:  -->
  <xsd:complexContent>
   <xsd:extension base="policy-arc:VariableType">
    <xsd:attribute name="Type" type="xsd:string"/>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="CondFraction" type="policy-arc:CondFractionType"/>
 <xsd:complexType name="CondFractionType">
  <xsd:complexContent>
   <xsd:extension base="policy-arc:VariableType">
    <xsd:attribute name="Type" type="xsd:string"/>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>

 <xsd:element name="Variable" type="policy-arc:VariableType" abstract="true"/>
 <xsd:complexType name="VariableType" abstract="true"/>

</xsd:schema>
