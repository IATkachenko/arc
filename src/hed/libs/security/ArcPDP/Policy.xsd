<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema targetNamespace="http://www.nordugrid.org/schemas/policy-arc"
 xmlns:policy-arc="http://www.nordugrid.org/ws/schemas/policy-arc"
 xmlns:xsd="http://www.w3.org/2001/XMLSchema">

<!-- -->
 <xsd:element name="Policy" type="policy-arc:PolicyType"/>
 <xsd:complexType name="PolicyType">
  <xsd:sequence>
   <xsd:element ref="policy-arc:Description" minOccurs="0"/>
   <xsd:element ref="policy-arc:Rule" minOccurs="1" maxOccurs="unbounded"/>
  </xsd:sequence>
  <xsd:attribute name="PolicyId" type="xsd:anyURI" use="required"/>
  <!--RuleCombiningAlgId, Combining Algorithm for Rules,  e.g. "DenyOveride" means any "Deny" evaluation result from some Rule will overide 
  all "Permit" result from the other Rules. -->
  <xsd:attribute name="RuleCombiningAlgId" type="xsd:anyURI"/> 
 </xsd:complexType>


 <!--One rule is a unit of decision-making, which means there is implicit relationship among <Subjects, Resources, Actios, Conditions>. 
  There are some principles about the Rule definition:
   1. Each Rule has a tuple <Subjects, Resources, Actios, Conditions> (actually <Subjects, Resources, Actios, Conditions, Effect>). 
      The policy administrator should define the rules according to granuality of Actions and Resources, and constraints to Subjects. 
      For example, there is a Rule: <UserA/UserB, FileX, Read/List, 14:00, Permit>, if the administrator wants to add "Delete" permssion 
      for "UserA/UserB" to "FileX" at Condition "14:00", then the constraint can be added to the existing rule: <UserA/UserB, FileX, Read/List/Delete, 
      14:00, Permit>; Otherwise,if any of the other element (Subjects, Resources, Conditions, Effect) does not match, he should add a new Rule.
   2. Subjects is a must element for each Rule. Each Rule must have one and only one Requests element.
   3. Each Rule can have zero or one Resources, Actions, Conditions element. 
      If the policy is attached to some specified Resource, then Resources element is not necessary, just like GACL policy which is attached to each files;
      If the operation to the Resources are only one, then Actions element can be missing, just lile gridmap in which the operation is the all the
      permission of a specified system user.
      If there is no Conditions constrains, the Conditions element can be missing.
      Moreover, the absence of one or more elements can make the Rule more general, and then we can need less items of rules. But the price is more
      coarse granuality. -->
 <xsd:element name="Rule" type="policy-arc:RuleType"/>
 <xsd:complexType name="RuleType">
  <xsd:sequence> 
   <xsd:element ref="policy-arc:Description" minOccurs="0"/>
   <xsd:element ref="policy-arc:Subjects"/>
   <xsd:element ref="policy-arc:Resources" minOccurs="0"/>
   <xsd:element ref="policy-arc:Actions" minOccurs="0"/>
   <xsd:element ref="policy-arc:Conditions" minOccurs="0"/>
  </xsd:sequence>
  <xsd:attribute name="RuleId" type="xsd:string" use="required"/>
  <xsd:attribute name="Effect" type="policy-arc:EffectType"/>
 </xsd:complexType> 


 <!--Some common definition-->
 
 <xsd:simpleType name="EffectType">
  <xsd:restriction base="xsd:string">
   <xsd:enumeration value="Permit">
   <xsd:enumeration value="Deny">
  </xsd:restriction>
 </xsd:simpleType>

 <xsd:element name="GroupIdRef" type="policy-arc:IdRefType"/>

 <xsd:complexType name="policy-arc:IdRefType">
  <xsd:simpleContent>
   <!--e.g. Specify the "Id" inside a file "Group" information-->
   <xsd:extension base="xsd:anyURI">
    <!--e.g. "Location" specifies the path of "Group" information file-->
    <xsd:attribute name="Location" type="xsd:anyURI" use="optional">
   </xsd:extension>
  </xsd:simpleContent>
 </xsd:complexType>

 

 <!--Definition of Subjects-->
 <xsd:element name="Subjects" type="policy-arc:SubjectsType"/>
 <xsd:complexType name="SubjectsType">
  <!-- -->
  <xsd:choice maxOccurs="unbounded">
   <xsd:element ref="policy-arc:GroupIdRef"/>   
   <xsd:element ref="policy-arc:Subject"/>
  </xsd:choice>
 </xsd:complexType>

 <!--"SubjectGroup" information includes a few Subject, and is stored in a file independent to policy file--> 
 <xsd:element name="SubjectGroup" type="policy-arc:SubjectGroupType"/>
 <xsd:complexType name="policy-arc:SubjectGroupType">
  <xsd:sequence>
   <xsd:element ref="policy-arc:Subject" maxOccures="unbounded"/>
  </xsd:sequence>
  <xsd:attribute name="GroupId" type="xsd:anyURI" use="required">
 </xsd:complexType> 

 <xsd:element name="Subject" type="policy-arc:SubjectType"/>
 <xsd:complexType name="SubjectType">
  <xsd:choice maxOccures="unbounbded">
   <!--One choice, if there are more than two fractions in one Subject, the request should match all of these fractions: 
      <Subject>
       <SubFraction Type="X500DN">/O=Grid/OU=KnowARC/CN=ABC</SubjectFraction>
       <SubFraction Type="ShibName">urn:mace:shibboleth:examples</SubjectFraction>
      </Subject>-->
   <!--If minOccures<"2", we can use the other choice-->
   <xsd:sequence minOccures="2">
    <xsd:element ref="policy-arc:SubFraction" maxOccurs="unbounded/">
   </xsd:sequence>
 
   <!-- The other choice:  <Subject Type="X509DN">/O=Grid/OU=KnowARC/CN=ABC</Subject>   -->
   <xsd:simpleContent base="xsd:string">
    <xsd:attribute name="Type" type="xsd:string" use="required"/>
   </xsd:simpleContent>
  </xsd:choice>
 </xsd:complexType>

 <xsd:element name="SubFraction" type="policy-arc:SubFractionType"/>
 <xsd:complexType name="SubFractionType">
  <xsd:simpleContent base="xsd:string">
    <xsd:attribute name="Type" type="xsd:string" use="required"/>
  </xsd:simpleContent>
 </xsd:complexType>
 
 
 <!--Definition of Resources, similar to the definition of Subjects-->
 <xsd:element name="Resources" type="policy-arc:ResourcesType"/>
 <xsd:complexType name="ResourcesType">
  <!-- -->
  <xsd:choice maxOccurs="unbounded">
   <xsd:element ref="policy-arc:GroupIdRef"/>
   <xsd:element ref="policy-arc:Resource"/>
  </xsd:choice>
 </xsd:complexType>

 <!--"ResourceGroup" information includes a few Resource, and is stored in a file independent to policy file-->
 <xsd:element name="ResourceGroup" type="policy-arc:ResourceGroupType"/>
 <xsd:complexType name="policy-arc:ResourceGroupType">
  <xsd:sequence>
   <xsd:element ref="policy-arc:Resource" maxOccures="unbounded"/>
  </xsd:sequence>
  <xsd:attribute name="GroupId" type="xsd:anyURI" use="required">
 </xsd:complexType>

 <xsd:element name="Resource" type="policy-arc:ResourceType"/>
 <xsd:complexType name="ResourceType">
  <xsd:choice maxOccures="unbounbded">
   <!--One choice, if there are more than two fractions in one Resource, the request should match all of these fractions. No example here. Maybe there
   is no such requirement the same as Subjects-->
   <!--If minOccures<"2", we can use the other choice-->
   <xsd:sequence minOccures="2">
    <xsd:element ref="ResFraction" maxOccurs="unbounded/">
   </xsd:sequence>

   <!-- The other choice:  <Resource Type="Storage">file://tmp/test.txt</Resource>   -->
   <xsd:simpleContent base="xsd:string">
    <xsd:attribute name="Type" type="xsd:string" use="required"/>
   </xsd:simpleContent>
  </xsd:choice>
 </xsd:complexType>

 <!--
 <xsd:element name="ResFraction" type="policy-arc:ResFractionType"/>
 <xsd:complexType name="ResFractionType">
  <xsd:simpleContent base="xsd:string">
    <xsd:attribute name="Type" type="xsd:string" use="required"/>
  </xsd:simpleContent>
 </xsd:complexType>
 -->

 <!--Definition of Actions-->
 <xsd:element name="Actions" type="policy-arc:ActionsType"/>
 <xsd:complexType name="ActionsType">
  <!-- -->
  <xsd:sequence maxOccurs="unbounded">
   <xsd:element ref="policy-arc:Action"/>
  </xsd:sequence>
 </xsd:complexType>

 <xsd:element name="Action" type="policy-arc:ActionType"/>
 <xsd:complexType name="ActionType">
   <!-- The "Type" is defined to distinguish different types of operations: e.g. Storage (read/write/list ...), Job(submit/list/kill/status ...) -->
   <!--  <Action Type="Storage">Read</Action>   -->
  <xsd:simpleContent base="xsd:string">
    <xsd:attribute name="Type" type="xsd:string" use="optional"/>
  </xsd:simpleContent>
 </xsd:complexType>


 <!--Definition of Conditions, Conditions is more complicated than Resouces, Subjects or Actions:
   The definition of Conditions is complicated, because there can be many types of conditions: Time, Duration, URI, etc.;
   The match-making of Conditions with Request.Contex (See schema definition of Request) is complicated, because for each types of Condition, the
   match-making algorithm should be different.  Not like the situation, we implicitly use simple "string1 == string2" for match-making. -->
 <!-- -->
 <xsd:element name="Conditions" type="policy-arc:ConditionsType"/>
 <xsd:complexType name="ConditionsType">
  <xsd:choice maxOccurs="unbounded">
   <xsd:element ref="policy-arc:GroupIdRef"/>
   <xsd:element ref="policy-arc:Condition"/>
  </xsd:choice>
 </xsd:complexType>

 <!--"ConditionGroup" information includes a few Conditions, and is stored in a file independent to policy file. It is reasonable when the 
 administrator wants to define some general condition constraints.-->
 <xsd:element name="ConditionGroup" type="policy-arc:ConditionGroupType"/>
 <xsd:complexType name="policy-arc:ConditionGroupType">
  <xsd:sequence>
   <xsd:element ref="policy-arc:Condition" maxOccures="unbounded"/>
  </xsd:sequence>
  <xsd:attribute name="GroupId" type="xsd:anyURI" use="required">
 </xsd:complexType>

 <xsd:element name="Condition" type="policy-arc:ConditionType"/>
 <xsd:complexType name="ConditionType">
  <xsd:choice maxOccures="unbounbded">
   <!--One choice, if there are more than two fractions in one Condition, the request should match all of these fractions.-->
   <!--If minOccures<"2", we can use the other choice-->
   <xsd:sequence minOccures="2">
    <xsd:element ref="CondFraction" maxOccurs="unbounded/">
   </xsd:sequence>

   <!-- The other choice:  -->
   <xsd:element ref="policy-arc:Expression"/>
  
  </xsd:choice>
 </xsd:complexType>

 <xsd:element name="CondFraction" type="xacml:CondFractionType"/>
  <xsd:complexType name="CondFractionType">
   <xsd:sequence>
    <xsd:element ref="policy-arc:Expression"/>
   </xsd:sequence>
  </xsd:complexType>

 <!--Example:
  <Expression FunctionId="policy-arc:string-equal">
    <CondValue DataType="xsd:dateTime">14:00</CondValue>
  </Expression>
  -->

 <xsd:element name="Expression" type="policy-arc:ExpressionType"/>
 <xsd:complexType name="ExpressionType">
  <xsd:complexContent>
   <xsd:extension base="policy-arc:VariableType">
    <xsd:sequence>
     <xsd:element ref="policy-arc:Variable" minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
    <xsd:attribute name="FunctionId" type="xsd:anyURI" use="required"/>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>
 
 <!-- Example: <Function FunctionId="function-arc:string-equal"/> -->
 <xsd:element name="Function" type="policy-arc:FunctionType"/>
 <xsd:complexType name="FunctionType">
  <xsd:complexContent>
   <xsd:extension base="policy-arc:VariableType">
    <xsd:attribute name="FunctionId" type="xs:anyURI" use="required"/>
   </xsd:extension>
  </xsd:complexContent>
 </xsd:complexType>


 <xsd:element name="CondValue" type="policy-arc:CondValueType"/>
 <xsd:complexType name="CondValueType">
  <xsd:extension base="policy-arc:VariableType">
   <xsd:sequence>
    <xsd:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
   </xsd:sequence>
   <xsd:attribute name="DataType" type="xs:string" use="required"/>
   <xsd:anyAttribute namespace="##any" processContents="lax"/>
  </xsd:extension>
 </xsd:complexType>

 <xsd:element name="Variable" type="policy-arc:VariableType" abstract="true"/>
 <xsd:complexType name="VariableType" abstract="true"/>

</xsd:schema>
