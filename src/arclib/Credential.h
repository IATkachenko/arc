#ifndef __ARC_CREDENTIAL_H__
#define __ARC_CREDENTIAL_H__

#include <stdlib.h>
#include <stdexcept>
#include <iostream>
#include <string>
#include <openssl/asn1.h>
#include <openssl/pem.h>
#include <openssl/x509.h>
#include <openssl/x509v3.h>
#include <openssl/pkcs12.h>
#include <openssl/err.h>

#include <arc/Logger.h>
#include <arc/DateTime.h>

#include "cert_util.h"

extern "C" {
#include "VOMSAttribute.h"
}


/**Credential class covers the functionality about general processing about certificate/key files, 
 *including cerficate/key parsing, information extracting (such as subject name, issuer name, lifetime, etc.), chain verifying,
 *extension processing about proxy certinfo, extension processing about other general certificate extension
 * (such as voms, it should be the extension-specific code itself (here it is some code about writing and parsing
 * voms-implementing Attibute Certificate/ RFC3281, which will then look as a binary part be embeded into extension 
 * of X509 certificate/proxy certificate) to create, parse and verify the extension, not the Credential class, 
 * so the voms api can still be used
 * if need to process the voms extension).
 * The Crendential class support PEM, DER PKCS12 credential 
 */
  
namespace ArcLib {
  // An exception class for the Credential class.
  /** This is an exception class that is used to handle runtime errors
    discovered in the Credential class.
   */
class CredentialError : public std::runtime_error {
  public:
    // Constructor
    /** This is the constructor of the CredentialError class.
      @param what An explanation of the error.
     */
    CredentialError(const std::string& what="");
};

typedef enum {PEM, DER, PKCS, UNKNOWN} Credformat;

class Credential {
  public:
    /**Constructor*/
    Credential(Arc::Time start = Arc::Time(), Arc::Period lifetime = Arc::Period(12*3600));

    /**Constructor, construct from credential files, this constructor will parse the credential information,
    and put them into "this" */
    Credential(const std::string& cert, const std::string& key, const std::string& cadir, const std::string& cafile);

  private:
    /**Constructor, construct from key and request, it is just a half-matured credential*/
    //Credential(X509_REQ**, EVP_PKEY** key);

    static Arc::Logger credentialLogger;

    void loadKey(BIO* &keybio, EVP_PKEY* &pkey);
    void loadCertificate(BIO* &certbio, X509* &cert, STACK_OF(X509)** certchain);
    void InitVerification(void);

    /**Verify whether the certificate is signed by trusted CAs
     *the verification is not needed for EEC, but needed for verifying a proxy which 
     *is generated by the others
     */
    bool Verify(void);
 
    X509_EXTENSION* CreateExtension(std::string name, std::string data, bool crit = false);

    bool SetProxyPeriod(X509* tosign, X509* issuer, Arc::Time& start, Arc::Period& lifetime);

    bool SignRequestAssistant(Credential* &proxy, EVP_PKEY* &req_pubkey, X509** tosign);

  /************************************/
  /*****Get the information from "this" object**/
  public:

    void LogError(void);   

    /**Get the private key attached to the object*/
    EVP_PKEY* GetPrivKey(void);

    /**Get the certificate attached to the object*/
    X509* GetCert(void);

     /**Get the certificate chain attached to the object*/
    STACK_OF(X509)* GetCertChain(void);

    /**Add an extension to the extension part of the certificate
     @param name, the name of the extension, there OID related with the name 
      should be registered into openssl firstly
     @param data, the data which will be insert into certificate extension  
    */
    bool Credential::AddExtension(std::string name, std::string data, bool crit = false);

    /***/
    bool Credential::AddExtension(std::string name, char** aclist, bool crit = false);

    Credformat getFormat(BIO * in);        

    bool GenerateRequest(BIO* &bio);
    bool GenerateRequest(std::string &content);
    bool GenerateRequest(const char* filename);
  
    bool InquireRequest(BIO* &reqbio);
    bool InquireRequest(std::string &content);
    bool InquireRequest(const char* filename);

    bool SignRequest(Credential* proxy, BIO* outputbio);
    bool SignRequest(Credential* proxy, std::string &content);
    bool SignRequest(Credential* proxy, const char* filename);


  /*************************************/
  /*****General methods for proxy Request, proxy sign********/
  /**Note although we use "proxy" here, the below method can also be used for request and sign for original
  certificate*/

  public:
    /**Make a proxy request, based on the credential information inside "this"
    @param bits  modulus size for RSA key generation, it should be greater than 1024
    @param string which includes the request information, i.e, X509_REQ, which is produced by this method;
    this param is specific for transfering the request to remote end to sign.
    @return the Credential object which includes X509_REQ** and EVP_PKEY** iff successfully make the proxy request,
    otherwise NULL
    */
    //Credential* GenerateRequest(std::string& request, int bits = 1024);


    /**Make all of the extensions for proxy certificate.*
    @param name  the name of the extenstion
    @param data  data of the extension
    @return  the extension stucture iff successfully initialize extension
    */
    //X509_EXTENSION* GenerateExtension(std::string name, std::string data);


    /**Sign a certificate request, based on the proxy request which is generated by GenerateProxyRequest(),
    and certificate in "this" which is used to sign the proxy
    @param req  Credential object which includes X509_REQ* that is generated by GenerateProxyRequest(), the Credential
    object will include the signed certificate, iff successfully gets signing
    @param extensions the extension of the signed certificate
    @param lifetime  lifetime of the proxy certificate
    @param limit  whether give limit constraint for the proxy certificate
    @return  true iff successfully sign the certificate, otherwise false 
    */
    //bool Sign(Credential* req, STACK_OF(X509_EXTENSION) ** extensions, Period lifetime, bool limit);

    /**Sign a certificate request, based on the proxy request which is generated by GenerateProxyRequest(), 
    and certificate in "this" which is used to sign the proxy
    @param req  the request information
    @param extensions the extension of the signed certificate
    @param lifetime  lifetime of the proxy certificate
    @param limit  whether give limit constraint for the proxy certificate
    @return  a string which include the proxy certificate, iff successfully sign the certificate
    */
    //std::string Sign(std::string req, STACK_OF(X509_EXTENSION) ** extensions, Period lifetime, bool limit);

    /**Create a proxy certificate, based on the certificate in "this", so it will generate a self-signed proxy certificate.
    This method includes the GenerateProxyRequest, GererateProxyExtension and SignProxy.
    @param lifetime  lifetime of the proxy certificate
    @param limit  whether give limit constraint for the proxy certificate
    @return  a new Credential object
    */
    //Credential* CreateProxy(std::list<AC*> aclist, std::string extra);

    /**Set the certificate information for "this" by using proxy certificate which is return by siging side*/
    //bool SetCertificate(std::string certificate);

  private:
    // PKI files
    std::string cacertfile_;
    std::string cacertdir_;
    std::string certfile_;
    std::string keyfile_;

    // Verify context 
    cert_verify_context verify_ctx_;

    //Certificate structures
    X509 *           cert_;    //cert
    certType         cert_type_;
    EVP_PKEY *       pkey_;    //private key
    //int              keybits_; 
    STACK_OF(X509) * cert_chain_;  //cert chain
    PROXYCERTINFO*   proxy_cert_info_;
    Credformat       format;
    Arc::Time             start_;
    Arc::Period           lifetime_;

    //Certificate/Proxy certificate request
    X509_REQ* req_;
    RSA* rsa_key_;
    EVP_MD* signing_alg_;
    int keybits_;
    //int init_prime_;

    //Extensions for certificate, such as certificate policy, attributes, etc/
    STACK_OF(X509_EXTENSION)* extensions_;

    //some properties and AC settings */
    int            bits;
    Arc::Time           ac_start;
    Arc::Period         ac_lifetime; //lifetime of attribute
    std::string    policyfile;
    std::string    policylang;
    int            pathlength;

};

}// namespace ArcLib

#endif /* __ARC_CREDENTIAL_H__ */


