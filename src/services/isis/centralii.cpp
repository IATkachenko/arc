// Generated by wsdl2hed
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <arc/loader/Loader.h>
#include <arc/loader/ServiceLoader.h>
#include <arc/message/PayloadSOAP.h>
#include <arc/ws-addressing/WSA.h>

#include "centralii.h"

namespace CentralII {

static Arc::Service *get_service(Arc::Config *cfg, Arc::ChainContext *) { 
    return new CentralIIService(cfg);
}

CentralIIService::CentralIIService(Arc::Config *cfg):Service(cfg),logger(Arc::Logger::rootLogger, "CentralII")
{
    // Define supported namespaces
    ns["iis"]="http://www.nordugrid.org/schemas/iis/2007/06";
    ns["wsa"]="http://www.w3.org/2005/08/addressing";
    ns["wsrf-bf"]="http://docs.oasis-open.org/wsrf/bf-2";
    ns["wsrf-rp"]="http://docs.oasis-open.org/wsrf/rp-2";
    ns["wsrf-rpw"]="http://docs.oasis-open.org/wsrf/rpw-2";
    ns["wsrf-rw"]="http://docs.oasis-open.org/wsrf/rw-2";
}

CentralIIService::~CentralIIService(void)
{
}

Arc::MCC_Status CentralIIService::process(Arc::Message &inmsg, Arc::Message &outmsg)
{
    // Both input and output are supposed to be SOAP
    // Extracting payload
    Arc::PayloadSOAP* inpayload = NULL;
    try {
      inpayload = dynamic_cast<Arc::PayloadSOAP*>(inmsg.Payload());
    } catch(std::exception& e) { };
    if(!inpayload) {
      logger.msg(Arc::ERROR, "input is not SOAP");
      return make_soap_fault(outmsg);
    };
    // Analyzing request
    Arc::XMLNode op = inpayload->Child(0);
    if(!op) {
      logger.msg(Arc::ERROR, "input does not define operation");
      return make_soap_fault(outmsg);
    }; 
    logger.msg(Arc::DEBUG,"process: operation: %s", op.Name().c_str());
    Arc::PayloadSOAP* outpayload = new Arc::PayloadSOAP(ns);
    Arc::PayloadSOAP& res = *outpayload;
    Arc::MCC_Status ret = Arc::STATUS_OK;
    if(MatchXMLName(op, "Register")) {
        res.NewChild("iis:RegisterResponse");
        ret = Register(op, res);
    } else if(MatchXMLName(op, "RemoveRegistrations")) {
        res.NewChild("iis:RemoveRegistrationsResponse");
        ret = RemoveRegistrations(op, res);
    } else if(MatchXMLName(op, "GetRegistrationStatuses")) {
        res.NewChild("iis:GetRegistrationStatusesResponse");
        ret = GetRegistrationStatuses(op, res);
    } else if(MatchXMLName(op, "GetIISList")) {
        res.NewChild("iis:GetIISListResponse");
        ret = GetIISList(op, res);
    } else if(MatchXMLName(op, "DelegateCredentialsInit")) {
        if(!delegation.DelegateCredentialsInit(*inpayload,*outpayload)) {
          delete inpayload;
          return make_soap_fault(outmsg);
        }
    // WS-Property
    } else if(MatchXMLNamespace(op,"http://docs.oasis-open.org/wsrf/rp-2")) {
        Arc::SOAPEnvelope* out_ = infodoc.Process(*inpayload);
        if(out_) {
          *outpayload=*out_;
          delete out_;
        } else {
          delete inpayload; delete outpayload;
          return make_soap_fault(outmsg);
        };
    } else {
        logger.msg(Arc::ERROR,"SOAP operation is not supported: %s", op.Name().c_str());
        return make_soap_fault(outmsg);
    };
    // Set output
    outmsg.Payload(outpayload);
    return Arc::MCC_Status(ret);
}

Arc::MCC_Status CentralIIService::make_soap_fault(Arc::Message& outmsg)
{
    Arc::PayloadSOAP* outpayload = new Arc::PayloadSOAP(ns,true);
    Arc::SOAPFault* fault = outpayload?outpayload->Fault():NULL;
    if(fault) {
        fault->Code(Arc::SOAPFault::Sender);
        fault->Reason("Failed processing request");
    };
    outmsg.Payload(outpayload);
    return Arc::MCC_Status(Arc::STATUS_OK);
}

Arc::MCC_Status CentralIIService::Register(Arc::XMLNode &in, Arc::XMLNode &out)
{
    return Arc::MCC_Status();
}

Arc::MCC_Status CentralIIService::RemoveRegistrations(Arc::XMLNode &in, Arc::XMLNode &out)
{
    return Arc::MCC_Status();
}

Arc::MCC_Status CentralIIService::GetRegistrationStatuses(Arc::XMLNode &in, Arc::XMLNode &out)
{
    return Arc::MCC_Status();
}

Arc::MCC_Status CentralIIService::GetIISList(Arc::XMLNode &in, Arc::XMLNode &out)
{
    return Arc::MCC_Status();
}

}; // namespace CentralII

service_descriptors ARC_SERVICE_LOADER = {
    { "centralii", 0, &CentralII::get_service },
    { NULL, 0, NULL }
};
