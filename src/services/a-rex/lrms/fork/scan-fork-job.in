#!/bin/sh
#
#  Periodically monitor for jobs which has finished or failed but not
#  reported an exitcode
#

set -e

id=`id -u`

#debug='eval echo >> @tmp_dir@/parse-fork-log.$id'
debug=:

$debug "run at `date`"
$debug "options = $@"

if [ -z "$1" ] ; then echo "Argument missing" >&2 ; exit 1 ; fi

for control_dir in "$@" ; do

    if [ ! -d "${control_dir}" ]; then 
	echo "No control dir $control_dir" >&2
        continue
    fi

    # iterate over all jobs known in the control directory
    for job in `grep -l INLRMS ${control_dir}/job.*.status 2>/dev/null | sed -e 's/.*job.//' -e 's/.status.*$//'` ; do
        $debug "scanning job = $job"
        unset joboption_jobid
	unset joboption_user
        unset joboption_directory

        # this job was already completed, nothing remains to be done
        [ -f "${control_dir}/job.${job}.lrms_done" ] && continue

	# a grami file exists for all jobs that GM thinks are running.
        # proceed to next job if this file is missing.
        if [ ! -f "${control_dir}/job.${job}.grami" ]; then
            continue
        fi

        # extract process IDs of the grami file
        . "${control_dir}/job.${job}.grami"

        # process IDs could not be learned, proceeding to next
        [ -z "$joboption_jobid" ] && continue
    
        $debug "local jobid = $joboption_jobid"
        $debug "local user  = $joboption_user"
    
        ps -ouser= -p$joboption_jobid > /dev/null
        rc=$?
	$debug "ps returned $rc"
        [ $rc -eq 0 ] && continue

        # checking if process is still running
        if ps -ouser= -p$joboption_jobid > /dev/null; then
            $debug "ps returned $? - process $joboption_jobid of job $job is still running. Continuing to next"
            continue
        else
            $debug "ps returned $? - process $joboption_jobid of job $job has exited!"
        fi

        $debug "checking ${joboption_directory}.diag"
        if [ `id -u` -eq '0' ] ; then
          exitcode=`su "${joboption_user}" -c "cat ${joboption_directory}.diag" 2>/dev/null | sed -n 's/^exitcode=\([0-9]*\).*/\1/p'`
        else
          exitcode=`cat "${joboption_directory}.diag" 2>/dev/null | sed -n 's/^exitcode=\([0-9]*\).*/\1/p'`
        fi
        $debug "exitcode = [$exitcode] extracted from ${joboption_directory}.diag"
        if [ -z "$exitcode" ] ; then
	  $debug "checking ${control_dir}/job.${job}.diag"
          exitcode=`cat "${control_dir}/job.${job}.diag" 2>/dev/null | sed -n 's/^exitcode=\([0-9]*\).*/\1/p'`
          $debug "exitcode = [$exitcode] extracted from ${control_dir}/job.${job}.diag"
	fi	
        fork_comment=""
	if [ -z "$exitcode" ]; then
            echo "Job $job with PID $joboption_jobid died unexpectedly" >&2
            fork_comment="Job died unexpectedly" >&2
    	    exitcode=1
	elif [ "$exitcode" -ne '0' ]; then
            fork_comment="Job finished with non-zero exit code" >&2
	fi
        $debug "got exitcode=$exitcode"
	echo "$exitcode $fork_comment" > "${control_dir}/job.${job}.lrms_done"
    done    

done

$debug "done, going to sleep"

sleep 10
exit 0
