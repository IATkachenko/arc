#!@posix_shell@
#
#  Periodically monitor for jobs which has finished or failed but not
#  reported an exitcode
#

set -e

id=`id -u`

#debug='eval echo >> @tmp_dir@/parse-fork-log.$id'
debug=:

$debug "run at `date`"
$debug "options = $@"

if [ -z "$1" ] ; then echo "Argument missing" 1>&2 ; exit 1 ; fi

# Prints the owner of the file given as argument
# Perl is used because it's more protable than using the stat command
printowner () {
  code='$f=$ARGV[0];if(@s=stat $f){@p=getpwuid $s[4];if(@p){print $p[0]}else{exit 1}}else{die "$f: $!\n"}'
  perl -we "$code" "$1"
}

# Append .comment (containing STDOUT & STDERR of the job wrapper) to .errors
save_commentfile () {
  username=$1
  commentfile=$2
  errorsfile=$3
  action="
    { echo '---------- Contents of output stream from job wrapper -----------'
      cat '$commentfile' 2> /dev/null
      echo '------------------------- End of output -------------------------'
    } >> '$errorsfile'
  "
  if [ -z "$username" ] ; then
    eval "$action"
  else
    su "$username" -c "eval \"$action\""
  fi
}

for control_dir in "$@" ; do

    if [ ! -d "${control_dir}" ]; then 
	echo "No control dir $control_dir" 1>&2
        continue
    fi

    # iterate over all jobs known in the control directory
    find ${control_dir} -name 'job.[0-9]*.status' \
    | xargs grep -l INLRMS \
    | sed -e 's/.*job\.//' -e 's/\.status$//' \
    | while read job; do
        $debug "scanning job = $job"
        unset joboption_jobid
        unset joboption_directory

        # this job was already completed, nothing remains to be done
        [ -f "${control_dir}/job.${job}.lrms_done" ] && continue

        # a grami file exists for all jobs that GM thinks are running.
        # proceed to next job if this file is missing.
        if [ ! -f "${control_dir}/job.${job}.grami" ]; then
            continue
        fi

        # extract process IDs of the grami file
        . "${control_dir}/job.${job}.grami"

        # process IDs could not be learned, proceeding to next
        [ -z "$joboption_jobid" ] && continue
    
        $debug "local jobid = $joboption_jobid"

        # checking if process is still running
        if ps -ouser= -p$joboption_jobid > /dev/null; then
            $debug "ps returned $? - process $joboption_jobid of job $job is still running. Continuing to next"
            continue
        else
            $debug "ps returned $? - process $joboption_jobid of job $job has exited!"
        fi

        $debug "checking ${joboption_directory}.diag"
        if [ "$id" = '0' ] ; then
          username=`printowner "${control_dir}/job.${job}.local"`
          exitcode=`su "$username" -c "cat ${joboption_directory}.diag" 2>/dev/null | sed -n 's/^exitcode=\([0-9]*\).*/\1/p'`
        else
          username=
          exitcode=`cat "${joboption_directory}.diag" 2>/dev/null | sed -n 's/^exitcode=\([0-9]*\).*/\1/p'`
        fi
        $debug "local user  = $username"
        $debug "exitcode = [$exitcode] extracted from ${joboption_directory}.diag"
        if [ -z "$exitcode" ] ; then
	  $debug "checking ${control_dir}/job.${job}.diag"
          exitcode=`cat "${control_dir}/job.${job}.diag" 2>/dev/null | sed -n 's/^exitcode=\([0-9]*\).*/\1/p'`
          $debug "exitcode = [$exitcode] extracted from ${control_dir}/job.${job}.diag"
	fi	
        fork_comment=""
	if [ -z "$exitcode" ]; then
            echo "Job $job with PID $joboption_jobid died unexpectedly" 1>&2
            fork_comment="Job died unexpectedly" 1>&2
    	    exitcode=1
	elif [ "$exitcode" -ne '0' ]; then
            fork_comment="Job finished with non-zero exit code" 1>&2
	fi
        $debug "got exitcode=$exitcode"
        save_commentfile "$username" "${joboption_directory}.comment" "${control_dir}/job.${job}.errors"
	echo "$exitcode $fork_comment" > "${control_dir}/job.${job}.lrms_done"
    done    

done

$debug "done, going to sleep"

sleep 10
exit 0
