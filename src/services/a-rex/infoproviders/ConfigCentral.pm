package ConfigCentral;

# Builds an intermediate config hash that is used by the A-REX infoprovider and LRMS control scripts
# Can read XML and INI

use strict;
use warnings;

use XML::Simple;
use Data::Dumper qw(Dumper);

use ConfigParser;
use LogUtils;

# Logging not configured yet, so loglevel is WARNING.
our $log = LogUtils->getLogger(__PACKAGE__);

############################ Generic functions ###########################

# walks a tree of hashes and arrays while applying a function to each hash.
sub hash_tree_apply {
    my ($ref, $func) = @_;
    if (not ref($ref)) {
        return;
    } elsif (ref($ref) eq 'ARRAY') {
        map {hash_tree_apply($_,$func)} @$ref;
        return;
    } elsif (ref($ref) eq 'HASH') {
        &$func($ref);
        map {hash_tree_apply($_,$func)} values %$ref;
        return;
    } else {
        return;
    }
}

# Strips namespace prefixes from the keys of the hash passed by reference
sub hash_strip_prefixes {
    my ($h) = @_;
    my %t;
    while (my ($k,$v) = each %$h) {
        next if $k =~ m/^xmlns/;
        $k =~ s/^\w+://;
        $t{$k} = $v;
    }
    %$h=%t;
    return;
}

# Works on a hash generated by XMLSimple with ForceArray => 1. It takes a
# reference to a hash followedby a list of key names to be excluded from
# processing.  Except for the excluded keys, values of keys containing an array
# are replaced with the last elementof the array.
sub hash_collapse_arrays {
    my ($h, @preserve) = @_;
    while (my ($k,$v) = each %$h) {
        next unless ref($v) eq 'ARRAY';
        next if grep {$k eq $_} @preserve;
        $v = pop @$v;
		# XMLSimple converts empty elements into an empty hash.
        # Replace these with the empty string.
        $v = '' if ref $v eq 'HASH' and not scalar %$v;
        $h->{$k} = $v;
    }
    return $h;
}

# Expects a hash as returned by ConfigParser::get_section(). A list of options
# that are multivalued are passed asthe remaining arguments.  Values
# corresponding to multivalued INI options are converted to arrays. For other
# options only the last value is retained.
sub section_expand_multivalued {
    my ($h, @multivalued) = @_;
    while (my ($k,$v) = each %$h) {
        next if ref $v; # skip anything other than arrays of scalars
        $h->{$k} = [split '\[separator\]', $v];
        unless (grep {$k eq $_} @multivalued) {
            $h->{$k} = pop @{$h->{$k}}; # single valued options, remember last defined value only
        }
    }
    return $h;
}

# Returns a hash cleaned of keys with values other that scalars or array of scalars.
sub hash_extract_onelevel {
    my ($h) = @_;
    my %t;
    while (my ($k,$v) = each %$h) {
        $t{$k} = $v and next if not ref $v;
        $t{$k} = $v if ref $v eq 'ARRAY' and not ref $v->[0];
    }
    return \%t;
}

sub fixbools {
    my ($h,$bools) = @_;
    for my $key (@$bools) {
        next unless exists $h->{$key};
        my $val = $h->{$key};
        if ($val eq '0' or lc $val eq 'false' or lc $val eq 'no') {
            $h->{$key} = 'false';
        } elsif ($val eq '0' or lc $val eq 'true' or lc $val eq 'yes') {
            $h->{$key} = 'true';
        } else {
            $log->error("Invalid value for $key");
        }
    }
    return $h;
}

############################ ARC xml config ##############################

sub read_arex_config {
    my ($file) = @_;
    my $nameAttr = {Service => 'name'};
    my %xmlopts = (NSexpand => 0, ForceArray => 1, KeepRoot => 1, KeyAttr => $nameAttr);
    my $xml = XML::Simple->new(%xmlopts);
    my $data = $xml->XMLin($file);
    hash_tree_apply $data, \&hash_strip_prefixes;
    return $data->{Service}{'a-rex'}
        || $data->{ArcConfig}[0]{Chain}[0]{Service}{'a-rex'}
        || undef;
}

sub build_config_from_inifile {
    my ($inifile) = @_;
    my $iniparser = ConfigParser->new($inifile);
    if (not $iniparser) {
        print STDERR "Cannot open $inifile\n";
        return undef;
    }
    my $config = {};
    %$config = (%$config, $iniparser->get_section("common"));
    %$config = (%$config, $iniparser->get_section("grid-manager"));

    $config->{service} = {$iniparser->get_section("ComputingService")};
    fixbools $config->{service}, ['sharedFilesystem', 'sharedScratchDir'];

    $config->{control} = {};
    $config->{xenvs} = {};
    $config->{shares} = {};

    my @cnames = $iniparser->list_subsections('grid-manager');
    for my $name (@cnames) {
        $config->{control}{$name} = {$iniparser->get_section("grid-manager/$name")};
    }
    my @gnames = $iniparser->list_subsections('ExecutionEnvironment');
    for my $name (@gnames) {
        my $xeconf = $config->{xenvs}{$name} = {$iniparser->get_section("ExecutionEnvironment/$name")};
        fixbools $xeconf, ['Homogeneous', 'VirtualMachine', 'ConnectivityIn', 'ConnectivityOut'];
    }
    my @snames = $iniparser->list_subsections('ComputingShare');
    for my $name (@snames) {
        my $sconf = $config->{shares}{$name} = {$iniparser->get_section("ComputingShare/$name")};
        fixbools $sconf, ['Preemption'];
    }
	my @multival = qw(cachedir remotecachedir sessiondir maxloadshare condor_requirements
                      OpSys Middleware LocalSE ClusterOwner Benchmark OtherInfo
                      StatusInfo NodeSelectionRegex ExecEnvName AuthorizedVO);
    hash_tree_apply $config, sub { section_expand_multivalued shift, @multival };
    #print(Dumper $config);
    return $config;
}

sub build_config_from_parsed_xml {
    my ($arex) = @_;
    my $config = {};

	my @multival = qw(cache location control sessionRootDir maxJobsPerShare
                      OpSys Middleware LocalSE ClusterOwner Benchmark OtherInfo
                      StatusInfo Regex ExecEnvName AuthorizedVO
                      Contact ExecutionEnvironment ComputingShare);
    hash_tree_apply $arex, sub { hash_collapse_arrays shift, @multival };

    $config->{endpoint} = $arex->{endpoint} if $arex->{endpoint};
    $config->{ttl} = $arex->{InfoproviderWakeupPeriod} if $arex->{InfoproviderWakeupPeriod};
    $config->{runtimedir} = $arex->{runtimeDir} if $arex->{runtimeDir};
    $config->{scratchdir} = $arex->{scratchDir} if $arex->{scratchDir};
    $config->{sharedScratchDir} = $arex->{sharedScratchDir} if $arex->{sharedScratchDir};
    $config->{sharedFilesystem} = $arex->{sharedFilesystem} if $arex->{sharedFilesystem};
    $config->{gnu_time} = $arex->{GNUTimeUtility} if $arex->{GNUTimeUtility};
    $config->{tmpdir} = $arex->{tmpDir} if $arex->{tmpDir};

    $config->{control}{'.'} = {};
    $config->{xenvs} = {};
    $config->{shares} = {};

    $log->error("No control element in config") unless $arex->{control};
    for my $control (@{$arex->{control}}) {
        my $user = $control->{username} || '.';
        my $cconf = {};

        my $controldir = $control->{controlDir};
        $cconf->{controldir} = $controldir if $controldir;
        my $sessiondirs =  $control->{sessionRootDir}; # an array
        $cconf->{sessiondir} = $sessiondirs if $sessiondirs;

        my $ttl = $control->{defaultTTL} || '';
        my $ttr = $control->{defaultTTR} || '';
        $cconf->{defaultttl} = "$ttl $ttr" if $ttl;

        for my $cache (@{$control->{cache}}) {
            my $type = $cache->{type} || '';
            for (@{$cache->{location}}) {
                my $loc = $_->{path};
                next unless $loc;
                push @{$cconf->{cachedir}}, $loc if $type ne 'REMOTE';
                push @{$cconf->{remotecachedir}}, $loc if $type eq 'REMOTE';
            }
        }
        $config->{control}{$user} = $cconf;
    }
    # Merge control options for default user
    $config = { %$config, %{$config->{control}{'.'}} };
    delete $config->{control}{'.'};
    delete $config->{control} unless keys %{$config->{control}};

    my $globus = $arex->{dataTransfer}{Globus};
    $log->warning("No Globus element in config") unless $globus;
    $config->{x509_user_cert} = $globus->{certpath} if $globus->{certpath};
    $config->{x509_user_key} = $globus->{keypath} if $globus->{keypath};
    $config->{x509_cert_dir} = $globus->{cadir} if $globus->{cadir};
    $config->{gridmap} = $globus->{gridmapfile} if $globus->{gridmapfile};

    my $load = $arex->{loadLimits};
    $log->warning("No loadLimits element in config") unless $load;
    my $maxjobs = $load->{maxJobsTracked} || '';
    my $maxjobsrun = $load->{maxJobsRun} || '';
    $config->{maxjobs} = "$maxjobs $maxjobsrun";

    for my $ts (@{$load->{maxJobsPerShare}}) {
        push @{$config->{maxloadshare}}, $ts->{content}." ".$ts->{shareType};
    }

    if (my $lrms = $arex->{LRMS}) {
        $config->{lrms} = $lrms->{type} if $lrms->{type};
        %$config = (%$config, %{$arex->{LRMS}});
    }

    my $csrv = $arex->{ComputingService} || {};

    $config->{service} = { %$config, %{hash_extract_onelevel $csrv} };
    fixbools $config->{service}, ['sharedFilesystem', 'sharedScratchDir'];

    $config->{Location} = $csrv->{Location} if $csrv->{Location};
    $config->{Contact} = $csrv->{Contact} if $csrv->{Contact};

    my $xenvs = $csrv->{ExecutionEnvironment};
    $log->warning("No ExecutionEnvironment element in config") unless $xenvs;
    for my $xe (@{$xenvs}) {
        my $name = $xe->{name};
        $log->error("ExecutionEnvironment witout name") unless $name;
        delete $xe->{name};
        my $xeconf = $config->{xenvs}{$name} = {};
        %$xeconf = %{hash_extract_onelevel $xe};

        fixbools $xeconf, ['Homogeneous', 'VirtualMachine', 'ConnectivityIn', 'ConnectivityOut'];
    }

    my $shares = $csrv->{ComputingShare};
    $log->warning("No ComputingShare element in config") unless $shares;
    for my $s (@{$shares}) {
        my $name = $s->{name};
        $log->error("ComputingShare without name") unless $name;
        delete $s->{name};
        my $sconf = $config->{shares}{$name} = {};
        %$sconf = %{hash_extract_onelevel $s};

        fixbools $sconf, ['Preemption'];
    }

    #print(Dumper $config);
    return $config;
}

# add options from config2 to config1.
# values defined in config2 take precendence.
sub merge_configs {
    my ($conf1, $conf2) = @_;
    $conf1 = { %$conf1, %{hash_extract_onelevel $conf2} };
    my @branches = qw(control xenvs shares);
    $conf2->{$_} or $conf2->{$_} = {} for @branches;
    for my $type (@branches) {
        for my $name (keys %{$conf2->{$type}}) {
            my $oldhash = $conf1->{$type}{$name} || {};
            $conf1->{$type}{$name} = { %$oldhash, %{$conf2->{$type}{$name}} };
        }
    }
    keys %{$conf1->{$_}} or delete $conf1->{$_} for @branches;
    return $conf1;
}


################### support for shell scripts ############################

{
    my $nb;

    sub _print_shell_start { my $nb = 0 }
    sub _print_shell_end { print "_CONFIG_NUM_BLOCKS=$nb\n" }
    
    sub _print_shell_section {
        my ($bn,$opts) = @_;
        $nb++;
        my $prefix = "_CONFIG_BLOCK$nb";

        print $prefix."_NAME=\Q$bn\E\n";
        my $no=0;
        while (my ($opt,$val)=each %$opts) {
            unless ($opt =~ m/^\w+$/) {
                print "echo config_parser: Skipping malformed option \Q$opt\E 1>&2\n"; 
                next;
            }
            if (not ref $val) {
                $no++;
                $val = '' if not defined $val;
                print $prefix."_OPT${no}_NAME=$opt\n";
                print $prefix."_OPT${no}_VALUE=\Q$val\E\n";
            } elsif (ref $val eq 'ARRAY') {
                # multi-valued option
                for (my $i=0; $i<@$val; $i++) {
                    $no++;
                    $val->[$i] = '' if not defined $val->[$i];
                    print $prefix."_OPT${no}_NAME=$opt"."_".($i+1)."\n";
                    print $prefix."_OPT${no}_VALUE=\Q@{[$val->[$i]]}\E\n";
                }
            }
        }
        print $prefix."_NUM=$no\n";
    }
}

# Reads an XML config file containing config for A-REX and prints out
# configuration options for LRMS control scripts.  It's meant to be used by
# 'config_parser.sh'.

sub printConfigForShell($) {
    my $xmlfile = shift;
    my $config = parseConfig($xmlfile);

    _print_shell_start();
    _print_shell_section('common', hash_extract_onelevel $config);
    for my $sname (keys %{$config->{shares}}) {
        _print_shell_section("queue/$sname", $config->{shares}{$sname});
    }
    _print_shell_end();
}

# If the gmconfig option is present, it will parse the linked ini file.
# Otherwise it will extract LRMS options from XML config.
sub parseConfig {
    my $xmlfile = shift;
    my $arex = read_arex_config($xmlfile);
    my $config = build_config_from_parsed_xml($arex);
    # Ignore INI for now
    #if ($arex->{gmconfig} and (not exists $arex->{gmconfig}{type}
    #                                   or $arex->{gmconfig}{type} eq 'INI') ) {
    #    my $inifile = $arex->{gmconfig}{content};
    #    my $iniconfig = build_config_from_inifile($inifile);
    #    $config = merge_configs($config, $iniconfig);
    #}
    $log->error("A-REX service configuration format has changed. See 'install_prefix/share/doc/arc/arex_service-secure-xml.xml.example'")
        unless %{$config->{service}} and %{$config->{xenvs}} and %{$config->{shares}};
    #print(Dumper $config);
    return $config;
}

1;

__END__
