#!/usr/bin/perl -w

package CEInfo;

use File::Basename;
use Getopt::Long;
use XML::Simple;
use Data::Dumper;
use Cwd;

use strict;

BEGIN {
    my $pkglibdir = dirname($0).'/@pkglibdir_rel_to_pkglibexecdir@';
    unshift @INC, $pkglibdir;
}

########################################################
# Driver for information collection
# Reads old style arc.config and prints out XML
########################################################

use ConfigCentral;
use LogUtils; 

use HostInfo;
use GMJobsInfo;
use LRMSInfo;

use ARC0ClusterInfo;
use ARC1ClusterInfo;

use InfoChecker;

our $log = LogUtils->getLogger(__PACKAGE__);


sub main {

    LogUtils::setLevel('INFO');

    ########################################################
    # Config defaults
    ########################################################
    
    my %config_defaults = (
                   InfoproviderWakeupPeriod  =>  600,
                   PublishNordugrid  =>  'false',
                   arcversion     => '@VERSION@',
                   gm_mount_point => "/jobs",
                   gm_port        => 2811,
                   defaultttl     => "604800",
                   x509_user_cert => "/etc/grid-security/hostcert.pem",
                   x509_cert_dir  => "/etc/grid-security/certificates/",
                   gridmap        => "/etc/grid-security/grid-mapfile",
                   connectivityIn => "false",
                   connectivityOut=> "false",
                   processes      => [qw(arched)]
    
    );


    ########################################################
    # Parse command line options
    ########################################################
    
    my $configfile;
    my $print_help;
    GetOptions("config:s" => \$configfile,
               "help|h"   => \$print_help ); 
        
    if ($print_help) { 
        print "Usage: $0 <options>
        --config   - location of arc.conf
        --help     - this help\n";
        exit 1;
    }
    
    unless ( $configfile ) {
        $log->error("a command line argument is missing, see --help ");
    }
    
    ##################################################
    # Read ARC configuration
    ##################################################
    
    my $config = ConfigCentral::parseConfig($configfile);
    $config = { %config_defaults, %$config};

    $config->{control} = {} unless $config->{control};
    $config->{xenvs} = {} unless $config->{xenvs};
    $config->{shares} = {} unless $config->{shares};
    $config->{queues} = {} unless $config->{queues};


    # Change level for root logger (affects all loggers from now on)
    LogUtils::setLevel($config->{debugLevel}) if defined $config->{debugLevel};

    # Cross-check ExecutionEnvironment references
    for my $s (values %{$config->{shares}}) {
        next unless $s->{ExecEnvName};
        for my $group (@{$s->{ExecEnvName}}) {
            $log->error("No such ExecutionEnvironment: $group")
                unless $config->{xenvs}{$group};
        }
    }

    my $defaultshare = $config->{defaultShare};
    $log->error("defaultShare set to nonexistent ComputingShare")
        if $defaultshare and not $config->{shares}{$defaultshare};

    if ($config->{endpoint} =~ m{^\w+://([^:]+):(\d+)}) {
        $config->{hostname} = $1;
        $config->{arexport} = $2;
    } else {
        $log->error("missing config option: endpoint");
    }

    if ($config->{Contact}) {
        for (@{$config->{Contact}}) {
            $log->warning("URI expected in Contact Detal: ".$_->{Detail}) unless $_->{Detail} =~ m/^\w+:/;
        }
    }

    ##################################################
    # Collect information & print XML
    ##################################################

    my $xml = new XML::Simple(NoAttr => 0, ForceArray => 1, RootName => 'InfoRoot', KeyAttr => ['name']);
    my $cluster_info = CEInfo::collect($config);
    print $xml->XMLout($cluster_info);
}
    

##################################################
# Unified information collector for NG and GLUE2
##################################################

my $config_schema = {
    lrms => '',              # name of the LRMS module
    gridmap => '',
    x509_user_cert => '',
    x509_cert_dir => '',
    controldir => '',
    sessiondir => [ '' ],
    cachedir => [ '*' ],
    runtimeDir => '*',
    processes => [ '' ],
    service => {
        Name => '',
        AdminDomain => '',
    },
    xenvs => {              # node group names are keys in this hash
        '*' => {
        }
    },
    shares => {              # share names are keys in this hash
        '*' => {
        }
    }
};

sub collect($) {
    my ($config) = @_;
    my ($checker, @messages);

    $log->error("missing config option: endpoint") unless $config->{endpoint};
    $log->error("missing config option: ComputingService: AdminDomain") unless $config->{service}{AdminDomain};
    $log->error("missing config option: ComputingService: Name") unless $config->{service}{Name};

    $checker = InfoChecker->new($config_schema);
    @messages = $checker->verify($config);
    $log->warning("config key config->$_") foreach @messages;
    $log->fatal("Some required config options are missing") if @messages;


    # get all local users from grid-map. Sort unique
    my %saw = ();
    my $usermap = read_grid_mapfile($config->{gridmap});
    my @localusers = grep !$saw{$_}++, values %$usermap;

    my $gmjobs_info = get_gmjobs_info($config);

    my @jobids;
    for my $job (values %$gmjobs_info) {
        next unless $job->{status} eq 'INLRMS';
        next unless $job->{localid};
        push @jobids, $job->{localid};
    }

    my $input = {};
    $input->{config} = $config;
    $input->{usermap} = $usermap;
    $input->{host_info} = get_host_info($config,\@localusers);
    $input->{gmjobs_info} = $gmjobs_info;
    $input->{lrms_info} = get_lrms_info($config,\@localusers,\@jobids);

    fix_adotf($config, $input->{host_info});
    fix_adotf($_, $input->{host_info}) for values %{$config->{xenvs}};

    my $cluster_info;
    my $png = $config->{service}{PublishNordugrid};
    if (defined $png and $png eq 'true') {
        $cluster_info->{'n:nordugrid'} = ARC0ClusterInfo::collect($input);
        $cluster_info->{'n:nordugrid'}{'xmlns:n'} = "urn:nordugrid-cluster";
    }
    $cluster_info->{'Domains'}->{'xmlns'} = "http://schemas.ogf.org/glue/2008/05/spec_2.0_d41_r01";
    $cluster_info->{'Domains'}->{'xmlns:xsi'} = "http://www.w3.org/2001/XMLSchema-instance";
    $cluster_info->{'Domains'}->{'xsi:schemaLocation'} = "http://schemas.ogf.org/glue/2008/05/spec_2.0_d41_r01 pathto/GLUE2.xsd";
    $cluster_info->{'Domains'}->{'AdminDomain'}->{'xmlns'} = "http://schemas.ogf.org/glue/2008/05/spec_2.0_d41_r01";
    $cluster_info->{'Domains'}->{'AdminDomain'}->{'Services'}->{'xmlns'} = "http://schemas.ogf.org/glue/2008/05/spec_2.0_d41_r01";
    $cluster_info->{'Domains'}->{'AdminDomain'}->{'Services'}->{'ComputingService'} = ARC1ClusterInfo::collect($input);

    return $cluster_info;
}


##################################################
# Calling other information collectors
##################################################

sub get_host_info($$) {
    my ($config,$localusers) = @_;

    my $host_opts = Storable::dclone($config);
    $host_opts->{localusers} = $localusers;
    $host_opts->{libexecdir} = dirname($0);

    return HostInfo::collect($host_opts);
}

sub get_lrms_info($$$) {
    my ($config,$localusers,$jobids) = @_;

    # possibly any options from config are needed, so just clone it all
    my $lrms_opts = Storable::dclone($config);
    delete $lrms_opts->{$_} for qw(control xenvs shares);
    $lrms_opts->{jobs} = $jobids;
    for my $share ( keys %{$config->{shares}} ) {
        $lrms_opts->{queues}{$share} = $config->{shares}{$share};
        $lrms_opts->{queues}{$share}{users} = $localusers;
    }

    return LRMSInfo::collect($lrms_opts);
}

sub get_gmjobs_info($) {
    my $config = shift;
    $log->error("controldir option missing") unless $config->{controldir};
    my $gmjobs_info = GMJobsInfo::collect($config->{controldir});

    for my $jobid (keys %$gmjobs_info) {
        my $job = $gmjobs_info->{$jobid};
        my $share = $job->{share};

        # If A-REX has not choosen a share for the job, default to one.
        if (not $share) {
            my $msg = "A-REX has not choosen a share for job $jobid";
            if ($config->{defaultShare}) {
                $log->info($msg.". Assuming default: ".$config->{defaultShare});
                $share = $config->{defaultShare};
            } else {
                my @shares = keys %{$config->{shares}};
                if (@shares == 1) {
                    $log->info($msg.". Assuming: ".$shares[0]);
                    $share = $shares[0];
                } else {
                    $log->warning($msg." and no default share is defined.");
                }
            }
        }

        # Set correct queue
        if ($share) {
            my $sconfig = $config->{shares}{$share};
            if ($sconfig) {
                $job->{queue} = $sconfig->{MappingQueue} if $sconfig->{MappingQueue}
            } else {
                $log->warning("Job $jobid belongs to an unconfigured share '$share'");
                $share = undef;
            }
        }

		# Group jobs not belonging to any known share into a catch-all share named ''
        $job->{share} = $share || '';
    }
    return $gmjobs_info;
}

#### reading grid-mapfile #####

sub read_grid_mapfile($) {
    my $gridmapfile = shift;
    my $usermap = {};

    unless (open MAPFILE, "<$gridmapfile") {
        $log->warning("can't open gridmapfile at $gridmapfile");
        return;
    }
    while (my $line = <MAPFILE>) {
        chomp($line);
        if ( $line =~ m/\"([^\"]+)\"\s+(\S+)/ ) {
            $usermap->{$1} = $2;
        }
    }
    close MAPFILE;

    return $usermap;
}


sub fix_adotf {
    my ($config, $hostinfo) = @_;
    my %hostkey = (Platform => 'architecture',
                   PhysicalCPUs => 'cpusocketcount',
                   LogicalCPUs => 'cputhreadcount',
                   CPUVendor => 'cpuvendor',
                   CPUModel => 'cpumodel',
                   CPUClockSpeed => 'cpufreq',
                   MainMemorySize => 'memtotal',
                   OSFamily => 'osfamily'
    );
    for my $key (keys %hostkey) {
        if (exists $config->{$key} and $config->{$key} eq 'adotf') {
            $log->error("Failed to autodetect value for '$key'. Enter correct value in config file")
                unless defined $hostinfo->{$hostkey{$key}};
            $config->{$key} = $hostinfo->{$hostkey{$key}};
        }
    }
    
};

main();
