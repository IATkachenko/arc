\documentclass{article}
%\documentclass{book}
\usepackage{graphicx}                              %for PNG images (pdflatex)
\usepackage[linkbordercolor={1.0 1.0 0.0}]{hyperref} %for \url tag
\usepackage{color}                                 %for defining custom colors
\usepackage{framed}                                %for shaded and framed paragraphs
\usepackage{textcomp}                              %for various symbols, e.g. Registered Mark
\usepackage{geometry}                              %for defining page size
\usepackage{longtable}                             %for breaking tables
\usepackage{array}
\usepackage{booktabs}
%
\geometry{verbose,a4paper,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2cm}
\hypersetup{
  pdfauthor = {Martin Skou Andersen},
  pdftitle = {WS-ARC service configuration manual},
  pdfsubject = {Paper subject},
  pdfkeywords = {Paper,keyword,comma-separated},
  pdfcreator = {PDFLaTeX with hyperref package},
  pdfproducer = {PDFLaTeX}
}
%
\bibliographystyle{IEEEtran}                       %a nice bibliography style
%
\def\efill{\hfill\nopagebreak}%
\hyphenation{Nordu-Grid}
\setlength{\parindent}{0cm}
\setlength{\FrameRule}{1pt}
\setlength{\FrameSep}{8pt}
\addtolength{\parskip}{5pt}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\arraystretch}{1.3}
\newcommand{\dothis}{\colorbox{shadecolor}}
\newcommand{\ngdl}{\url{http://ftp.nordugrid.org/download}~}
\definecolor{shadecolor}{rgb}{1,1,0.6}
\definecolor{salmon}{rgb}{1,0.9,1}
\definecolor{bordeaux}{rgb}{0.75,0.,0.}
\definecolor{cyan}{rgb}{0,1,1}
\definecolor{grey}{rgb}{0.9,0.9,0.9}

\usepackage{listings}
 \lstset{
         basicstyle=\small\ttfamily,
         numbers=none,
         numberstyle=\tiny,
         stepnumber=1,
         numbersep=5pt,
         tabsize=2,
         extendedchars=true,
         breaklines=true,
         keywordstyle=\color{red},
 %        keywordstyle=[1]\textbf,
 %        keywordstyle=[2]\textbf,
 %        keywordstyle=[3]\textbf,
 %        keywordstyle=[4]\textbf,   \sqrt{\sqrt{}} %
         stringstyle=\color{blue}\ttfamily,
         showspaces=false,
         showtabs=false,
         xleftmargin=17pt,
         frame=single,
         framexleftmargin=17pt,
         framexrightmargin=5pt,
         framexbottommargin=4pt,
         framextopmargin=4pt,
         backgroundcolor=\color{grey},
         showstringspaces=false
 }
 \lstloadlanguages{
  sh,
  XML
 }

% Make lineshift after paragrah...
\makeatletter
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
  {-3.25ex\@plus -1ex \@minus -.2ex}%
  {1.5ex \@plus .2ex}%
  {\normalfont\normalsize\bfseries}}
\makeatother

 %
%----- DON'T CHANGE HEADER MATTER
\hyphenation{preserve-Original}
\begin{document}
\def\today{\number\day/\number\month/\number\year}

\begin{titlepage}

\begin{tabular}{rl}
\resizebox*{3cm}{!}{\includegraphics{ng-logo.png}}
&\parbox[b]{2cm}{\textbf \it {\hspace*{-1.5cm}NORDUGRID\vspace*{0.5cm}}}
\end{tabular}

\hrulefill

%-------- Change this to NORDUGRID-XXXXXXX-NN

% {\raggedleft NORDUGRID-MANUAL-10\par}

{\raggedleft \today\par}

\vspace*{2cm}

%%%%---- The title ----
{\centering \textsc{\Large WS-ARC service configuration manual}\Large \par}
\vspace*{0.5cm}

%%%%---- A subtitle, if necessary ----
%{\centering \textit{\large First prototype status and plans}\large \par}

\vspace*{1.5cm}
%%%%---- A list of authors ----
    {\centering \large Martin Skou Andersen\footnote{skou@nbi.dk} \large \par}
\end{titlepage}

\tableofcontents                          %Comment if use article style

\newpage

\renewcommand{\thefootnote}{\arabic{footnote}}


%\chapter{Quick start guide} % (fold)

\section{Introduction} % (fold)

The Web Service (WS) Advanced Resource Connector (ARC) provides a great deal of
services which all share a common configuration interface. One or more services
can be specified in a configuration and the \texttt{arched} daemon should then
be used for starting the service(s). The configuration should be
specified in a file using either the relatively simple INI format, or the more
complex XML format.

INI configuration is the recommended way of configuring services for people who
are new to ARC or unfamiliar with WS-ARC configuration. However it is limited in
the sense that it relies on profiles. A profile is a configuration
template setup for one or more services, and common use case profiles exist for
most services and are installed per default. The limitation lies in the fact
that only services and options which are specified in the profile can be
configured in INI configuration, however the installed profiles should give
enough flexibility for common use cases. For a detailed description on INI
configuration see section~\ref{sec:INI configuration}. Profiles are further
discussed in section~\ref{sec:Profiles}.

XML configuration is the core format of WS-ARC configuration -- it
is used internally -- and thus it gives full flexibility when configuring
services. A detailed description of XML configuration can be found in
section~\ref{sec:XML configuration}.

The \texttt{arched} daemon, which is used to start WS-ARC services according to
the configuration is briefly discussed in section~\ref{sec:arched}.

\subsection{How to read this manual}
This manual is divided into the three independent sections INI configuration,
XML configuration and Profiles, and these can be read independent of each other.
Additionally the \texttt{arched} section describe the command with the same
name.

It should be noted that words typeset with the \texttt{typewriter} font should
be typed as written.


\section{INI configuration}\label{sec:INI configuration}
As mentioned in the introduction, INI configuration directly relies on profiles,
and a profile is a configuration template setup for one or more services. So
when creating a INI configuration file a choice of profile must be made. Only
one profile can be used in a given INI configuration. A standard WS-ARC
installation comes with a set of profiles and the list in
appendix~\ref{app:List of profiles} gives a short description of these. The
profiles will per default be installed into the \texttt{/usr/share/arc/profiles}
folder, where it is also possible to find an example INI configuration file for
each of the profiles.

A INI configuration file basically consist of sections, attribute-value pairs
and maybe comments and blank lines. In the following code-listing the syntax of
an INI configuration file is shown:
\begin{lstlisting}
# A comment
[ common ]
profile = <path-to-profile>

<attribute> = <value>
...
...

# Another comment
[ <section-name> ]
<attribute> = <value>
...
...
[ <another-section> ]
<attribute> = <value>
...
...
\end{lstlisting}

A section is specified by putting the name of the section inside brackets
(\texttt{[} and \texttt{]}), where the left bracket (\texttt{[}) must be the
first non white space character on the line. Any white space character after the
left bracket and before the right will not be part of the section name. Every
attribute-value pair belongs to the section which has be been defined
previously. If the file starts without declaring a section, then following
attributes will belong to the common section. Multiple sections with identical
names are different sections, except for the common section, which is special in
this respect and if multiple common sections exist these will be considered as
one.

The \texttt{profile} attribute is also a special, as it is used to indicate
which profile the INI configuration uses, and its value should be the
absolute path to the profile file. The \texttt{profile} attribute must be
located in the common section. If multiple \texttt{profile} attributes exist
only the first attribute will be used.

Attribute-value pairs are defined by specifying the name of the attribute
followed by an equal sign and then the value the attribute should take. It is
the first equal sign which separates the attribute from the value. If a line,
not defining a section, does not contain an equal then it will be ignored and if
it contains multiple equal signs then all but first equal sign will be part of
the value. Any white space before and after the attribute and value will be
ignored. Only attributes which have been defined in the selected profile will be
consideren by \texttt{arched}. For each profile in WS-ARC a corresponding INI
configuration file exist which defines sensible values and at the time list all
configurable attributes. When it comes to multiple attributes with identical
names defined in the same section, it is the selected profile which determines
if multiple attributes is allowed and will be interpreted or not. It is possible
that attributes from one section can override attributes from another section,
however this behaviour is completely determined by the profile.

Comments in the INI configuration file are specified by letting the first non
white space character be the sharp character (\texttt{\#}), and these will be
ignored by \texttt{arched}.

\subsection{Examples}
\subsubsection{Echo service}

\begin{lstlisting}
profile = /usr/share/arc/profiles/EchoService.xml

pidfile = /tmp/arched.pid
logfile = /tmp/arched.log
loglevel = INFO

port = 60000

cacert = /etc/grid-security/certificates
host_cert = /etc/grid-security/hostcert.pem
host_key = /etc/grid-security/hostkey.pem

[ echo ]
prefix = {{
suffix = }}
\end{lstlisting}

\subsubsection{Other service}

\subsection{Limitations}
Configuring WS-ARC services in INI format may pose some limitations, since this
configuration format depend on profiles. If one wants to configure a service
setup which is not covered by any of the available profiles, it is simply not
possible to configure that service setup in INI format and one has to use the
XML format described in section~\ref{sec:XML configuration}. It should however
be noted that it is easy to switch from INI to XML format since the
\texttt{arched} command provide a way to convert a INI configuration into XML.
See section~\ref{sec:arched} for further details.

\section{XML configuration}\label{sec:XML configuration}
\subsection{Overview}
XML configuration in WS-ARC provides full flexibility for configuring services,
and to construct an adequate configuration one need to address the following
subjects. If not done already, a choice on which service(s) being setup need to
be made and a short discussion of the available WS-ARC services is given in
section~\ref{sec:Service configuration}. Upon the choice of service(s) the
proper message chain need to be configured and a discussion about message chains
is given in section~\ref{sec:Message Chain}. Most people also want some kind of
security setup capable of allowing/denying certain users, which can be done with
security handlers and is discussed in section~\ref{sec:Security Handlers}.
Common configuration options like specifying plugins required for instance by
the message chain, and configuring logging, is discussed in
section~\ref{sec:General Daemon Configuration}. In
section~\ref{sec:XML examples} example XML configuration files are given.

\subsection{Service configuration}\label{sec:Service configuration}
The following services are part of WS-ARC and specific configuration details for
these are given in the respective references below:
\begin{description}
\item[A-REX]
  A-REX
\item[Chelonia]
\item[ISIS]
\item[Charon]
\item[hopi]
  hopi, a lightweight HTTP webserver, is described in details in \%\% REFERENCE.

\end{description}

\subsection{Message Chain}\label{sec:Message Chain}
To configure WS-ARC services, a basic knowledge about how these are
communicating with clients or other services is needed. WS-ARC uses a chain of
message components (MCCs) which serves different levels of functionality. In one
end it accepts messages from an interface and in the other a service processes
them and produce a response. Two types of MCCs exist, and they differ in that
the first type should be able to listen on some interface for messages, while
the other simply
receives messages from another MCC. The MCC then process the message and pass it
on to a single or multiple other MCCs or services. MCCs should be configured
using the XML element \texttt{Component}, where the \texttt{name} attribute
specifies the MCC to use. The following MCCs is part of WS-ARC:
\begin{description}
\item[\texttt{tcp.service}] Listens on the TCP interface, see
  section~\ref{sec:tcp-mcc},
\item[\texttt{tls.service}] Adds encryption layer to communication, see
  section~\ref{sec:tls-mcc},
\item[\texttt{http.service}] Processes HTTP messages, see
  section~\ref{sec:http-mcc},
%~ \item[\texttt{gsi.service}] Processes GSI messages, see
  %~ section~\ref{sec:gsi-mcc},
\item[\texttt{soap.service}] Processes SOAP messages, see
  section~\ref{sec:soap-mcc}.
\end{description}
Additionally a special MCC,
the Plexer, exist which is able to pass messages to different components simply
based on the endpoint the messages was sent to, and it should should be
configured using the \texttt{Plexer} element, see section~\ref{sec:plexer}. In
the end of the chain a service should be specified, using the  \texttt{Service}
element, where the \texttt{name} attribute indicates the given service.

A working configuration should then link a set of MCCs and services, starting
with a MCC that receives messages from some interface. The MCCs and services
should be uniquely identifiable, by setting the \texttt{id} attributes of these
elements. A MCC links to another or several MCCs or services using the
\texttt{next} element, where the \texttt{id} attribute specifies the \texttt{id}
of that MCC or service. The message chain should be contained in the root
element \texttt{ArcConfig}, which is shown in the conceptual configuration
example below:
\begin{lstlisting}[language=xml]
...
<Component name="mcc1.service" id="mcc1">
  <next id="mcc2"/>
</Component>
<Component name="mcc2.service" id="mcc2">
  <next id="service"/>
</Component>
<Service name="service" id="service"/>
...
\end{lstlisting}
For readability the message chain can be grouped into a \texttt{Chain} element
in one or more levels.

\subsubsection{TCP MCC}\label{sec:tcp-mcc}
The TCP message component is named \texttt{tcp.service} and should be the first
component in a chain. It is used to setup a server socket which will listen for
incoming connections. The socket can be configured using the \texttt{Listen}
element, which can occur multiple times and under each element the following
child elements can be specified:
\begin{description}
\item[\texttt{Interface}] This element specifies the interface which socket
  should listen on. If this element is not specified then the socket will listen
  on all available interfaces.
\item[\texttt{Port}] The port which the socket should bind to should be
  specified with this element. If no port is specified an error will be reported
  and this \texttt{Listen} element will be ignored.
\item[\texttt{Version}] The IP version can be specified by this element, and by
  default both version 4 and 6 will be used. It is possible to specify version 4
  or 6 only.
\item[\texttt{NoDelay}] By default Nagle's algorithm is used for sending data,
  however if the \texttt{NoDelay} element is set to \texttt{true} data will be
  sent when ready. This is mainly used for optimizing connections for communication
  patterns which involve a lot of very short messages exchanged by service 
  and client.
\item[\texttt{Timeout}] Specifies how much time, in seconds, data sending or
  receiving may take. If time is exceeded MCC reports error and in most cases 
  connection is dropped. The default value is 60 seconds.
\end{description}
It is also possible to put a limit on number of incoming connections, and how 
these should be handled if the limit is reached. The limit can only be put on all 
configured interfaces, and not per interface. The \texttt{Limit} element specifies 
the limit on incoming connections, and the \texttt{drop} attribute specifies whether 
new connections, above the limit, will be put on hold (default) or if they should 
be dropped, which is specified by setting the attribute to \texttt{true}.

An example of a TCP MCC configuration using the described elements is shown
below:
\begin{lstlisting}[language=xml]
...
<Component name="tcp.service" id="tcp">
  <Listen>
    <Interface>w.x.y.z</Interface>
    <Port>44444</Port>
    <Version>4</Version>
    <NoDelay>true</NoDelay>
    <Timeout>120</Timeout>
  </Listen>
  <Listen>
    <Interface>a:b:c:d:e:f:g:h</Interface>
    <Port>55555</Port>
    <Version>6</Version>
    <NoDelay>false</NoDelay>
    <Timeout>20</Timeout>
  </Listen>
  <Limit drop="true">30</Limit>
</Component>
...
\end{lstlisting}

\subsubsection{TLS MCC}\label{sec:tls-mcc}
A security layer can be configured with the TLS MCC, named \texttt{tls.service},
and it should be put on top of a TCP MCC. By default it is able to understand
the SSLv2 (hadshake only), SSLv3 and TLSv1 protocols, however the \texttt{Handshake} 
element can be used to specify another behaviour. The supported values for the
\texttt{Handshake} element are \texttt{TLS} (default) and \texttt{SSLv3}, where
specifying the latter will configure a MCC which only understand the SSLv3
protocol. If other values than the mentioned ones are given, then \texttt{TLS}
will be used.

For the TLS MCC to function, it should have access to a host key-certificate
pair. The key should be the private one, and it should not be password
protected. The path to the key-certificate pair can be specified by using the
\texttt{KeyPath} and \texttt{CertificatePath} elements. If the \texttt{KeyPath}
element is not specified the default path
\texttt{/etc/grid-security/hostkey.pem} will be used, and likewise if the
\texttt{CertificatePath} element is not specified the default path
\texttt{/etc/grid-security/hostcert.pem} will be used. The supported key and
certificate formats are PEM and DER.

When establishing a connection with a client, the client certificate are per
default verified against the Certificate Authority (CA) certificates, known to
the TLS MCC. The CA certificates used for verification can be specified with
either the \texttt{CACertificatesDir} or the \texttt{CACertificatePath} element,
or both elements can be used. The \texttt{CACertificatesDir} element should
point to a directory containing one or more CA certificates (in PEM format). The
files should each contain exactly one certificate, and should be named by the
hash value of the CA subject name. CA certificates provided by NorduGrid uses
this option. The \texttt{CACertificatePath} element should point to a file
containing one or more CA certificates (in PEM format) identified by:
\begin{lstlisting}
  -----BEGIN CERTIFICATE-----
  ... (CA certificate in base64 encoding) ...
  -----END CERTIFICATE-----
\end{lstlisting}
sequences. If both elements have been specified, CA certificates will first be
looked up in the file pointed to by the \texttt{CACertificatePath} element and
then in the directory pointed to by the \texttt{CACertificatesDir} element. If
none of the two elements have been specified, then the
\texttt{CACertificatesDir} element will be initialised to the
\texttt{/etc/grid-security/certificates} location. Client certificate
verification can also be skipped, which is done by setting the
\texttt{ClientAuthn} element to \texttt{false}.

\begin{lstlisting}[language=xml]
...
<Component name="tls.service" id="tls">
  <KeyPath></KeyPath>
  <CertificatePath></CertificatePath>
  <CACertificatePath></CACertificatePath>
  <CACertificatesDir></CACertificatesDir>
  <ClientAuthn></ClientAuthn>
  <Handshake>SSLv3</Handshake>
</Component>
...
\end{lstlisting}

If element \texttt{CACertificatesDir} have attribute \texttt{PolicyGlobus} set
to "true" additional verification of client credentials is performed. Client
credentials are restricted to be signed by specific Certification Authorities
as specified in additional configuration files. Those files are stored in the
location specified by the element \texttt{CACertificatesDir} and have names
made of the hash of the subject of CA certificate followed by \texttt{.signing\_policy}
suffix. Information about format of those files may be found at 
http://dev.globus.org/wiki/Signing\_Policy.
%~
%~ \paragraph{Trusted VOMS Credentials}
%~ \texttt{VOMSCertTrustDNChain}
%~ <xsd:sequence>
  %~ \texttt{VOMSCertTrustDN}
  %~ \texttt{VOMSCertTrustRegex}
%~ </xsd:sequence>
%~ The DN list of the trusted voms server credential;
%~ in the AC part of voms proxy certificate, voms proxy
%~ certificate comes with the server certificate which is
%~ used to sign the AC. So when verifying the AC on the
%~ AC-consuming side (in ARC1, it is the MCCTLS which will
%~ consumes the AC), the server certificate will be checked
%~ against a trusted DN list. Only if the DN and issuer's
%~ DN of server certificate exactly matches the DN list
%~ in the configuration under TLS component, the AC can be trusted
%~
%~ \texttt{VOMSCertTrustDNChainsLocation}
%~ DN list in an external file, which is in the same format as VOMSCertTrustDNChain
%~
%~ \begin{lstlisting}[language=xml]
%~ ...
%~ <Component name="tls.service" id="tls">
  %~ <VOMSCertTrustDNChain>
    %~ <VOMSCertTrustDN></VOMSCertTrustDN>
    %~ <VOMSCertTrustDN></VOMSCertTrustDN>
    %~ <VOMSCertTrustDN></VOMSCertTrustDN>
    %~ <VOMSCertTrustRegex></VOMSCertTrustRegex>
  %~ </VOMSCertTrustDNChain>
%~ </Component>
%~ ...
%~ \end{lstlisting}

\subsubsection{GSI MCC}\label{sec:gsi-mcc}
At its purpose MCC is similar to TLS described in section \ref{sec:tls-mcc}. It 
provides security layer using Globus implementation of GSS-API and corresponding 
communication protocol.

Its configuration element \texttt{KeyPath} and \texttt{CertificatePath} are 
identical to those of TLS MCC. This MCC is implemented using libraries of 
Globus Toolkit and its functionality and requirements are better to be 
described by descrition of Globus gssapi library.

Use of this MCC is not recommended due to non-standard origin of underlying
protocol.

\subsubsection{HTTP MCC}\label{sec:http-mcc}
The HTTP protocol is supported by the HTTP MCC named \texttt{http.service}, and
it should either be put on top of the TCP or TLS MCC. A working configuration of
this MCC is simple, since it should only use the \texttt{next} element which
must have a value equal to one of the HTTP request methods. An example of a HTTP
MCC configuration is shown below.

\begin{lstlisting}[language=xml]
...
<Component name="http.service">
  <next id="component1">GET</next>
  <next id="component2">POST</next>
  <next id="component3">PUT</next>
</Component>
...
\end{lstlisting}

\subsubsection{SOAP MCC}\label{sec:soap-mcc}
SOAP is supported by the SOAP MCC, named \texttt{soap.service}. It parses and
processes incoming messages as SOAP messages. This component should be put right
after the HTTP MCC in the message chain. The component is needed by most of the
services in WS-ARC. The only option which should be configured for the SOAP MCC
is to which component or service the valid SOAP messages should be directed to,
and it is done with the \texttt{next} element as for the other components.

\subsubsection{Plexer}\label{sec:plexer}
The Plexer is a special MCC which filters messages based on their URL endpoints.
One or more regular expressions (POSIX extended) should be defined using one or
more \texttt{next} elements, and these will then be used to filter incoming
messages, thus forwarding messages, where the path of the endpoint URL matched a
given regular expression, to the component or service specified by the
\texttt{id} attribute of the corresponding \texttt{next} element. At the first
match the message will be forwarded to the respective component or service and
no more expressions will be tried. If a message did not match any of the regular
expressions then it is discarded and an error code is returned to the client. An
example of a Plexer configuration is shown below.
%% What is the order testing the regular expressions. First listed first tested or Last listed firsted tested?

\begin{lstlisting}[language=xml]
...
<Plexer>
  <next>^/arex$</next>
  <next>^/[eE][cC][hH][oO]$</next>
</Plexer>
...
\end{lstlisting}

\subsection{Security Handlers}\label{sec:Security Handlers}
Security Handlers are components which extract security related properties of
the message, collect then and use for making authorization decisions.

The Security Handlers are assigned MCCs and are arranged in queues. Each queue
is processing specific messages. Usually MCCs implement two queues named 
"incoming" and "outgoing" for the messages going through chain to service
and returning back respectively.

The Security Handlers in each queue are applied sequentially and if any
produces negative result processing stops are error is raised.

The Security Handlers are added to MCCs through \texttt{SecHandler} configuration
element put inside \texttt{Component} or \texttt{Service} elements. The
\texttt{name} attribute specifies which plugin to be used. And queue is 
specified by \texttt{event} attribute. Each configured instance can be 
optionally assigned identifier through \texttt{id} attribute. Tne content
of \texttt{SecHandler} is specific for every kind of plugin.
Example is below:
\begin{lstlisting}[language=xml]
...
<Component name="mcc1.service" id="mcc1">
  <next id="mcc2"/>
  <SecHandler name="handler1" event="incoming" id="id1">
  </SecHandler>
</Component>
...
\end{lstlisting}


\subsubsection{ARC Authorization}\label{sec:arcauthz-shc}
This Security Handler applies set of Policy Decision Point (PDP) element to the
message and then produces decision result using combining algorithm specified in 
\texttt{action} attribute of \texttt{SecHandler} element. For desciption of PDP
elements see section \ref{sec:Policy Decision Points}. The plugin name of this 
Secirity hadler is \texttt{arc.authz} and it resides in \texttt{arcshc} loadable module.

Available combining algorithms are:
\begin{description}
\item[breakOnDeny] - processing stops when PDP returns Deny decision. The SecHandler
produces negative result. This is a default algorith.
\item[breakOnAllow] - processing stopr when PDP return Allow decision. The SecHandler
produces positive result.
\item[breakAlways] - processing stops after first PDP. Produced result is used as
result of SecHandler.
\item[breakNever] - all PDPs are applied. Result of last PDP is used as result of 
SecHandler.
\end{description}
Here is an example of of ARC Authorization Security Handler configuration.
\begin{lstlisting}[language=xml]
...
  <SecHandler name="arc.authz" event="incoming" id="authz">
    <PDP name="arc.pdp">
      ...
    </PDP>
    <PDP name="xacml.pdp">
      ...
    </PDP>
  </SecHandler>
...
\end{lstlisting}


\subsubsection{Identity Mapping}\label{sec:identitymap-shc}
The Identity Mapping plugin applies set of associated PDPs to the message
being processed and depending on result assigns local account to the 
message. Its plugin name is \texttt{identity.map} and it resides in 
\texttt{identitymap} loading module.

This Security Handler works in a similar way to ARC Authorization (see
section \ref{sec:arcauthz-shc}). But instead of passing results of PDPs as
final processing result it applies local account mapping algorithm 
associated with particular PDP.

Configuration is also similar with only difference being that inside 
each \texttt{PDP} configuration element there is additional element
representing mapping algorithm used for producing local account name.
Available are following mapping algorithms:
\begin{description}
\item[\texttt{LocalName}] - maps to specified account name.
\begin{lstlisting}[language=xml]
...
    <PDP name="arc.pdp">
      <LocalName>nobody</LocalName>
      ...
    </PDP>
...
\end{lstlisting}

\item[\texttt{LocalList}] - uses subject of X.509 certificate presented by client
to perform mapping. Element content provides path to local file containing pairs
of subjects and account names. One pair per line separated by blank space.
\begin{lstlisting}[language=xml]
...
    <PDP name="arc.pdp">
      <LocalList>/etc/grid-security/grid-mapfile</LocalList>
      ...
    </PDP>
...
\end{lstlisting}

\item[\texttt{LocalSimplePool}] - manages dynamic mapping of X.509 client subject
to a set of local accont names. Content of element point to directory containing
file named \texttt{pool}. This file contains list of local account available for
mapping one per line. This directory is also used fro storing currently active
mappings.
\begin{lstlisting}[language=xml]
...
    <PDP name="arc.pdp">
      <LocalSimplePool>/etc/grid-security/mappool</LocalSimplePool>
      ...
    </PDP>
...
\end{lstlisting}
\end{description}

\subsubsection{Delegation Collector}\label{sec:delegcollector-shc}
This plugin processes chain of X.509 certificates and extracts embedded
policies. Policies are attached to the message and may be later used by
Delegation PDP described in section \ref{sec:delegation-pdp}. The
plugin name of this Security Handler is \texttt{delegation.collector} 
and it resides in \texttt{mcctls} loadable module.
It has no configuration parameters.

% \subsubsection{Delegation Handler}\label{sec:deleghandler-shc}

\subsubsection{UsernameToken}\label{sec:unametoken-shc}
The UsernameToken Security Handler processes information in the SOAP Header
stored according to "Web Services Security UsernameToken Profile 1.0"
\cite{ws-security-usernametoken}. The plugin name of this Security Handler
is \texttt{usernametoken.handler} and it resides in \texttt{arcshc} loadable
module.

The configuration element \texttt{Process} defines type of processing to 
be performed. Possible values are:
\begin{description}
\item[extract] - parse and process elements in SOAP Header. This option
shoudl be used for service side configuration.
\item[generate] - create UsernameToken. This option is only used for client
side.
\end{description}

Only another configuration element relevant for service side processing is
\texttt{PasswordSource}. It specifies path to local file containing
list of usernames and passwords (one pair per line) which are accepted 
by plugin. If there is no pair in file matching one SOAP Header this 
Security Handler will raise an error.

\subsubsection{X.509 Token}\label{sec:x509token-shc}
The X.509 Token Security Handler processes information in the SOAP Header
stored according to "Web Services Security X.509 Token Profile 1.0"
\cite{ws-security-usernametoken}. The plugin name of this Security Handler
is \texttt{x509token.handler} and it resides in \texttt{arcshc} loadable
module.

The configuration element \texttt{Process} defines type of processing to 
be performed. Possible values are:
\begin{description}
\item[extract] - parse and process elements in SOAP Header. This option
shoudl be used for service side configuration.
\item[generate] - create X.509 Token. This option is only used for client
side.
\end{description}

In \texttt{extract} mode this plugin process X.509 Token from SOAP Header
and validates contained credetials against locally stored CA certificates.
Following configuration elements specify location of trusted CA certificates:
\begin{description}
\item[CACertificatePath] - path to file containing CA certificate.
\item[CACertificatesDir] - path to directory containing files with CA certificates.
\end{description}
If provided credentials failed verification this Security Handler will raise 
an error.

%\subsubsection{SAML Token}% samltoken.handler
%\subsubsection{SAML Single Sign-On}% saml2ssoassertionconsumer.handler

\subsection{Policy Decision Points}\label{sec:Policy Decision Points}

\subsection{General Daemon Configuration}\label{sec:General Daemon Configuration}
The following options configures the \texttt{arched} daemon, and thus applies to
all services. Some of the options can also be set using command line arguments,
and if used these will override the configuration file options. See
section~\ref{sec:arched} for a description of the \texttt{arched} daemon.

Under the \texttt{Server} element the file to store the PID in, can be specified
using the \texttt{PidFile} element, if not specified the PID will be stored in
the file \texttt{/var/run/arched.pid}. This options can also be set using a
command line argument. If the \texttt{Foreground} element is
present under the \texttt{Server} element, \texttt{arched} will run in
foreground and thus the \texttt{PidFile} element will be ignored. It is also
posible to specify that \texttt{arched} should run in foreground on the command
line, however it is not posible to specify that it should run as a daemon, if
configured to run in foreground in the configuration file. Also under the
\texttt{Server} the user and group owning the \texttt{arched} process can be
specified, which is accomplished with the \texttt{User} and \texttt{Group}
elements. These can also be set on the command line.

Logging options should be specified under the \texttt{Logger} element under the
\texttt{Server} element. The \texttt{File} element specifies which file to write
log messages to and if not present log messages will be written to the
\texttt{/var/log/arched.log} file. Each log message is associated with a log
level which indicates the serverity of the message. The following log levels
exist in WS-ARC, ordered by serverity: \texttt{FATAL}, \texttt{ERROR},
\texttt{WARNING}, \texttt{INFO}, \texttt{VERBOSE} and \texttt{DEBUG}. With
the \texttt{Level} element the level of messages being reported can be
specified. Log messages with a higher or same level as specified by the
\texttt{Level} element will be written to the log file. The default log level is
\texttt{WARNING}. \newline
By default the log file is not limited in size, neither
will any log rotation be done. The \texttt{Maxsize} and \texttt{Backups}
elements can be used to change this behaviour. The \texttt{Maxsize} element sets
the maximum file size of the log file in bytes, while the \texttt{Backups}
element specifies the number of files used for log rotation. When the size of
the log file exceeds the limit specified by the \texttt{Maxsize} element the log
file is renamed to \texttt{<log-file>.1}. If this file exist it is renamed to
\texttt{<log-file>.2} and so forth up to the number specified by
\texttt{Backups}, which means that the last file will be deleted. The log file
size is only allowed to exceed the specified limit by the size of one log
message. If the \texttt{Maxsize} element have been specified and no
\texttt{Backups} element is specified then log rotation will not be carried out,
thus the log file is truncated when the limit is exceeded.

Plugins which should be used later in the configuration should be specified
under the \texttt{Plugins} element where the \texttt{Name} element specifies the
name of the plugin. The \texttt{Path} element under the \texttt{ModuleManager}
element specifies where to locate the plugins.

The following example show the use of the above configuration options:
\begin{lstlisting}[language=xml]
<?xml version="1.0"?>
<ArcConfig>
  <Server>
    <PidFile>/tmp/arched.pid</PidFile>
    <User></User>
    <Group></Group>
    <Logger>
      <File>/tmp/arched.log</File>
      <Level>WARNING</Level>
      <MaxSize>1000000</MaxSize>
      <Backups>5</Backups>
    </Logger>
  </Server>
  <ModuleManager>
    <Path>/usr/lib/arc</Path>
  </ModuleManager>
  <Plugins>
    <Name>plugin1</Name>
    <Name>plugin2</Name>
    ...
  </Plugins>
  ...
</ArcConfig>
\end{lstlisting}

\subsection{Examples}\label{sec:XML examples}
\subsubsection{Echo Service}
\begin{lstlisting}[language=xml]
<?xml version="1.0"?>
<cfg:ArcConfig xmlns="http://www.nordugrid.org/schemas/loader/2009/08"
               xmlns:cfg="http://www.nordugrid.org/schemas/arcconfig/2009/08"
               xmlns:tcp="http://www.nordugrid.org/schemas/tcp/2009/08"
               xmlns:tls="http://www.nordugrid.org/schemas/tls/2009/08"
               xmlns:echo="http://www.nordugrid.org/schemas/echo/2009/08"
               xmlns:infosys="http://www.nordugrid.org/schemas/infosys/2009/08">
  <cfg:Server>
    <cfg:PidFile>/tmp/arched.pid</cfg:PidFile>
    <cfg:Logger>
      <cfg:File>/var/log/arched.log</cfg:File>
      <cfg:Level>WARNING</cfg:Level>
    </cfg:Logger>
  </cfg:Server>
  <ModuleManager>
    <Path>/usr/lib/arc</Path>
  </ModuleManager>
  <Plugins>
    <Name>mcctls</Name>
    <Name>mcchttp</Name>
    <Name>mccsoap</Name>
    <Name>mcctcp</Name>
  </Plugins>
  <Chain>
    <Component name="tcp.service" id="tcp">
      <next id="http"/>
      <tcp:Listen>
        <tcp:Interface>0.0.0.0</tcp:Interface>
        <tcp:Version>4</tcp:Version>
      </tcp:Listen>
    </Component>
    <Component name="http.service" id="http">
      <next id="soap">POST</next>
      <next id="plexer">GET</next>
    </Component>
    <Component name="soap.service" id="soap">
      <next id="plexer"/>
    </Component>
    <Plexer id="plexer">
      <next id="echo">/Echo</next>
    </Plexer>
    <Service name="echo" id="echo">
      <echo:prefix>[</echo:prefix>
      <echo:suffix>]</echo:suffix>
    </Service>
  </Chain>
</cfg:ArcConfig>
\end{lstlisting}

\section{Profiles}\label{sec:Profiles}
In WS-ARC the concept of profiles have been introduced. A profile is a complete
XML configuration template, for a specific service setup and it is used when
configuring services in INI format. The core of WS-ARC
uses an XML struture for service initialization, which makes the XML format
the apparent choice for configuration. However the XML language is not simple
and easy to use, which is why WS-ARC utilizes profiles, namely to provide a
configuration format (the INI format) easy to use.

To write a profile, some knowledge on the INI (see
section~\ref{sec:INI configuration}) and XML configuration formats (see
section~\ref{sec:XML configuration}) is needed. Not necessaray to say, knowledge
on the desired service setup is also needed. A XML configuration file is only a
profile if it defines a option mapping from INI format to XML, thus making it
possible to utilise the XML configuration through the INI format.

Two XML attributes have been introduced to be able to create a mapping, and
these are \texttt{inisections} and \texttt{initag}. XML elements which should be
configurable in INI format must specify these attributes. The \texttt{initag}
attribute defines the name of the tag which represent the respective XML element
in the INI configuration file, and the \texttt{inisections} attribute is used to
specify, as a space separated list, which sections the tag can occur in. The
list is ordered, in the sense that the listed sections is searched, in the
specified order, for the tag specified by the \texttt{initag} attribute, and if
found in a section no further sections will be searched. Only leaf XML elements
(elements with no child elements) should be mapped, mapping non leaf element
result in a undefined behaviour. A profile example of a XML element mapping is
shown in the listing below:
\begin{lstlisting}[language=xml,title=ElementMapping.xml]
...
<Server>
  ...
  <Logger>
    <File inisections="special common"
          initag="logfile">/var/log/arched.log</File>
    ...
  </Logger>
</Server>
...
\end{lstlisting}
And this example profile can then be utilised in a INI configuration file as:
\begin{lstlisting}[language=xml,title=ElementMapping.ini]
profile=ElementMapping.xml
logfile=/etc/arc/arched.log
...
[ special ]
logfile=/var/arc/arched.log
...
\end{lstlisting}
And the resulting XML configuration will look like:
\begin{lstlisting}[language=xml]
...
<Server>
  ...
  <Logger>
    <File>/var/arc/arched.log</File>
    ...
  </Logger>
</Server>
...
\end{lstlisting}

To be able to map XML attributes the use of a new XML element
\texttt{AttributeRepresentation} have been introduced. The element should have
three attributes set, the two attributes \texttt{inisections} and
\texttt{initag} used as described above, and a new attribute \texttt{id} which
specifies which attribute of the parent element is being mapped. A profile
example of a XML attribute is shown in the listing below:
\begin{lstlisting}[language=xml,title=AttributeMapping.xml]
...
<Component name="tcp.service">
  ...
  <Limit drop="false">
    <AttributeRepresentation id="drop" inisections="common" initag="drop"/>
    100
  </Limit>
</Component>
...
\end{lstlisting}
And this example profile can then be utilised in a INI configuration file as:
\begin{lstlisting}[language=xml,title=AttributeMapping.ini]
profile=AttributeMappingExample.xml
drop=true
...
\end{lstlisting}
And the resulting XML configuration will look like:
\begin{lstlisting}[language=xml]
...
<Component name="tcp.service">
  ...
  <Limit drop="true">100</Limit>
</Component>
...
\end{lstlisting}

\section{The \texttt{arched} daemon}\label{sec:arched}
The \texttt{arched} daemon is the daemon which is used to start every service in
WS-ARC. It will load a configuration file, and start the services specified
herein.

\hspace*{0.5cm}
\begin{shaded}
\textbf{\sffamily arched [OPTION...]}
\end{shaded}
\vspace{-0.3cm}(ARC 0.9)\par
\begin{longtable}{llp{8cm}}
  \texttt{-f, --foreground} && run daemon in foreground\\
  \texttt{-c, --xml-config} & \textit{path} & full path of XML configuration file\\
  \texttt{-i, --ini-config} & \textit{path} & fill path of INI configuration file\\
  \texttt{-d, --config-dump} && dump generated XML configuration\\
  \texttt{-p, --pid-file} & \textit{path} & full path of PID file\\
  \texttt{-u, --user} & \textit{user} & user name\\
  \texttt{-g, --group} & \textit{group} & group name\\
  \texttt{-s, --schema} & \textit{path} & full path of XML schema file\\
  \texttt{-h, --help} && Show help options
\end{longtable}

If no configuration file is specified, \texttt{arched} first looks for the
\texttt{/etc/arc/server.ini} INI configuration file if it does not exist then
the \texttt{/etc/arc/server.xml} XML configuration file is tried. If none of
these is found \texttt{arched} will abort with an error and exit code 1.

A INI configuration file can be specified with the \texttt{-i} option,  while
the \texttt{-c} option makes it possible to specify a XML configuration file. If
both options are given, the INI configuration will be chosen.

\texttt{arched} also has the capability of printing the XML configuration which
will be generated from a given INI configuration. By specifying the \texttt{-d}
option along with the \texttt{-i} option and the path to the INI configuration
\texttt{arched} will transform the INI configuration to XML and dump the output
to standard out and exit.

\appendix
\section{List of standard profiles in WS-ARC}\label{app:List of profiles}


\subsection{A-REX}
\begin{description}
%~ \item[ComputingElementWithFork]
\item[ComputingElementWithFork] MINIMAL configuration template for a secure
standalone Computing Element (CE) with a fork queue.
%~ \item[NonSecureComputingElement]
\item[InsecureComputingElement]
%~ \item[SecureComputingElementWithMapfile]
\item[ComputingElementWithMapfile]
%~ \item[SecureComputingElementWithMapfileAndPBSBackend]
\item[ComputingElementWithMapfileAndPBSBackend]
%~ \item[SecureComputingElement\_DNlist]
\item[ComputingElement\_DNlist]
%~ \item[SecureComputingElement\_VOMS]
\item[ComputingElement\_VOMS]
\end{description}

\subsection{Chelonia}
\begin{description}
%~ \item[CheloniaAllServicesCentralizedAHash]
\item[CheloniaAllCentralizedAHash]
%~ \item[CheloniaCentralizedAHashWithISIS]
\item[CheloniaAllCentralizedAHashWithISIS]
%~ \item[CheloniaAllServicesReplicatedAHash]
\item[CheloniaAllReplicatedAHash]
%~ \item[CheloniaAllServicesReplicatedAHashGatewayVOMSWithISIS]
\item[CheloniaAllReplicatedAHashGatewayVOMSWithISIS]
%~ \item[CheloniaAllServicesReplicatedAHashWithISIS]
\item[CheloniaAllReplicatedAHashWithISIS]
%~ \item[CheloniaReplicatedAHash]
\item[CheloniaReplicatedAHash]
%~ \item[CheloniaShepherdWithHopi]
\item[CheloniaShepherdWithHopi]
%~ \item[NonSecureNonDistributedStorageElement]
\item[InsecureNonDistributedStorageElement]
%~ \item[SecureNonDistributedStorageElement\_DNlist]
\item[NonDistributedStorageElement\_DNlist]
%~ \item[SecureNonDistributedStorageElement\_VOMS]
\item[NonDistributedStorageElement\_VOMS]
\end{description}

\subsection{ISIS}
\begin{description}
%~ \item[NonSecureP2PIIS]
\item[InsecureP2PIIS]
%~ \item[NonSecureStandaloneIIS]
\item[InsecureStandaloneIIS]
%~ \item[SecureP2PIIS]
\item[P2PIIS]
%~ \item[SecureStandaloneIIS]
\item[StandaloneIIS]
\end{description}

\subsection{Charon}
\begin{description}
%~ \item[CharonService]
\item[Charon]
\end{description}

\subsection{Hopi}
\begin{description}
%~ \item[HopiService]
\item[Hopi]
%~ \item[HopiServiceNonSecure]
\item[HopiInsecure]
%~ \item[HopiServiceWithPlexer]
\item[HopiWithPlexer]
%~ \item[HopiServiceWithPlexerNonSecure]
\item[HopiWithPlexerInsecure]
\end{description}

\subsection{Combined services}
\begin{description}
%~ \item[NonSecureComputingAndStorageElement]
\item[InsecureComputingAndStorageElement]
%~ \item[SecureComputingAndStorageElement\_DNlist]
\item[ComputingAndStorageElement\_DNlist]
%~ \item[SecureComputingAndStorageElement\_VOMS]
\item[ComputingAndStorageElement\_VOMS]
\end{description}

\subsection{Testing}
\begin{description}
%~ \item[EchoService]
\item[Echo]
%~ \item[EchoInsecure]
\item[EchoInsecure]
%~ \item[EchoServicePython]
\item[EchoPython]
%~ \item[EchoServicePythonNonSecure]
\item[EchoPythonInsecure]
%~ \item[EchoServiceSAMLToken]
\item[EchoSAMLToken]
%~ \item[EchoServiceUsernameToken]
\item[EchoUsernameToken]
%~ \item[EchoServiceX509Token]
\item[EchoX509Token]
%~ \item[NonSecureHopiService]
\item[InsecureHopiService]
\end{description}

\section{Profile attributes naming convention}
Since profiles defines a mapping of XML elements or attributes to INI tags, they
control the naming of the tags. So for consistency tags in different profiles
reprensenting the same XML element or attribute should not be named differently.
A naming convention list for the XML elements and attributes described in
section~\ref{sec:XML configuration} is presented below. Note that there are only
conventions for leaf XML elements (element with no children).

\begin{tabular}{>{\ttfamily}l>{\ttfamily}l}
\toprule
\textrm{\textbf{XML element/attribute}} & \textrm{\textbf{INI tag}} \\
\midrule
/Server/PidFile & pidfile \\
/Server/User & user \\
/Server/Group & group \\
/Server/Logger/File & logfile \\
/Server/Logger/Level & loglevel \\
/Server/Logger/Maxsize & logmaxsize \\
/Server/Logger/Backups & logbackups \\
\midrule
\multicolumn{2}{c}{\textbf{TCP MCC}}\\
\midrule
/Component/Listen/Interface & interface \\
/Component/Listen/Port & port \\
/Component/Listen/Version & ipversion \\
/Component/Listen/NoDelay & nodelay \\
/Component/Listen/Timeout & timeout \\
/Component/Limit & limit \\
/Component/Limit.drop & drop \\
\midrule
\multicolumn{2}{c}{\textbf{TLS MCC}}\\
\midrule
/Component/KeyPath & x509\_user\_key \\
/Component/CertificatePath & x509\_user\_cert \\
/Component/CACertificatePath & x509\_cacert\_path \\
/Component/CACertificatesDir & x509\_cacert\_dir \\
/Component/CACertificatesDir.PolicyGlobus & policyglobus \\
/Component/ClientAuthn & clientauthn \\
/Component/VOMSCertTrustDNChain/VOMSCertTrustDN &  \\
/Component/VOMSCertTrustDNChain/VOMSCertTrustRegex &  \\
/Component/VOMSCertTrustDNChainsLocation & \\
/Component/Handshake & handshake \\
\bottomrule
\end{tabular}

\section{XML Schemas}
\subsection{General Daemon Schema}
\lstinputlisting[language=xml]{base.xsd}

\subsection{Loader Schema}
\lstinputlisting[language=xml]{loader.xsd}

\subsection{TCP Schema}
\lstinputlisting[language=xml]{tcp.xsd}

\subsection{TLS Schema}
\lstinputlisting[language=xml]{tls.xsd}

\bibliography{grid}
\end{document}
