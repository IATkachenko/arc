\subsection{chelonia}\label{sec:chelonia}

\index{chelonia}\index{commands:chelonia}\texttt{chelonia} is a client tool for
accessing the Chelonia storage system. With it it is possible to
create, remove and list file collections, upload, download and remove files,
and move and stat collections and files, using Logical Names (LN).
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia [options] $<$method$>$ [arguments]}
\end{shaded}
\versions{ARC 0.9}
\begin{longtable}{llp{8cm}}
   Options:&&\\
   \texttt{-b} & \textit{URL} & URL of Bartender to connect\\
   \texttt{-x} && print SOAP XML messages\\
   \texttt{-v} && verbose mode\\
   \texttt{-z}&\textit{filename}& configuration file (default {\$}HOME/.arc/client.conf)\\
   \texttt{-w} && allow to run without the ARC python client libraries (with limited functionality)\\
   Methods:&&\\
   \texttt{stat} &\textit{LN [LN ...]}& get detailed information about an entry or several\\
   \texttt{makeCollection, make, mkdir} &\textit{LN}& create a collection\\
   \texttt{unmakeCollection, unmake, rmdir} &\textit{LN}& remove an empty collection\\
   \texttt{list, ls} &\textit{LN}& list the content of a collection\\
   \texttt{move, mv} &\textit{source target}& move entries within the namespace (both LNs)\\
   \texttt{putFile, put} &\textit{source target}& upload a file from a \textit{source} to a \textit{target} (both specified as LNs))\\
   \texttt{getFile, get} &\textit{source [target]}& download a file from a \textit{source} to a \textit{target}\\
   \texttt{delFile, del, rm} &\textit{LN [LN ...]}& remove file(s))\\
   \texttt{modify, mod} &\textit{string}& modify metadata\\
   \texttt{policy, pol} &\textit{string}& modify access policy rules\\
   \texttt{unlink} &\textit{string}& remove a link to an entry from a collection without removing the entry itself\\
   \texttt{credentialsDelegation, cre} &\textit{string}& delegate credentials for using gateway\\
   \texttt{removeCredentials, rem} &\textit{string}& remove previously delegated credentials\\
   \texttt{makeMountPoint, makemount} &\textit{string}& create a mount point\\
\end{longtable}

Without arguments, each method prints its own help. Detailed explanation of each method is given below.

Examples:
\begin{verbatim}
    chelonia list /
    chelonia put orange /
    chelonia stat /orange
    chelonia get /orange /tmp
    chelonia mkdir /fruits
    chelonia mkdir /fruits/apple
    chelonia mv /orange /fruits
    chelonia ls /fruits
    chelonia rmdir /fruits/apple
    chelonia rmdir /fruits
    chelonia rm /fruits/orange
    chelonia policy / change ALL +read +addEntry
    chelonia modify /pennys-orange set states neededReplicas 2
\end{verbatim}

\subsubsection{stat} % (fold)
\label{ssub:stat}
With the \texttt{stat}\index{commands:chelonia:stat} method it is possible to get all the metadata about one or more entry (file, collection, etc.). The entries are specified with their Logical Name (LN).
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia stat $<$LN$>$ [$<$LN$>$ ...]}
\end{shaded}

The output contains key-value pairs grouped in sections. The `states' section contains the size and the checksum of a file, the number of needed replicas, and whether a collection is closed or not; the `entry' section contains the DN of the owner, the globally unique ID (GUID) of the entry, and the type of the entry (file, collection, etc.); the `parents' section contains the GUID of the parent collection(s) of this entry, and the name of this entry in that collection separated with a `/'; the `locations' sections contains the location of the replicas of a file, which contains of the ID (the URL) of the storage element, the ID of the replica within the storage element, and the state of the replica; the `timestamps' section contains the creation time of the entry; the `entries' section contains the name and GUID of the entries of a collection.
Example stat of a file:
\begin{verbatim}
$ chelonia stat /thing
'/thing': found
  states
    checksumType: md5
    neededReplicas: 3
    size: 6
    checksum: a0186a90393bd4a639a1ce35d8ef85f6
  entry
    owner: /C=HU/O=NIIF CA/OU=GRID/OU=NIIF/CN=Nagy Zsombor
    GUID: 398CBDEA-E282-4735-8DF6-2464CD00BE2D
    type: file
  parents
    0/thing: parent
  locations
    https://localhost:60000/Shepherd D519F687-EF65-4AEA-9766-E6E2D42166C4: alive
  timestamps
    created: 1257351119.3
\end{verbatim}
Example stat of a collection:
\begin{verbatim}
$ chelonia stat /
'/': found
  states
    closed: no
  entry
    owner: /C=HU/O=NIIF CA/OU=GRID/OU=NIIF/CN=Nagy Zsombor
    GUID: 0
    type: collection
  timestamps
    created: 1257351114.37
  entries
    thing: 398CBDEA-E282-4735-8DF6-2464CD00BE2D    
\end{verbatim}
% subsubsection stat (end)

\subsubsection{makeCollection} % (fold)
\label{ssub:makecollection}
With the \texttt{makeCollection}\index{commands:chelonia:makeCollection} or \texttt{mkdir} method it is possible to create a new empty collection. The requested Logical Name (LN) should be specified.
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia makeCollection $<$LN$>$}
\end{shaded}

The parent collection of the requested Logical Name must exist.

Example output of the method:
\begin{verbatim}
$ chelonia mkdir /newcoll
Creating collection '/newcoll': done

$ chelonia mkdir /nonexistent/newcoll
Creating collection '/nonexistent/newcoll': parent does not exist
\end{verbatim}
% subsubsection makecollection (end)

\subsubsection{unmakeCollection} % (fold)
\label{ssub:unmakecollection}
With the \texttt{unmakeCollection}\index{commands:chelonia:unmakeCollection} or \texttt{rmdir} method it is possible to delete an empty collection which is specified by its Logical Name (LN).
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia unmakeCollection $<$LN$>$}
\end{shaded}

Example output of the method:
\begin{verbatim}
$ chelonia rmdir /newcoll
Removing collection '/newcoll': removed

$ chelonia rmdir /dir
Removing collection '/dir': collection is not empty
\end{verbatim}
% subsubsection unmakecollection (end)

\subsubsection{list} % (fold)
\label{ssub:list}
With the \texttt{list}\index{commands:chelonia:list} or \texttt{ls} method it is possible to list the contents of one or more collections which are specified by their Logical Name (LN).
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia list $<$LN$>$ [$<$LN$>$ ...]}
\end{shaded}

Example output of the method:
\begin{verbatim}
$ chelonia list / /newcoll
'/newcoll': collection
    empty.
'/': collection
  thing   <file>
  dir     <collection>
  newcoll <collection>
\end{verbatim}
% subsubsection list (end)

\subsubsection{move} % (fold)
\label{ssub:move}
With the \texttt{move}\index{commands:chelonia:move} or \texttt{mv} method it is possible to move a file or collection within the namespace of chelonia (including renaming the entry). The source path and the target path should be specified as Logical Names
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia move $<$sourceLN$>$ $<$targetLN$>$}
\end{shaded}

Example output of the method:
\begin{verbatim}
$ chelonia mv /thing /newcoll/
Moving '/thing' to '/newcoll/': moved 

$ chelonia mv /newcoll/thing /newcoll/othername
Moving '/newcoll/thing' to '/newcoll/othername': moved   
\end{verbatim}
% subsubsection move (end)

\subsubsection{putFile} % (fold)
\label{ssub:putfile}
With the \texttt{putFile}\index{commands:chelonia:putFile} or \texttt{put} method it is possible to upload a new file into the system creating a new Logical Name (LN). It is possible the specify the number of needed replicas.
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia putFile $<$source filename$>$ $<$target LN$>$ [$<$number of replicas needed$>$]}
\end{shaded}

Example output of the method:
\begin{verbatim}
$ chelonia put thing /newcoll/
'thing' (6 bytes) uploaded as '/newcoll/thing'.    
\end{verbatim}
% subsubsection putfile (end)

\subsubsection{getFile} % (fold)
\label{ssub:getfile}
With the \texttt{getFile}\index{commands:chelonia:getFile} or \texttt{get} method it is possible to download a file specified with its Logical Name (LN). If the target local path is not given, then the file will be put into the local directory.
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia getFile $<$source LN$>$ [$<$target filename$>$]}
\end{shaded}

Example output of the method:
\begin{verbatim}
$ chelonia get /newcoll/thing newlocalname
'/newcoll/thing' (6 bytes) downloaded as 'newlocalname'.
\end{verbatim}
% subsubsection getfile (end)

\subsubsection{delFile} % (fold)
\label{ssub:delfile}
With the \texttt{delFile}\index{commands:chelonia:delFile} or \texttt{rm} method it is possible to delete one or more files from the system.
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia delFile $<$LN$>$ [$<$LN$>$ ...]}
\end{shaded}

Example output of the method:
\begin{verbatim}
$ chelonia rm /newcoll/othername
/newcoll/othername: deleted    
\end{verbatim}
% subsubsection delfile (end)

\subsubsection{modify} % (fold)
\label{ssub:modify}

With the \texttt{modify}\index{commands:chelonia:modify} or \texttt{mod} method it is possible to modify some metadata of an entry.
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia modify $<$LN$>$ $<$changeType$>$ $<$section$>$ $<$property$>$ $<$value$>$}
\end{shaded}

The possible values of `changeType' are `set' (sets the property to value within the given section), `unset' (removes the property from the given section - the `value' does not matter) and `add' (sets the property to value within the given section only if it does not exist yet). 

To change the number of needed replicas for a file:
\begin{verbatim}
chelonia modify <LN> set states neededReplicas <number of needed replicas>    
\end{verbatim}

To close a collection:
\begin{verbatim}
chelonia modify <LN> set states closed yes    
\end{verbatim}

To change metadata key-value pairs:
\begin{verbatim}
chelonia modify <LN> set|unset|add metadata <key> <value>    
\end{verbatim}
% subsubsection modify (end)

\subsubsection{policy} % (fold)
\label{ssub:policy}

With the \texttt{policy}\index{commands:chelonia:policy} or \texttt{pol} method it is possible to modify the policy of the entry
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia policy $<$LN$>$ $<$changeType$>$ $<$identity$>$ $<$action list$>$}   
\end{shaded}

The possible values of `changeType' are `set' (sets the action list to the given user overwriting the old one), `change' (modify the current action list with adding and removing actions) and `clear' (clear the action list of the given user).

The `identity' could be currently three things: the DN of a user; the name of a VO (with the syntax: `VOMS:$<$VO name$>$'); or `ALL' for all users.

The `action list' is a list of actions prefixed with `+' or `-', e.g. `+read +addEntry -delete'.

These are the actions which can be used for access control:
\begin{itemize}
    \item \emph{read}: user can get the list of entries in the collection; user can download the file
    \item \emph{addEntry}: user can add a new entry to the collection;
    \item \emph{removeEntry}: user can remove any entry from the collection 
    \item \emph{delete}: user can delete the collection if it is empty; user can delete a file
    \item \emph{modifyPolicy}: user can modify the policy of the file/collection
    \item \emph{modifyStates}: user can modify some special metadata of the file/collection (close the collection, change the number of needed replica of the file)
    \item \emph{modifyMetadata}: user can modify the arbitrary metadata section of the file/collection (these are property-value pairs)
\end{itemize}

There is an implicit default policy: the owner always has all the rights.
Checking the `stat' of new collections:
\begin{verbatim}
$ chelonia stat /newcoll
'/newcoll': found
  states
    closed: no
  entry
    owner: /C=HU/O=NIIF CA/OU=GRID/OU=NIIF/CN=Nagy Zsombor
    GUID: 41CBD461-09BE-46FD-8A1B-767C7D427AF9
    type: collection
  parents
    0/newcoll: parent
  timestamps
    created: 1257435820.26
  entries
    thing: A63658B4-2C6E-46A3-8238-7D291F8F81C2
\end{verbatim}
shows no policies, but it shows the owner. This collection has no additional policies just the default one: the owner can do anything, noone else can do anything.

Let's set it in a way that all users can read the contents of this collection:
\begin{verbatim}
$ chelonia policy /newcoll change ALL +read
Setting action list of '/newcoll' for user ALL to +read: set.
$ chelonia stat /newcoll
'/newcoll': found
  [...]
  policy
    ALL: +read
  [...]
\end{verbatim}

Then we can set that all the members of the knowarc VO would be able to add entries to this collection:
\begin{verbatim}
$ chelonia policy /newcoll change VOMS:knowarc +addEntry
Setting action list of '/newcoll' for user VOMS:knowarc to +addEntry: set.
$ chelonia stat /newcoll
'/newcoll': found
  [...]
  policy
    ALL: +read
    VOMS:knowarc: +addEntry
  [...]
\end{verbatim}

And for example we can set a specific user to be able to remove entries from this collections:
\begin{verbatim}
$ chelonia policy /newcoll change \
    "/C=HU/O=NIIF CA/OU=GRID/OU=NIIF/CN=TestUser" +removeEntry
Setting action list of '/newcoll'
    for user /C=HU/O=NIIF CA/OU=GRID/OU=NIIF/CN=TestUser to +removeEntry: set.
$ chelonia stat /newcoll'/newcoll': found
  [...]
  policy
    /C=HU/O=NIIF CA/OU=GRID/OU=NIIF/CN=TestUser: +removeEntry
    ALL: +read
    VOMS:knowarc: +addEntry
  [...]
\end{verbatim}

% subsubsection policy (end)

\subsubsection{unlink} % (fold)
\label{ssub:unlink}

With the \texttt{unlink}\index{commands:chelonia:unlink} method it is possible to remove a file or collection just from its parent collection without removing the file or collection itself.
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia unlink $<$LN$>$}   
\end{shaded}

If there is a file called `/newcoll/thing', it is in the listing of the `/newcoll' collection:
\begin{verbatim}
$ chelonia list /newcoll
'/newcoll': collection
  thing <file>
\end{verbatim}    
The file is in the entries of the collection:
\begin{verbatim}
$ chelonia stat /newcoll
'/newcoll': found
  entries
    thing: A63658B4-2C6E-46A3-8238-7D291F8F81C2
  [...]
\end{verbatim}

It is possible the `stat' the file with the Logical Name `/newcoll/thing':
\begin{verbatim}
jim:~ zsombor$ chelonia stat /newcoll/thing
'/newcoll/thing': found
  states
    checksumType: md5
    neededReplicas: 3
    size: 6
    checksum: a0186a90393bd4a639a1ce35d8ef85f6
  [...]
\end{verbatim}

Now with the `unlink' method it is possible to remove the file from the `/newcoll' collection, but not from the system:
\begin{verbatim}
$ chelonia unlink /newcoll/thing
Unlinking '/newcoll/thing': unset
\end{verbatim}

Now the file is not in the collection anymore:
\begin{verbatim}
$ chelonia list /newcoll
'/newcoll': collection
    empty.
$ chelonia stat /newcoll/thing
'/newcoll/thing': not found
\end{verbatim}

But with the GUID of the file, it can still be accessed:
\begin{verbatim}
$ chelonia stat A63658B4-2C6E-46A3-8238-7D291F8F81C2
'A63658B4-2C6E-46A3-8238-7D291F8F81C2': found
  states
    checksumType: md5
    neededReplicas: 3
    size: 6
    checksum: a0186a90393bd4a639a1ce35d8ef85f6
  [...]
\end{verbatim}
% subsubsection unlink (end)

\subsubsection{credentialDelegation} % (fold)
\label{ssub:credentialdelegation}
With the \texttt{credentialDelegation}\index{commands:chelonia:credentialDelegation} or \texttt{cre} method it is possible to delegate credentials to the Bartender.
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia credentialDelegation}   
\end{shaded}
% subsubsection credentialdelegation (end)

\subsubsection{removeCredentials} % (fold)
\label{ssub:removecredentials}
With the \texttt{removeCredentials}\index{commands:chelonia:removeCredentials} or \texttt{rem} method it is possible to remove the previously delegated credentials.
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia removeCredentials}   
\end{shaded}
% subsubsection removecredentials (end)

\subsubsection{makeMountPoint} % (fold)
\label{ssub:makemountpoint}
With the \texttt{makeMountPoint}\index{commands:chelonia:makeMountPoint} or \texttt{makemount} method it is possible to create a mount point within the namespace of Chelonia which points to a GridFTP server.
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia makeMountPoint $<$LN$>$ $<$URL$>$}   
\end{shaded}

The `LN' is the requested Logical Name for the mount point, the `URL' points to the GridFTP server.
% subsubsection makemountpoint (end)

\subsubsection{unmakeMountPoint} % (fold)
\label{ssub:unmakemountpoint}
With the \texttt{unmakeMountPoint}\index{commands:chelonia:unmakeMountPoint} or \texttt{unmount} method it is possible to remove a previously created mount point.
\hspace*{0.5cm}
\begin{shaded}
   \uicommand{chelonia unmakeMountPoint $<$LN$>$}   
\end{shaded}

The `LN' is the Logical Name of the mount point.
% subsubsection unmakemountpoint (end)