\documentclass{article}
\usepackage{graphicx}                              %for PNG images (pdflatex)
\usepackage{graphics}                              %for EPS images (latex)
\usepackage[linkbordercolor={1.0 1.0 0.0}]{hyperref} %for \url tag
\usepackage{color}                                 %for defining custom colors
\usepackage{framed}                                %for shaded and framed paragraphs
\usepackage{textcomp}                              %for various symbols, e.g. Registered Mark
\usepackage{geometry}                              %for defining page size
\usepackage{longtable}                             %for breaking tables
%

%---CUSTOM FLOAT---
\usepackage{float}
\floatstyle{ruled}
\newfloat{example}{H}{loe}
\floatname{example}{Example}
\floatstyle{plain}
\newfloat{illustration}{htp}{loi}
\floatname{illustration}{Illustration}

%
\geometry{verbose,a4paper,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2cm}
\hypersetup{
  pdfauthor = {Tamas Kazinczy},
  pdftitle = {Documentation of ARC1 Python API},
  pdfsubject = {},
  pdfkeywords = {API,ARC1,arcom,Python,SWIG},
  pdfcreator = {PDFLaTeX with hyperref package},
  pdfproducer = {PDFLaTeX}
}
%
\bibliographystyle{IEEEtran}                       %a nice bibliography style
%
\def\efill{\hfill\nopagebreak}%
\hyphenation{Nordu-Grid}
\setlength{\parindent}{0cm}
\setlength{\FrameRule}{1pt}
\setlength{\FrameSep}{8pt}
\addtolength{\parskip}{5pt}
%\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\arraystretch}{1.3}
\newcommand{\dothis}{\colorbox{shadecolor}}
\newcommand{\globus}{Globus Toolkit\textsuperscript{\textregistered}~2~}
\newcommand{\GT}{Globus Toolkit\textsuperscript{\textregistered}}
\newcommand{\ngdl}{\url{http://download.nordugrid.org/}~}
\definecolor{shadecolor}{rgb}{1,1,0.6}
\definecolor{salmon}{rgb}{1,0.9,1}
\definecolor{bordeaux}{rgb}{0.75,0.,0.}
\definecolor{cyan}{rgb}{0,1,1}
%
%----- DON'T CHANGE HEADER MATTER
\begin{document}
\def\today{\number\day/\number\month/\number\year}

\begin{titlepage}

\begin{tabular}{rl}
\resizebox*{3cm}{!}{\includegraphics{fig/logo-knowarc.png}}
\end{tabular}

\hrulefill

%-------- Change this to Knowarc_D<w>.<d>-<n>_<yy>

{\raggedleft Knowarc\_D0.0-0\_00\par}

{\raggedleft \today\par}

\vspace*{2cm}

%%%%---- The title ----
{\centering \textsc{\Large The SWIG wrapped ARC Python API and the arcom utility package\footnote{as of rev. 13724}}\Large \par}
\vspace*{0.5cm}
    
%%%%---- A subtitle, if necessary ----
%{\centering \textit{\large Paper subtitle}\large \par}
    
\vspace*{1.5cm}
%%%%---- A list of authors ----
    {\centering \large Tam\'as Kazinczy\footnote{kazy@niif.hu} \large \par}
    
%%%%---- An abstract - if style is article ----
%\begin{abstract}
%The abstract
%\end{abstract}
\end{titlepage}

\tableofcontents
\newpage
%\listoffigures
%\newpage


\section{Preface}
When it comes to creating new functionality in ARC\footnote{Advanced Resource Connector; \url{http://www.nordugrid.org/middleware/}} 
it is nice if one could do that in a simple, quick and neat way.
Python\footnote{\url{http://www.python.org/}} is known for its versatility, simple and clean design, that
made it a good choice for rapid prototyping and gluing.
As the new ARC has moved towards the service oriented architecture, it has become a viable 
option to use Python both for creating new services and gluing existing ones together.
To be able to work with the functionality provided by ARC HED\footnote{Hosting Environment Daemon; \url{http://www.nordugrid.org/documents/ARCHED\_article.pdf}}, 
a decision was made to wrap its API with SWIG\footnote{Simplified Wrapper and Interface Generator; \url{http://www.swig.org/}}.
Furthermore, the arcom utility package was created on the basis of Python modules 
that had been created to ease developers' lives. (It contains reusable components to support various parts of development, including but not limited to the following categories: client development, logging, security and service development.)

\subsection{Purpose of this document}

Objectives of this document are:

\begin{itemize}

  \item{to demonstrate differences of original and wrapped API}

  \item{to comment about the use of ARC Python API}

  \item{to document the arcom utility package}

\end{itemize}

\subsection{Structure}

The document has the following structure:

\begin{itemize}

  \item{In the first part we provide an overview of how the API is wrapped by SWIG. 
    Here the use of SWIG interface files will be discussed along with the main 
    differences resulting from them and some thoughts will be given about usage.}

  \item{In the second part the arcom utility package will be discussed.
    Here the functionality found in the package will be described and some
    examples of use will be shown.}

\end{itemize}

\section{The SWIG generated API}

In this part the following topics will be covered: 

\begin{itemize}

  \item{Python specific parts of SWIG interface files}

  \item{main differences between the original and the SWIG generated API resulting 
    from the style of wrapping}

  \item{the use of the generated API from Python}

\end{itemize}

\subsection{Python specific parts of SWIG interface files}

SWIG interface files are found in the swig subdirectory under the ARC source directory.

Specific parts for Python in SWIG interface files are enclosed in SWIGPYTHON blocks, 
starting with \textit{\#ifdef SWIGPYTHON} and ending with \textit{\#endif}.

There are seven interface files that contain such blocks:

\begin{itemize}
  \item{Arc.i}

  \item{common.i}

  \item{message.i}

  \item{client.i}

  \item{data.i}

  \item{delegation.i}

  \item{security.i}
\end{itemize}

When not in a specific block (neither Python nor another - e.g. SWIGJAVA), instructions
are applied to all languages.

\subsubsection{Arc.i}
\label{iArc}
\begin{flushleft}
\begin{itemize}
  \item{\verb$%module arc$} \linebreak
    As stated in the SWIG documentation\footnote{\url{http://www.swig.org/Doc1.3/SWIGDocumentation.html}}: ''The \verb$%module$ directive defines the name of the module that will be created by SWIG.''
    That means, this module could be imported in Python code with: \textit{import arc}
\end{itemize}
\begin{itemize}
  \item{\verb$%include <stl.i>$} \linebreak
    Include the Standard Template Library, so that templates could be used.
\end{itemize}
\begin{itemize}
  \item{
\begin{verbatim}
  #ifdef SWIGPYTHON
  %include <std_list.i>
  #endif\end{verbatim}
    If target language is Python include \verb$std_list$.
  } \linebreak
\end{itemize}
\begin{itemize}
  \item{\verb$%template(StringList) std::list<std::string>;$\linebreak
    Define StringList as a template list of strings. An example of handling a list of strings is shown below. \linebreak
    \begin{example}
      \caption{Handling a list of strings}\label{listex}
\begin{verbatim}
>>> import arc
>>> #create an empty list
... sl = arc.StringList()
>>> #append strings to the list
... #size increases
... sl.size()
0
>>> sl.append('apple')
>>> sl.size()
1
>>> sl.append('banana')
>>> sl.size()
2
>>> sl.append('lemon')
>>> sl.size()
3
>>> sl.append('orange')
>>> sl.size()
4
>>> #list members
... sl[0], sl[1], sl[2], sl[3]
('apple', 'banana', 'lemon', 'orange')
>>> #do some slicing
... tmp = sl[:2]
>>> #now tmp contains the first two strings
... tmp.size()
2
>>> tmp[0], tmp[1]
('apple', 'banana')
>>> #do some more slicing
... tmp = sl[1:]
>>> #now tmp contains all the strings except the first
... tmp.size()
3
>>> tmp[0], tmp[1], tmp[2]
('banana', 'lemon', 'orange')
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{\verb$%template(StringStringMap) std::map<std::string, std::string>;$ \linebreak
    Define StringStringMap as a template map where both key and value are strings.\linebreak
    \begin{example}
      \caption{arc.StringStringMap}\label{mapex}
\begin{verbatim}
>>> import arc
>>> #create an empty map
... ssm = arc.StringStringMap()
>>> #add mapping
... ssm['key1'] = 'value1'
>>> ssm['key2'] = 'value2'
>>> #get keys
... ssm.keys()
['key1', 'key2']
>>> #get value for 'key1'
... ssm['key1']
'value1'
>>> #get value for 'key2'
... ssm['key2']
'value2'
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{
\begin{verbatim}
  %include "common.i"
  %include "message.i"
  %include "client.i"
  %include "data.i"
  %include "delegation.i"\end{verbatim}
  Include other interface files.
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
  #ifdef SWIGPYTHON
  %include "security.i"
  #endif\end{verbatim}
  If target language is Python include interface file: security.i
  }
\end{itemize}
\end{flushleft}

%\newpage
\subsubsection{common.i}
\label{icommon}
\begin{flushleft}
\begin{itemize}
  \item{ \verb$%include <typemaps.i>$} \linebreak
  Typemaps will be used. 
\end{itemize}
\begin{itemize}
  \item{\begin{verbatim}
  %ignore operator !;
  %ignore operator [];
  %ignore operator =;
  %ignore operator ++;
  %ignore operator <<;

  %ignore *::operator [];
  %ignore *::operator ++;
  %ignore *::operator --;
  %ignore *::operator =;

  %ignore Arc::MatchXMLName;
  %ignore Arc::MatchXMLNamespace;

  %template(XMLNodeList) std::list<Arc::XMLNode>;
  %template(URLList) std::list<Arc::URL>;
  \end{verbatim}
  }
  As stated in SWIG documentation: ''\verb$%ignore$ instructs SWIG to ignore 
  declarations that match a given identifier.
  Any function, variable, etc. which matches \verb$%ignore$ will not be wrapped 
  and therefore will not be available from the target language.''
  According to this, ignored operators and methods above will not be accessible 
  from Python. \linebreak
  Define XMLNodeList as a template list of Arc::XMLNode and URLList as a template list of 
  Arc::URL objects. (See Example\ref{listex} for an example of using a list of objects - 
  list of strings in that particular case - in Python.)\linebreak
\end{itemize}
\begin{itemize}
  \item{
\begin{verbatim}
  %rename(toBool) operator bool;
  %rename(__str__) operator std::string;
\end{verbatim} 
    If target language is Python then apply the following:
    \begin{itemize}
      \item{
      The operator ''bool'' is being renamed to ''toBool'' and is thus accessible from Python that way. 
      However, ''toBool'' does not appear in the Python API, that is, there is no trace of ''toBool'' 
      either in the generated code or in error messages.
      }
      \item{
      The operator ''std::string'' is being renamed to ''\verb$__str__$'' and is thus accessible from 
      Python that way.
      }
    \end{itemize}
    \begin{example}
      \caption{String operator - simple node}\label{strex1}
\begin{verbatim}
>>> import arc
>>> #create an XMLNode
... mynode = arc.XMLNode(arc.NS({'me':'http://example.com/myExample'}),'me:myNode')
>>> #set text content
... mynode.Set('Hello, World!')
>>> #representation of the node
... mynode.GetXML()
'<me:myNode xmlns:me="http://example.com/myExample">Hello, World!</me:myNode>'
>>> #String operator in action
... str(mynode)
'Hello, World!'
\end{verbatim}
    \end{example}
    \begin{example}
      \caption{String operator - complex node}\label{strex2}
\begin{verbatim}
>>> # String operator of XMLNode works with the text content.
... # It does not care about child nodes or text contents of those nodes.
>>> 
>>> # build a tree and set text content in nodes
... #       r
... #     / | \
... #    /  |  \
... #   /   |   \
... # c01  c02  c03
... #      /\    |
... #     /  \  c06  
... #   c04  c05
... 
>>> # create the root node
... r = arc.XMLNode(arc.NS(),'r')
>>> # set text content
... r.Set('R')
>>> # create rest of the tree
... c01 = r.NewChild('c01')
>>> c01.Set('C-01')
>>> c02 = r.NewChild('c02')
>>> c02.Set('C-02')
>>> c03 = r.NewChild('c03')
>>> c03.Set('C-03')
>>> c04 = c02.NewChild('c04')
>>> c04.Set('C-04')
>>> c05 = c02.NewChild('c05')
>>> c05.Set('C-05')
>>> c06 = c03.NewChild('c06')
>>> c06.Set('C-06')
>>> # String operator does not care about child nodes
... str(c03)
'C-03'
>>> str(c02)
'C-02'
>>> str(r)
'R'
>>> # XML representation of a complex node
... c02.GetXML()
'<c02>C-02<c04>C-04</c04><c05>C-05</c05></c02>'
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{\verb$%rename(_print) Arc::Config::print;$ } \linebreak
  ''Arc::Config::print'' is being renamed to ''\verb$_print$'' and is thus accessible from 
  Python that way.
\end{itemize}
\begin{itemize}
  \item{\begin{verbatim}
  %apply std::string& OUTPUT { std::string& out_xml_str };
  %include "../src/hed/libs/common/XMLNode.h"
  %clear std::string& out_xml_str;\end{verbatim}
  It is common that a function provides return values through parameters (pointers or references).
  In Python, such functions should have multiple return values. This typemap tells SWIG that all 
  occurrences of ''\verb$out_xml_str$'' of type ''\verb$std::string&$'' as a parameter in XMLNode.h
  should be turned into ''\verb$std::string&$'' output values instead. An example regarding the 
  GetDoc function is shown below.
    \begin{example}
      \caption{Occurence of out\_xml\_str as an output value}\label{outxml}
\begin{verbatim}
>>> import arc
>>> #create node
... n = arc.XMLNode(arc.NS({'me':'myNS'}),'me:myNode')
>>> #set content
... n.Set('Hello, World!')
>>> #get document
... #GetDoc according to API:
... #void GetDoc(std::string &out_xml_str, bool user_friendly=false) const
... #out_xml_str is turned into an output value and user_friendly is an optional 
... #parameter so there are no necessary parameters this time
... #result will hold the output value
... result = n.GetDoc()
>>> #show result
... result
'<?xml version="1.0"?>\n<me:myNode xmlns:me="myNS">Hello, World!</me:myNode>\n'
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{\verb$%rename(LogStream_ostream) LogStream;$ \linebreak
  LogStream is being renamed to ''\verb$LogStream_ostream$''.
  It is so, because a function with the same name will be defined later.
  (See below.)
  }
\end{itemize}
\begin{itemize}
  \item{
\begin{verbatim}
%inline %{ 
class CPyOutbuf : public std::streambuf {
 ...
};

class CPyOstream : public std::ostream {
 ...
}; 

%}
\end{verbatim}
  Classes CPyOutBuf and CPyOstream are created. These are to be used when creating LogStreams.
  (Python does not have stream objects - it uses files instead - so these classes are defined 
   to be able to represent a Python file as an ostream that is required by the C++ code.)
  Although they will be accessible from Python and thus could be used to create LogStreams,
  it is much more comfortable to take advantage of the function defined right after.
  (Complete source code can be found in Appendix \ref{LogStreamHelperFullCode} of this document.)
  }
\end{itemize}
\begin{itemize}
  \item{\begin{verbatim}
%pythoncode %{
    def LogStream(file):
        os = CPyOstream(file)
        os.thisown = False
        ls = LogStream_ostream(os)
        ls.thisown = False
        return ls
%}
\end{verbatim}
  Provides an easy-to-use function to create LogStreams with.
    \begin{example}
      \caption{Using LogStream to add new destination to the root logger}\label{logstream}
\begin{verbatim}
>>> import arc
>>> import sys
>>> #get root logger
... root_logger = arc.Logger_getRootLogger()
>>> #create a LogStream; sys.stdout would be OK
... stream = arc.LogStream(sys.stdout)
>>> #add destination to root logger
... root_logger.addDestination(stream)
>>> #log a message
... #result immediately appears on sys.stdout
... root_logger.msg(arc.INFO, 'Hello, World!')
[2009-05-12 15:39:07] [Arc] [INFO] [28021/161022392] Hello, World!
\end{verbatim}
    \end{example}
  }
\end{itemize}
\end{flushleft}

%\newpage
\subsubsection{message.i}
\label{imessage}
\begin{flushleft}
\begin{itemize}
  \item{ \verb$%include <typemaps.i>$} \linebreak
  Typemaps will be used. 
\end{itemize}
\begin{itemize}
  \item{\verb$%rename(next) Arc::AttributeIterator::operator++;$ \linebreak
  Rename ''operator++'' of Arc::AttributeIterator to ''next''.
  For an example see the wrapping of Arc::MessageAttributes::getAll below. 
  }
\end{itemize}
\begin{itemize}
  \item{\begin{verbatim}
  #ifdef SWIGPYTHON
  %pythonappend Arc::MessageAttributes::getAll %{
      d = dict()
      while val.hasMore():
          d[val.key()] = val.__ref__()
          val.next()
      return d
  %}
  #endif\end{verbatim} 
  If target language is Python then append the above code to ''Arc::MessageAttributes::getAll''. 
  Basically this means that MessageAttributes are rather returned as a dictionary.
  (The original result is an iterator. This iterator is used in the appended code to collect 
   MessageAttributes and put them in a dictionary which is more natural to use in Python.)
    \begin{example}
      \caption{MessageAttributes - getAll}\label{msgattrex}
\begin{verbatim}
>>> import arc
>>> #create MessageAttributes object
... mas = arc.MessageAttributes()
>>> #add some key-value pairs
... mas.add('key1', 'value1')
>>> mas.add('key3', 'value3')
>>> mas.add('key2', 'value2')
>>> #get all attributes
... all = mas.getAll()
>>> #show result
... all
{'key3': 'value3', 'key2': 'value2', 'key1': 'value1'}
>>> #function returns a dictionary
... type(all)
<type 'dict'>
>>> #show keys
... all.keys()
['key3', 'key2', 'key1']
>>> #show values
... all.values()
['value3', 'value2', 'value1']
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
  %apply std::string& OUTPUT { std::string &val };
  %include "../src/hed/libs/message/SecAttr.h"
  %clear std::string &val;\end{verbatim} 
  This typemap tells SWIG that all occurrences of ''val'' of type ''\verb$std::string&$'' as a parameter
  in SecAttr.h should be turned into ''\verb$std::string&$'' output values instead.
  An example could be the Export functionality of SecAttr. However, SecAttr is a base class that
  should be extended, and such classes are not yet available for the Python API.
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
  #ifdef SWIGPYTHON
  %pythonprepend Arc::MessageAuth::Export %{
        x = XMLNode("<dummy/>")
        args = args[:-1] + (args[-1].fget(), x)
  %}
  %pythonappend Arc::MessageAuth::Export %{
        return x
  %}
  #endif \end{verbatim} 
  If target language is Python then ''Arc::MessageAuth::Export'' is modified in a way that: 
    \begin{itemize}
    \item{
      A dummy node is created that will be replaced with the actual output.
    }
    \item{
      The argument tuple (args) of the method is recreated to contain the dummy node mentioned above.
      (It will be the last element of the tuple.) Note that the fget() call is required to get the
      SecAttrFormat from the property object as current SecAttrFormats are defined as property objects
      in the SecAttr class.
    }
    \item{
      Finally, the new output - that used to be the dummy node - is returned.
    }
    \end{itemize}
  An example would require the use of SecAttr here, therefore one is not yet available for the Python API.
  (An own extension of SecAttr on the Python side would not be enough here because it would not be used by MessageAuth.)
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
  %apply std::string& OUTPUT { std::string& out_xml_str }; 
  %include "../src/hed/libs/message/SOAPEnvelope.h"
  %clear std::string& out_xml_str;
  \end{verbatim}
  This tells SWIG that all occurrences of ''\verb$out_xml_str$'' of type ''\verb$std::string&$'' as a parameter in SOAPEnvelope.h
  should be turned into ''\verb$std::string&$'' output values instead. An example regarding the GetXML function is shown below.
    \begin{example}
      \caption{SOAPEnvelope - out\_xml\_str}\label{outxmlex}
\begin{verbatim}
>>> import arc
>>> #create a namespace
... ns = arc.NS({'me':'http://example.com/myExample'})
>>> #create an empty SOAPEnvelope
... #use the namespace created above
... se = arc.SOAPEnvelope(ns,False)
>>> #show it
... se.GetXML()
'<soap-env:Envelope xmlns:me="http://example.com/myExample" xmlns:soap-enc="http
://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.or
g/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http:/
/www.w3.org/2001/XMLSchema-instance"><soap-env:Body/></soap-env:Envelope>'
\end{verbatim}
    \end{example}
  }
\end{itemize}
\end{flushleft}

\subsubsection{client.i}
\label{iclient}
\begin{flushleft}
\begin{itemize}
  \item{ \begin{verbatim}
  %template(ExecutionTargetList) std::list<Arc::ExecutionTarget>;
  %template(JobControllerList) std::list<Arc::JobController *>;
  %template(JobList) std::list<Arc::Job>;
  %template(JobStateList) std::list<Arc::JobState>;
  %template(SourceTypeList) std::list<Arc::DataSourceType>;
  %template(TargetTypeList) std::list<Arc::DataTargetType>;
  %template(FileTypeList) std::list<Arc::FileType>;
  %template(DirectoryTypeList) std::list<Arc::DirectoryType>;
  %template(ApplicationEnvironmentList) std::list<Arc::ApplicationEnvironment>;
  %template(SoftwareVersionList) std::list<Arc::SoftwareVersion>;
  %template(SoftwareRequirementList) std::list<Arc::SoftwareRequirement>;
  \end{verbatim}
  }
  Define ExecutionTargetList as a template list of Arc::ExecutionTarget objects, 
  JobControllerList as a template list of Arc::JobController pointers, 
  JobList as a template list of Arc::Job, JobStateList as a template list of 
  Arc::JobState, SourceTypeList as a template list of Arc::DataSourceType, 
  TargetTypeList as a template list of Arc::DataTargetType, FileTypeList as a 
  template list of Arc::FileType, DirectoryTypeList as a template list of 
  Arc::DirectoryType, ApplicationEnvironmentList as a template list of 
  Arc::ApplicationEnvironment, SoftwareVersionList as a template list of 
  Arc::SoftwareVersion and SoftwareRequirementList as a template list of 
  Arc::SoftwareRequirement objects. \linebreak
  (See Example\ref{listex} for an example of using a list of objects in Python.)
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
  #ifdef SWIGPYTHON
  namespace Arc {

  %typemap(in, numinputs=0) PayloadSOAP ** response (PayloadSOAP *temp) {
      $1 = &temp;
  }
  \end{verbatim}
  If target language is Python then this input typemap tells SWIG that ''response'' 
  arguments of type ''PayloadSOAP **'' found in ''Arc'' namespace are to be ignored. 
  As stated in the SWIG documentation: ''When numinputs is set to 0, the argument is 
  effectively ignored and cannot be supplied from the target language. '' 
  However the argument is still required when making the C/C++ call. This is solved 
  by providing a locally declared variable called temp from which the value used is 
  obtained. Statement ''\verb#$1 = &temp;#'' sets the input argument to point to this 
  temporary variable.
  \begin{verbatim}
  %typemap(argout) PayloadSOAP ** response {
      PyObject *o, *tuple;
      o = SWIG_NewPointerObj(*$1, SWIGTYPE_p_Arc__PayloadSOAP, SWIG_POINTER_OWN | 0 );
      tuple = PyTuple_New(2);
      PyTuple_SetItem(tuple,0,o);
      PyTuple_SetItem(tuple,1,$result);
      $result = tuple;
  }
  \end{verbatim}
  As the SWIG documentation tells: ''The \verb$"argout"$ typemap is used to return values from arguments.''
  With the previous typemap in mind this one indicates that the result will be changed as the following:
    \begin{itemize}
    \item{
      A tuple will be created with two members.
    }
    \item{
      The first member comes from the argument.
    }
    \item{
      The second one comes from the original result.
    }
    \item{
      The tuple will be returned as the new result.
    }
    \end{itemize}
  When processing a SOAP request it is required to return \verb$MCC_Status$ along with
  the SOAP response. This is achieved by returning a tuple that contains both of them.
  An example of calling the Echo service is shown below.
    \begin{example}
      \caption{ClientSOAP - process}\label{procex}
\begin{verbatim}
>>> import arc
>>> #create default config
... cfg = arc.MCCConfig()
>>> #create URL
... url = arc.URL('http://localhost:50000/Echo')
>>> #create payload
... payload = arc.PayloadSOAP(arc.NS({'echo':'urn:echo'}))
>>> #create payload content
... #and set echo message
... payload.NewChild('echo:echo').NewChild('echo:say').Set('Hello, World!')
>>> #create client
... client = arc.ClientSOAP(cfg,url)
>>> #let the client call the service
... response, status = client.process(payload)
>>> #see response
... print response.GetXML()
<soap-env:Envelope xmlns:echo="urn:echo" xmlns:soap-enc="http://schemas.xmlsoap.
org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" x
mlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XM
LSchema-instance"><soap-env:Body><echo:echoResponse><echo:hear>[ Hello, World! ]
</echo:hear></echo:echoResponse></soap-env:Body></soap-env:Envelope>
>>> #check status
... status.getKind() == arc.STATUS_OK
True
\end{verbatim}
    \end{example}
  
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
%extend ACCLoader {
  Arc::Broker * getBroker(const std::string& brokername) { 
      return dynamic_cast<Arc::Broker*>( self->getACC(brokername) ); 
  }
  Arc::Broker * loadBroker(const std::string& brokername, const XMLNode * cfg) { 
      return dynamic_cast<Arc::Broker*>( self->loadACC(brokername, cfg) ); 
  }
  Arc::JobController * getJobController(const std::string& jobcontrollername) { 
      return dynamic_cast<Arc::JobController*>( self->getACC(jobcontrollername) ); 
  }
  Arc::JobController * loadJobController(const std::string& jobcontrollername, 
                                         const XMLNode * cfg) { 
      return dynamic_cast<Arc::JobController*>( 
                                         self->loadACC(jobcontrollername, cfg) ); 
  }
}
  \end{verbatim}
  SWIG methods added to get/load Broker and JobController objects from an ACCLoader object.
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
  %apply std::string& INOUT { std::string& delegation_id };
  %include "../src/hed/libs/client/ClientX509Delegation.h"
  %clear std::string& delegation_id;
  \end{verbatim}
  This tells SWIG that all occurrences of ''\verb$delegation_id$'' of type ''\verb$std::string&$'' 
  as a parameter in ClientX509Delegation.h should be used as input and turned into 
  ''\verb$std::string&$'' output values as well. In fact, it depends on the type of delegation
  whether ''\verb$delegation_id$'' is used as an input or is created and returned as an output value.
  (See example below.)
    \begin{example}
      \caption{ClientX509Delegation - delegation\_id}\label{delegex}
\begin{verbatim}
For example the class ClientX509Delegation have a method createDelegation that makes 
use of delegation_id: 
  "For gridsite delegation service, the delegation_id
   is supposed to be created by client side, and sent to service side;
   for ARC delegation service, the delegation_id is supposed to be created
   by service side, and returned back. So for gridsite delegation service,
   this parameter is treated as input, while for ARC delegation service,
   it is treated as output."
However, this implies that one should take great care when dealing with delegation_id.
\end{verbatim}
    \end{example}
  }
\end{itemize}
\end{flushleft}

\subsubsection{data.i}
\label{idata}
\begin{flushleft}
\begin{itemize}
  \item{ \begin{verbatim}
  #ifdef SWIGPYTHON
  namespace Arc {
  \end{verbatim}
  If target language is Python then proceed with the following rules in ''Arc'' namespace.
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
  %typemap(in, numinputs=0) std::list<FileInfo> & files (std::list<FileInfo> temp) {
    $1 = &temp;
  }
  \end{verbatim}
  This input typemap tells SWIG that ''files'' arguments of type ''\verb$std::list<FileInfo>&$''
  are to be ignored. However the argument is still required when making the C/C++ call. 
  This is solved by providing a locally declared variable called temp from which the value 
  used is obtained. Statement ''\verb#$1 = &temp;#'' sets the input argument to point to this temporary variable.

  \begin{verbatim}
  %typemap(argout) std::list<FileInfo> & files {
    PyObject *o, *tuple;
    o = PyList_New(0);
    std::list<Arc::FileInfo>::iterator it;
    for (it = (*$1).begin(); it != (*$1).end(); ++it) {
        PyList_Append(o, SWIG_NewPointerObj(new Arc::FileInfo(*it), 
            SWIGTYPE_p_Arc__FileInfo, SWIG_POINTER_OWN | 0 ));
    }
    tuple = PyTuple_New(2);
    PyTuple_SetItem(tuple,0,o);
    PyTuple_SetItem(tuple,1,$result);
    $result = tuple;
  }
  \end{verbatim}
  This argout typemap - with the previous typemap in mind - indicates that the result will be changed as the following:
    \begin{itemize}
    \item{
      A tuple will be created with two members.
    }
    \item{
      The first member comes from the argument.
    }
    \item{
      The second one comes from the original result.
    }
    \item{
      The tuple will be returned as the new result.
    }
    \end{itemize}
    \begin{example}
      \caption{DataPointARC - ListFiles}\label{lfex}
\begin{verbatim}
One possible use of the FileInfo list could be the ListFiles funcionality of the 
DataPointARC class. This returns DataStatus along with the collected files. An example 
of using ListFiles will be shown later.
\end{verbatim} See Example\ref{url2dp} for details.
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
  %typemap(in, numinputs=0) std::string& failure_description (std::string temp) {
    $1 = &temp;
  }
  \end{verbatim}
  This input typemap tells SWIG that \verb$failure_description$ arguments of type \verb$std::string&$
  are to be ignored. However the argument is still required when making the C/C++ call. 
  This is solved by providing a locally declared variable called temp from which the value 
  used is obtained from. Statement ''\verb#$1 = &temp;#'' sets the input argument to point to this temporary variable.
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
  %typemap(argout) std::string & failure_description {
    PyObject *o, *tuple;
    tuple = PyTuple_New(2);
    o = PyString_FromString($1->c_str());
    PyTuple_SetItem(tuple,0,$result);
    PyTuple_SetItem(tuple,1,o);
    $result = tuple;
  }
  \end{verbatim}
  This argout typemap - with the previous typemap in mind - indicates that the result will be changed as the following:
    \begin{itemize}
    \item{
      A tuple will be created with two members.
    }
    \item{
      The first member comes from the original result.
    }
    \item{
      The second one comes from the argument.
    }
    \item{
      The tuple will be returned as the new result.
    }

  One possible use of \verb$failure_description$ could be the Transfer funcionality of the 
  DataMover class. This returns a failure description along with the corresponding 
  DataStatus. This description may contain more details about the error if transfer 
  fails for some reason.
  (See example below.)
    \end{itemize}
    \begin{example}
      \caption{DataMover - Transfer}\label{dmex}
\begin{verbatim}
>>> import arc
>>> # create DataMover
... mover = arc.DataMover()
>>> # import datapoint_from_url from arcom package
... # DataPoints are required to use DataMover
... from arcom import datapoint_from_url
>>> # create source DataPoint
... src = datapoint_from_url('file://./file1')
>>> # create destination DataPoint
... dst = datapoint_from_url('file://./file2')
>>> # do the transfer
... status, failure = mover.Transfer(src, dst, arc.FileCache(), arc.URLMap())
>>> # check status
... str(status)
'Operation completed successfully'
>>> # check for failure message
... failure
''
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{\verb$%ignore Arc::DataHandle::operator->;$} \linebreak
  Ignored operator will not be accessible from Python.
\end{itemize}
\end{flushleft}
\subsubsection{delegation.i}
\label{idelegation}
\begin{flushleft}
\begin{itemize}
  \item{ \begin{verbatim}
  #ifdef SWIGPYTHON
  %ignore Arc::DelegationConsumer::Acquire(std::string&, std::string&);
  %ignore Arc::DelegationConsumerSOAP::UpdateCredentials(std::string&, std::string&, 
    const SOAPEnvelope&, SOAPEnvelope&);
  %ignore Arc::DelegationConsumerSOAP::DelegatedToken(std::string&, std::string&, 
    const SOAPEnvelope&, SOAPEnvelope&);
  %ignore Arc::DelegationConsumerSOAP::DelegatedToken(std::string&, std::string&, 
    const XMLNode&);
  %ignore Arc::DelegationContainerSOAP::UpdateCredentials(std::string&, 
    std::string&, const SOAPEnvelope&, SOAPEnvelope&);
  %ignore Arc::DelegationContainerSOAP::DelegatedToken(std::string&, std::string&, 
    const SOAPEnvelope&, SOAPEnvelope&);
  %ignore Arc::DelegationContainerSOAP::DelegatedToken(std::string&, std::string&, 
    const XMLNode&);
  #endif
  \end{verbatim}
  If target language is Python the selected methods are to be ignored and thus 
  will not be accessible.
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
    %apply std::string& OUTPUT { std::string& credentials };
    %apply std::string& OUTPUT { std::string& identity };
    %ignore DelegationContainerSOAP::UpdateCredentials(
          std::string &,const SOAPEnvelope &, SOAPEnvelope &);
    %include "../src/hed/libs/delegation/DelegationInterface.h"
    %clear std::string& identity;
    %clear std::string& credentials;
  \end{verbatim}
  These tell SWIG that all occurrences of ''credentials'' and ''identity'' of type 
  ''\verb$std::string&$'' in DelegationInterface.h should be turned into 
  ''\verb$std::string&$'' output values.
  Furthermore, ''DelegationContainerSOAP::UpdateCredentials'' - with the parameters above - 
  will not be available from Python.
  Note that this is required by SWIG to properly generate Python code because applying the 
  previous typemap would result in two UpdateCredentials method having exactly the same parameter list.
    \begin{example}
      \caption{DelegationConsumerSOAP - UpdateCredentials}\label{dcsucex}
\begin{verbatim}
UpdateCredentials functionality of DelegationConsumerSOAP contains both credentials
and identity according to the C++ API documentation:

bool Arc::DelegationConsumerSOAP::UpdateCredentials (std::string & credentials,
std::string & identity, const SOAPEnvelope & in, SOAPEnvelope & out)

Occurences are turned into output values, that is, Python API will have UpdateCredentials 
take two parameters (both of them being of type SOAPEnvelope) and return a list.
\end{verbatim}
    \end{example}
  }
\end{itemize}
\end{flushleft}

\subsubsection{security.i}
This interface file differs from previous ones in that it does not contain implicit wrapping. 
That is, content will be wrapped according to explicit statements alone found in this file.
Examples regarding security will be shown later in the discussion of the ''arcom.security'' module.
\begin{flushleft}
\begin{itemize}
  \item{\verb$namespace ArcSec$} \linebreak
  Proceed with the following rules in ''ArcSec'' namespace.
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
    %nodefaultctor Policy;
    class Policy  {};
    
    %nodefaultctor Request;
    class Request {};
  \end{verbatim}
  No default constructor will be generated for classes Policy and Request.
  }
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
    typedef enum {
      DECISION_PERMIT = 0,
      DECISION_DENY = 1,
      DECISION_INDETERMINATE = 2,
      DECISION_NOT_APPLICABLE = 3
    } Result;
   
    typedef struct {
      Result res;
    } ResponseItem;
  \end{verbatim}
  }
  Define Result and ResponseItem.
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
    class ResponseList {
    public:
      int size() ;
      ResponseItem* getItem(int n);
      ResponseItem* operator[](int n);
      bool empty();
    };
    
    class Response {
    public:
      ResponseList& getResponseItems ();
    };
   
    class Source {
     public:
      Source(const Source& s):node(s.node);
      Source(Arc::XMLNode& xml);
      Source(std::istream& stream);
      Source(Arc::URL& url);
      Source(const std::string& str);
    };

    class SourceFile: public Source {
     public:
      SourceFile(const SourceFile& s):Source(s),stream(NULL);
      SourceFile(const char* name);
      SourceFile(const std::string& name);
    };

    class SourceURL: public Source {
     public:
      SourceURL(const SourceURL& s):Source(s),url(NULL);
      SourceURL(const char* url);
      SourceURL(const std::string& url);
    };
  \end{verbatim}
  }
  These tells SWIG the classes and their methods to be wrapped.
\end{itemize}
\begin{itemize}
  \item{ \begin{verbatim}
    %nodefaultctor Evaluator;
    %newobject Evaluator::evaluate;
    class Evaluator {
    public:
        void addPolicy(const Source& policy,const std::string& id = "");
        %apply SWIGTYPE *DISOWN {Policy *policy};
        void addPolicy(Policy* policy,const std::string& id = "");
        %clear Policy *policy;
        Response* evaluate(Request* request);
        Response* evaluate(const Source& request);
        Response* evaluate(const Source& request, const Source& policy);
        Response* evaluate(const Source& request, Policy* policyobj);
        Response* evaluate(Request* request, Policy* policyobj);
        Response* evaluate(Request* request, const Source& policy);
    };

    %newobject EvaluatorLoader::getEvaluator;
    %newobject EvaluatorLoader::getRequest;
    %newobject EvaluatorLoader::getPolicy;
    class EvaluatorLoader {
    public:
        EvaluatorLoader();
        Evaluator* getEvaluator(const std::string& classname);
        Request* getRequest(const std::string& classname, 
                            const Source& requestsource);
        Policy* getPolicy(const std::string& classname, 
                          const Source& policysource);
    };
  \end{verbatim}
  No default constructor will be generated for the Evaluator class. \linebreak
  SWIG is also told about additional classes to be wrapped. 
  Furthermore, a hint is given to SWIG about ownership of objects in libarcsecurity.
  }
\end{itemize}
\end{flushleft}

\newpage

\section{The arcom utility package}

This part is dedicated to documenting the arcom utility package.
As it is meant to ease developers' lives, the arcom package comes
with a handful of helper classes and utility functions.
The package has the following structure:
\begin{itemize}

  \item{\verb$__init__$\newline
  Provides a set of readily available utility functions. These functions provide a way 
  of e.g. importing classes or better handling of XML structures.
  }

  \item{client\newline
  Provides a simple class (Client) for sending SOAP messages to services.
  }

  \item{logger\newline
  Defines log levels and provides a function to get a logger of choice.
  }

  \item{security\newline
  Collection of classes and functions that helps when dealing with authorization requests,
  policies and decision making.
  }

  \item{service\newline
  Provides a base class for service definition. This base class should be extended then.
  }

  \item{threadpool\newline
  Thread pool support. Consists of classes ThreadPool, ThreadPoolThread and ReadWriteLock.
  The latter is a lock object that allows many simultaneous ''read locks'', but only one 
  ''write lock.''
  }

  \item{xmltree\newline
  Provides the XMLTree class which provides a way to convert from XML to native Python 
  structures and vice versa.
  }

  \item{store\newline
  Provides classes for storing arbitrary objects locally.
  }

  \begin{itemize}

    \item{basestore\newline
    Provides a base class for stores. This base class should be extended.
    }

    \item{cachedpicklestore\newline
    Class for storing objects to files using the Python Pickle module\footnote{\url{http://docs.python.org/library/pickle.html}}. 
    This class keeps all the objects in memory.
    }

    \item{cachedstringstore\newline
    Class for storing objects to files as strings. This class keeps all the objects in memory.
    }

    \item{picklestore\newline
    Class for storing objects to files using the Python Pickle module.
    }

    \item{stringstore\newline
    Class for storing objects to files as strings.
    }

    \item{transdbstore\newline
    Class for storing objects to a transactional Berkeley DB\footnote{\url{http://www.oracle.com/database/berkeley-db/db/index.html}}.
    }

    \item{zodbstore\newline
    Class for storing objects to a Zope Object Database\footnote{\url{http://www.zope.org/Products/StandaloneZODB}}.
    }

  \end{itemize}

\end{itemize}

\subsection{\_\_init\_\_.py}
\label{ainit}
''\verb$__init__.py$'' contains those parts of the arcom package that are
readily accessible without any further action (apart from importing the 
arcom package itself).
\begin{flushleft}
\begin{itemize}
  \item{\verb$import_class_from_string(str)$\newline
  Imports a class given as a string parameter.\newline
  The string parameter has the format: ''[package.]*module.classname'',
  that is, package or packages (separated by periods) followed by 
  module name and finally the class name.
    \begin{example}
      \caption{Importing the Logger class from module ''logger'' of ''arcom'' package}\label{loglog}
\begin{verbatim}
>>> import arcom
>>> # From the logger module within the arcom package
... # import the Logger class
... Logger = arcom.import_class_from_string('arcom.logger.Logger')
>>> # Now the class could be access through Logger
... Logger
<class arcom.logger.Logger at 0x89081dc>
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{ \verb$get_attributes(node)$\newline
  Returns all attributes of the supplied XMLNode (node) in a dictionary
  where attribute names will serve as keys.
    \begin{example}
      \caption{Getting attributes from an XMLNode}\label{getattr}
\begin{verbatim}
>>> import arc
>>> import arcom
>>> # Create XMLNode
... n = arc.XMLNode(arc.NS({'me':'http://example.com/myExample'}),'me:myExample')
>>> # Add attributes to node and set their values
... n.NewAttribute('foo').Set('Hello')
>>> n.NewAttribute('moo').Set('World')
>>> # Show XML
... n.GetXML()
'<me:myExample xmlns:me="http://example.com/myExample" foo="Hello" moo="World"/>'
>>> # get attributes of this XMLNode
... a = arcom.get_attributes(n)
>>> # result is a dictionary
... type(a)
<type 'dict'>
>>> # show dictionary
... a
{'foo': 'Hello', 'moo': 'World'}
>>> # extracting an attribute value
... a['moo']
'World'
\end{verbatim}
    \end{example}
  }
\end{itemize}
\newpage
\begin{itemize}
  \item{ \verb$get_child_nodes(node)$\newline
  Gets children of the supplied XMLNode (node).
  Result will be returned as a list of XMLNodes.
\begin{verbatim}
In the example below, the following structure will be created:

<a>A
    <b>B</b>
    <c>C
        <e>E</e>
        <f>F</f>
    </c>
    <d>D
        <g>G</g>
    </d>
<a>

Relationships:

        a       children: (b, c, d)
       /|\      
      / | \     
     b  c  d    children: () (e, f) (g)
       / \  \   
      e   f  g  children: () () ()
\end{verbatim}
    \begin{example}
      \caption{Getting child nodes}\label{getchld}
\begin{verbatim}
>>> import arc
>>> import arcom
>>> # Create root node
... a = arc.XMLNode(arc.NS(),'a')
>>> # Create child nodes for 'a'
... b = a.NewChild('b')
>>> c = a.NewChild('c')
>>> d = a.NewChild('d')
>>> # Create child nodes for 'c'
... e = c.NewChild('e')
>>> f = c.NewChild('f')
>>> # Create child node for 'd'
... g = d.NewChild('g')
>>> # show XML
... a.GetXML()
'<a><b/><c><e/><f/></c><d><g/></d></a>'
>>> # get child nodes for 'a'
... tmp = arcom.get_child_nodes(a)
>>> # result is a list
... type(tmp)
<type 'list'>
>>> # 'a' has 3 children
... len(tmp)
3
>>> # show name for each
... ', '.join(x.Name() for x in tmp)
'b, c, d'
>>> # 'b' has no children
... tmp = arcom.get_child_nodes(b)
>>> len(tmp)
0
>>> # 'c' has 2 children: 'e' and 'f'
... tmp = arcom.get_child_nodes(c)
>>> len(tmp)
2
>>> ', '.join(x.Name() for x in tmp)
'e, f'
>>> # 'd' has 1 child: 'g'
... tmp = arcom.get_child_nodes(d)
>>> len(tmp)
1
>>> ', '.join(x.Name() for x in tmp)
'g'
>>> # nodes 'e', 'f' and 'g' have no children
... tmp = arcom.get_child_nodes(e)
>>> len(tmp)
0
>>> tmp = arcom.get_child_nodes(f)
>>> len(tmp)
0
>>> tmp = arcom.get_child_nodes(g)
>>> len(tmp)
0
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{ \verb$get_child_values_by_name(node, name)$\newline
  Gets values from children of a supplied XMLNode (node),
  where those children have the supplied name (name).
    \begin{example}
      \caption{Get values of specified children}\label{getchdval}
\begin{verbatim}
In the example below, the following structure will be created:

<node>
    <same>firstEQ</same>
    <same>secondEQ</same>
    <different>DIFF</different>
</node>

>>> import arc
>>> import arcom
>>> # Create XMLNode
... n = arc.XMLNode(arc.NS(),'node')
>>> # Create 3 child nodes (two of which get the same name)
... x = n.NewChild('same')
>>> y = n.NewChild('same')
>>> z = n.NewChild('different')
>>> # Set values for nodes
... x.Set('firstEQ')
>>> y.Set('secondEQ')
>>> z.Set('DIFF')
>>> # Show XML
... n.GetXML()
'<node><same>firstEQ</same><same>secondEQ</same><different>DIFF</different></node>'
>>> # Get child values where name is 'same'
... tmp = arcom.get_child_values_by_name(n,'same')
>>> # Result is a list
... type(tmp)
<type 'list'>
>>> # Show result
... tmp
['firstEQ', 'secondEQ']
>>> # Get child values where name is 'different'
... tmp = arcom.get_child_values_by_name(n,'different')
>>> # Show result
... tmp
['DIFF']
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{ \verb$datapoint_from_url(url_string)$\newline
  Creates DataPoint from specified URL (\verb$url_string$).
    \begin{example}
      \caption{Creating DataPoint from URL}\label{url2dp}
\begin{verbatim}
>>> import arc
>>> import arcom
>>> tmpList = []
>>> status = ''
>>> # create DataPoint from a local directory
... dp = arcom.datapoint_from_url('file:///usr/local/share/arc')
>>> # list files
... (files, stat) = dp.ListFiles()
>>> # if it is not empty
... if files:
>>>     status = 'found'
>>>     # for all the entries, get type and name
...     for f in files:
>>>         if (f.GetType() == arc.FileInfo.file_type_file):
>>>             type = 'file'
>>>         elif (f.GetType() == arc.FileInfo.file_type_dir):
>>>             type = 'dir'
>>>         else:
>>>             type = 'unknown'
>>>         # get results together in a list
...         tmpList.append(f.GetName() + ' (' + type + ')\n')
>>> else:
>>>     status = 'Could not access data. Reason: %s' % str(stat)
>>> 
>>> # see result
... str(stat)
'Operation completed successfully'
>>> # show list
... tmpList
['nordugrid.schema (unknown)\n']
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{ \verb$parse_url(url)$\newline
  Parses a URL. Gets protocol, host, port and path.
    \begin{example}
      \caption{Parsing a URL}\label{parseurl}
\begin{verbatim}
>>> import arcom
>>> proto, host, port, path = arcom.parse_url('boo://no.one.here:123/foo')
>>> proto
'boo'
>>> host
'no.one.here'
>>> port
123
>>> path
'foo'
\end{verbatim}
    \end{example}
  }
\end{itemize}

\end{flushleft}

\subsection{arcom.client}
\label{aclient}
Module ''arcom.client'' contains a base Client class for sending SOAP messages to services.
\begin{flushleft}
\begin{itemize}
  \item{ \verb$Client(url, ns, print_xml = False, xmlnode_class = arc.XMLNode, ssl_config = {})$\newline
  This is the constructor of the Client class.
  \begin{itemize}
    \item{url is the URL of the service, it could be a list of URLs}
    \item{ns contains the namespaces we want to use with each message}
    \item{\verb$print_xml$ is for debugging, prints all the SOAP messages to the screen}
    \item{\verb$xmlnode_class$ is the XML node class to be used; by default, it is ''arc.XMLNode''}
    \item{\verb$ssl_config$ is the SSL configuration to be used for secure connection; it is a dictionary that contains information about client (\verb$proxy_file$ or \verb$key_file$ and \verb$cert_file$) and CAs (\verb$ca_file$ or \verb$ca_dir$)}
  \end{itemize}
  }
\end{itemize}
\begin{itemize}
  \item{ \verb$call(tree, return_tree_only = False)$\newline
    Creates a SOAP message from an XMLTree and sends it to the service. \newline
    - tree is an XMLTree object containing the content of the request \newline
    - \verb$return_tree_only$ indicates that we only need to put the response into an XMLTree
    \begin{example}
      \caption{Creating a client and calling the echo service (XMLTree)}\label{clientex1}
\begin{verbatim}
>>> import arc
>>> import arcom
>>> # Import the Client class
... Client = arcom.import_class_from_string('arcom.client.Client')
>>> # Import the XMLTree class
... XMLTree = arcom.import_class_from_string('arcom.xmltree.XMLTree')
>>> # Create namespace - it will be used for the message sent
... ns = arc.NS({'echo':'urn:echo'})
>>> # Create client
... c = Client('http://your.server.example.com:50000/Echo',ns,print_xml=True)
>>> # Create message
... msg = XMLTree(from_tree = ('echo:echo',[('echo:say', 'Hello, World!')]))
>>> # Let the client do what it is meant for
... # Note that we created the client with print_xml=True
... # so both request and response will be displayed in an easy-to-read form
... c.call(msg)
Request:
        #   <soap-env:Body>
        #       <echo:echo>
        #           <echo:say>Hello, World!</echo:say>
        #       </echo:echo>
        #   </soap-env:Body>

Response:
        #   <soap-env:Envelope>
        #       <soap-env:Body>
        #           <echo:echoResponse>
        #               <echo:hear>[ Hello, World! ]</echo:hear>
        #           </echo:echoResponse>
        #       </soap-env:Body>
        #   </soap-env:Envelope>

'<soap-env:Envelope xmlns:echo="urn:echo" xmlns:soap-enc="http://schemas.xmlsoap.org/soap
/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://
www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap-en
v:Body><echo:echoResponse><echo:hear>[ Hello, World! ]</echo:hear></echo:echoResponse></s
oap-env:Body></soap-env:Envelope>'
\end{verbatim}
    \end{example}
  }
\end{itemize}
\begin{itemize}
  \item{ \verb$call_raw(outpayload)$\newline
  Send a POST request with the SOAP XML message.\newline
  - outpayload is an XMLNode with the SOAP message
    \begin{example}
      \caption{Creating a client and calling the echo service (SOAP)}\label{clientex2}
\begin{verbatim}
>>> import arc
>>> import arcom
>>> # Import the Client class
... Client = arcom.import_class_from_string('arcom.client.Client')
>>> # Create namespace - it will be used for the message sent
... ns = arc.NS({'echo':'urn:echo'})
>>> # Create client
... c = Client('http://arctest.ki.iif.hu:50000/Echo',ns,print_xml=True)
>>> # Create SOAP Payload
... pl = arc.PayloadSOAP(ns)
>>> # Create message structure and set content
... pl.NewChild('echo:echo',ns).NewChild('echo:say',ns).Set('Hello, World!')
>>> # Let client do the call; see response
... c.call_raw(pl)
'<soap-env:Envelope xmlns:echo="urn:echo" xmlns:soap-enc="http://schemas.xmlsoap.org/soap
/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://
www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap-en
v:Body><echo:echoResponse><echo:hear>[ Hello, World! ]</echo:hear></echo:echoResponse></s
oap-env:Body></soap-env:Envelope>'
\end{verbatim}
    \end{example}
  }
\end{itemize}
\end{flushleft}

\subsection{arcom.logger}
\label{alogger}
Module ''arcom.logger'' provides simple access to the logging capability of ARC.
\begin{flushleft}
\begin{itemize}
  \item{ \verb$log_levels$\newline
  There are six log levels at the moment:
    \begin{itemize}
      \item{arc.DEBUG}
      \item{arc.VERBOSE}
      \item{arc.INFO}
      \item{arc.WARNING}
      \item{arc.ERROR}
      \item{arc.FATAL}
    \end{itemize}
  }
\end{itemize}
\begin{itemize}
  \item{ \verb$get_logger(system = '<UNKNOWN>')$\newline
  Creates a logger - with root logger as a parent - on a given subdomain (system). 
  If no such is given, it will be ''\verb$<UNKNOWN>$'' by default.
    \begin{example}
      \caption{Using the Logger}\label{loggerex}
\begin{verbatim}
>>> import arc
>>> import arcom
>>> import sys
>>> # Import get_logger function
... from arcom.logger import get_logger
>>> # Create logger
... rl = get_logger()
>>> rl.logger
<arc.Logger; proxy of <Swig Object of type 'Arc::Logger *' at 0x9ef3f60> >
>>> arclogger = rl.logger
>>> # Add new destination
... arclogger.addDestination(arc.LogStream(sys.stdout))
>>> # Log a message
... # Note that the message is also returned as an output
... rl.msg(arc.INFO, 'Hello, World!')
[2009-06-04 11:00:42] [Arc.<UNKNOWN>] [INFO] [13120/148748400] Hello, World!
'Hello, World!'
\end{verbatim}
    \end{example}
  }
\end{itemize}
\end{flushleft}

\subsection{arcom.security}
\label{asecurity}
Module ''arcom.security'' provides tools for managing simple authorisation policies and requests.
This includes policy format conversion (between storage and ARC policy), utility functions 
for accessing the decision making mechanism and retrieving credential information.
\begin{flushleft}

\begin{itemize}
  \item{ \verb$class AuthRequest$\newline
  Represents simple authorisation request.
  Conversion is limited to ARCAuth format at the moment.
  \begin{itemize}
    \item{ \verb$__init__ - construction of AuthRequest$\newline
      AuthRequest is created from the incoming message.
      Before the message reaches a service it is passed through several message chain components.
      (See ARC HED documentation\footnote{\url{http://svn.nordugrid.org/trac/nordugrid/browser/arc1/trunk/doc/tech\_doc/hed/ARCHED\_article.pdf}} for details.)
      During this, information specific to the MCC is probably added to the message.
      Specifically, when it is passed through the TLS MCC, then security information is added.
      (See security documentation\footnote{\url{http://svn.nordugrid.org/trac/nordugrid/browser/arc1/trunk/doc/tech\_doc/sec/SecurityFrameworkofARC1.tex}} 
       for details about security design in ARC.)
      This information is then retrieved when AuthRequest is created.
      \begin{example}
        \caption{Identity part of subject retrieved when TLS is not used}\label{asubnotls}
\begin{verbatim}
     <ra:Subject xmlns:ra="http://www.nordugrid.org/schemas/request-arc">
       ...
       <ra:SubjectAttribute 
         AttributeId="http://www.nordugrid.org/schemas/policy-arc/types/tls/identity" 
         Type="string">ANONYMOUS</ra:SubjectAttribute>
     </ra:Subject>
\end{verbatim}
        When TLS MCC is not included in the message chain, identity retrieval will fail,
        thus showing up with an anonymous user.
      \end{example}
    }
  \end{itemize}
  \begin{itemize}
    \item{ \verb$get_request(self, action, format = 'ARCAuth')$\newline
      Returns a request in a XML string for the given action. This action should be one of the storage actions. 
      These are 'read', 'addEntry', 'removeEntry', 'delete', 'modifyPolicy', 'modifyStates' and 'modifyMetadata'.
      Format should be ARCAuth at the moment, as other formats are not supported yet.
    }
  \end{itemize}
  \begin{itemize}
    \item{ \verb$get_identity(self)$\newline
      Returns identity information.
    }
  \end{itemize}
  \begin{itemize}
    \item{ \verb$get_identity_and_ca(self)$\newline
      Returns identity and CA information.
    }
  \end{itemize}
  }
\end{itemize}

\begin{itemize}
  \item{ \verb$class AuthPolicy$\newline
  Class to set / retrieve / convert simple policies.
    \begin{example}
      \caption{Creating policy}\label{policyex}
\begin{verbatim}
>>> from arcom.security import AuthPolicy
>>> # create policy object
... p = AuthPolicy()
>>> # set policy for Alice and Bob
... # Alice is allowed to read and add entries (addEntry)
... # Bob is only allowed to read
... AlicePol = ('Alice','+read +addEntry')
>>> BobPol = ('Bob','+read')
>>> p.set_policy([AlicePol,BobPol])
>>> # see Policy document
... print p.get_policy('ARCAuth')
<Policy xmlns="http://www.nordugrid.org/schemas/policy-arc" 
        CombiningAlg="Deny-Overrides">
  <Rule Effect="Permit">
    <Description>Alice is allowed to read, addEntry</Description>
    <Subjects>
      <Subject>
        <Attribute AttributeId="http://www.nordugrid.org/schemas/policy-arc/
types/tls/identity" Type="string">Alice</Attribute>
      </Subject>
    </Subjects>
    <Actions>
      <Action AttributeId="http://www.nordugrid.org/schemas/policy-arc/
types/storage/action" Type="string">read</Action>
      <Action AttributeId="http://www.nordugrid.org/schemas/policy-arc/
types/storage/action" Type="string">addEntry</Action>
    </Actions>
  </Rule>
  <Rule Effect="Permit">
    <Description>Bob is allowed to read</Description>
    <Subjects>
      <Subject>
        <Attribute AttributeId="http://www.nordugrid.org/schemas/policy-arc/
types/tls/identity" Type="string">Bob</Attribute>
      </Subject>
    </Subjects>
    <Actions>
      <Action AttributeId="http://www.nordugrid.org/schemas/policy-arc/
types/storage/action" Type="string">read</Action>
    </Actions>
  </Rule>
</Policy>
\end{verbatim}
    \end{example}
  }
\end{itemize}

\begin{itemize}
  \item{ \verb$make_decision(policy, request)$\newline
  Method for accessing decision making functionality of ARC.
  ARC Evaluator is used to make decision about the request
  according to supplied policy.
    \begin{example}
      \caption{Decision making}\label{decisionex}
\begin{verbatim}

... 
>>> dsa = DummySecAttr('Alice')
>>> # set 'thisown' to False to avoid problems
... dsa.thisown = False
>>> 
>>> # export XML in ARCAuth format
... ex = dsa.Export()
>>> 
>>> from arcom.security import AuthPolicy
>>> # create policy object
... p = AuthPolicy()
>>> # set policy for Alice
... # Alice is allowed to read and add entries (addEntry)
... AlicePol = ('Alice','+read +addEntry')
>>> p.set_policy([AlicePol])
>>> 
>>> from arcom.security import make_decision
>>> 
>>> # get policy XML
... px = p.get_policy()
>>> rx = ex.GetXML()
>>> 
>>> decision = make_decision(px, rx)
>>> 
>>> # Possible results:
... # arc.DECISION_PERMIT -- 0
... # arc.DECISION_DENY -- 1
... # arc.DECISION_INDETERMINATE -- 2
... # arc.DECISION_NOT_APPLICABLE -- 3
... 
>>> decision
0
\end{verbatim}
      In this example, Alice requests read for a temporary file.
      This request is made via DummySecAttr, when Export is called.
      (Details about DummySecAttr can be found in Appendix \ref{DummySecAttrCode} of this document.)
    \end{example}
  }
\end{itemize}

\begin{itemize}
  \item{ \verb$parse_ssl_config(cfg)$\newline
  Method for processing an XML node and retrieve SSL configuration information.
  First it looks for a ClientSSLConfig child of the supplied node, 
  then it either collects information from a file given in FromFile attribute
  or from other children of ClientSSLConfig, namely KeyPath, CertificatePath 
  and CACertificatesDir.\newline
  So if our ARC config looked like
\begin{verbatim}
<?xml version="1.0"?>
<ArcConfig 
  xmlns="http://www.nordugrid.org/schemas/ArcConfig/2007"
  xmlns:tcp="http://www.nordugrid.org/schemas/ArcMCCTCP/2007"
>
    ...
    <Chain>
        ...
        <Service name="pythonservice" id="bartender">
            <ClassName>storage.bartender.bartender.BartenderService</ClassName>
            <LibrarianURL>https://localhost:60000/Librarian</LibrarianURL>
            <ClientSSLConfig FromFile="/etc/arc/clientsslconfig.xml" />
        </Service>
        ...
    </Chain>
</ArcConfig>
\end{verbatim}
  and ''/etc/arc/clientsslconfig.xml'' contained the following lines:
\begin{verbatim}
<?xml version="1.0"?>
<ClientSSLConfig>
    <KeyPath>/etc/grid-security/hostkey.pem</KeyPath>
    <CertificatePath>/etc/grid-security/hostcert.pem</CertificatePath>
    <CACertificatesDir>/etc/grid-security/certificates</CACertificatesDir>
</ClientSSLConfig>
\end{verbatim}
  then parsing would produce results like in the example below.
    \begin{example}
      \caption{SSL config example}\label{sslconfex}
\begin{verbatim}
>>> import arc
>>> import arcom
>>> from arcom.security import parse_ssl_config
>>> 
>>> xml_str = file('/etc/arc/ssl_config_example.xml').read()
>>> configNode = arc.XMLNode(xml_str)
>>> 
>>> serviceNode = configNode.Get('Chain').Get('Service')
>>> 
>>> print parse_ssl_config(serviceNode)
{'key_file': '/etc/grid-security/hostkey.pem', 
 'cert_file': '/etc/grid-security/hostcert.pem', 
 'ca_file': '/etc/grid-security/certificates'}
\end{verbatim}
    \end{example}
  }
\end{itemize}

\end{flushleft}

\subsection{arcom.service}
\label{aservice}
Module ''arcom.service'' provides the Service class and other tools for
service development. The Service class deals with Trust Manager
and SSL configuration and has the process method to get requests from 
incoming messages and create outgoing ones from the results.
This class should be extended when creating a new service.
Note that security related parts will not be discussed here; for those please see 
the security documentation\footnote{\url{http://svn.nordugrid.org/trac/nordugrid/browser/arc1/trunk/doc/tech\_doc/sec/SecurityFrameworkofARC1.tex}} 
of ARC.
\begin{flushleft}

\begin{itemize}
  \item{ \verb$Service$ \linebreak
  Service class will be presented through an example, in which DummyService will provide
  access to the funcionality of the Dummy class. (Complete source code can be found in Appendix 
  \ref{DummyServiceCode} of this document.)\linebreak
  Note that a small change in AuthRequest class (found in ''security.py'') is required for 
  this example to work because the incoming message in our example could not be processed
  in a way like on the server side. Therefore it is assumed that the \verb$__init__$ method
  of AuthRequest has:
\begin{verbatim}
        auth = message.Auth()
        import arc
        try:
            xml = auth.Export(arc.SecAttr.ARCAuth)
            subject = xml.Get('RequestItem').Get('Subject')
        except:
            subject = arc.XMLNode(arc.NS({'ra':request_ns}), 'ra:Subject')
\end{verbatim}
  instead of \linebreak
\begin{verbatim}
        auth = message.Auth()
        import arc
        xml = auth.Export(arc.SecAttr.ARCAuth)
        subject = xml.Get('RequestItem').Get('Subject')
\end{verbatim}
  so an empty Subject is available if auth is not present.
    \begin{example}
      \caption{Using DummyService - an example service based on arcom.service.Service}\label{srvex}
\begin{verbatim}
>>> # Reminder:
... # import arc
... #
... # class Dummy:
... #   def foo(self, foomsg = ''):
... #     return ''.join(['Foo message is: ',str(foomsg)])
... # 
... # from arcom.service import Service
... # 
... # class DummyService(Service):
... #   """ DummyService class based on Service class in arcom.service """
... #   ...
... 
>>> # Create instance of DummyService
... ds = DummyService(None)
>>> # Create namespace - it will be used for the message sent
... ns = arc.NS({'dmmy':'urn:foo'})
>>> # Create SOAP Envelope
... se = arc.SOAPEnvelope(ns)
>>> # Create content
... se.NewChild('dmmy:foo').Set('Foo!')
>>> # Create SOAP Message
... msg = arc.SOAPMessage()
>>> # Payload
... pls = arc.PayloadSOAP(se)
>>> # Set Message Payload
... msg.Payload(pls)
>>> # create outgoing message that will hold response
... outse = arc.SOAPEnvelope(ns)
>>> outmsg = arc.SOAPMessage()
>>> outpls = arc.PayloadSOAP(outse)
>>> outmsg.Payload(pls)
>>> # call service
... ds.process(msg, outmsg)
<arc.MCC_Status; proxy of <Swig Object of type 'Arc::MCC_Status *' at 0x8a39078> >
>>> # show result
... print outmsg.Payload().GetXML()
<soap-env:Envelope xmlns:dmmy="urn:foo" xmlns:soap-enc="http://schemas.xmlsoap.o
rg/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xm
lns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XML
Schema-instance"><soap-env:Body><dmmy:fooResponse>Foo message is: Foo!</dmmy:foo
Response></soap-env:Body></soap-env:Envelope>
\end{verbatim}
    \end{example}
  }
\end{itemize}

\begin{itemize}
  \item{ \verb$parse_node(node, names, single = False, string = True)$ \linebreak
  Calls \verb$node_to_data()$ for each child of the given node.
  \begin{itemize}
    \item{\verb$node$ is the XMLNode whose children we want to convert}
    \item{\verb$names$ is a list of tag names which will be returned in the specified order}
    \item{\verb$single$ indicates whether only one value is needed beside the key; if so, do not put it into a list}
    \item{\verb$string$ indicates whether string contents of nodes are needed - not the nodes themselves}
  \end{itemize}
    \begin{example}
      \caption{parse\_node}\label{pnex}
\begin{verbatim}
>>> from arc import XMLNode
>>> from arcom.service import parse_node
>>> 
>>> # create xml node
... xml = XMLNode('''
... <myList>
...   <myElement>
...     <myID>0</myID>
...     <LN>/</LN>
...   </myElement>
...   <myElement>
...     <myID>1</myID>
...     <LN>/testfile</LN>
...   </myElement>
... </myList>''')
>>> 
>>> # default: single = False and string = True
... parse_node(xml, ['myID','LN'])
{'1': ['/testfile'], '0': ['/']}
>>> # single = True
... parse_node(xml, ['myID','LN'], single = True)
{'1': '/testfile', '0': '/'}
>>> parse_node(xml, ['myID','LN'], True)
{'1': '/testfile', '0': '/'}
>>> # string = False
... parse_node(xml, ['myID','LN'], string = False)
{<arc.XMLNode; proxy of <Swig Object of type 'Arc::XMLNode *' at 0x996f040> >: [
<arc.XMLNode; proxy of <Swig Object of type 'Arc::XMLNode *' at 0x996f050> >], <
arc.XMLNode; proxy of <Swig Object of type 'Arc::XMLNode *' at 0x9997590> >: [<a
rc.XMLNode; proxy of <Swig Object of type 'Arc::XMLNode *' at 0x99975a0> >]}
\end{verbatim}
    \end{example}
  }
\end{itemize}

\begin{itemize}
  \item{ \verb$parse_to_dict(node, names)$ \linebreak
  Converts the children of the node to a dictionary of dictionaries.
  \begin{itemize}
    \item{\verb$node$ is the XMLNode whose children we want to convert}
    \item{\verb$names$ is a list of tag names; for each child only these names will be included in the dictionary}
  \end{itemize}
  Note that the first element of ''names'' is considered as sthe child whose value will serve as the key of dictionary.
  Other elements are put in an inner dictionary with their names being the key and their content being the value for that key.
    \begin{example}
      \caption{parse\_to\_dict}\label{p2dex}
\begin{verbatim}
>>> from arc import XMLNode
>>> from arcom.service import parse_to_dict
>>> 
>>> # create xml node
... xml = XMLNode('''
... <myList>
...   <myElement>
...     <myID>123</myID>
...     <refID>abc</refID>
...     <state>alive</state>
...     <size>123456</size>
...   </myElement>
...   <myElement>
...     <myID>456</myID>
...     <refID>fed</refID>
...     <state>alive</state>
...     <size>987</size>
...   </myElement>
... </myList>''')
>>> 
>>> # example 1 - 'myID' as key
... # 'state' and 'size' goes to the inner dictionary
... parse_to_dict(xml, ['myID','state','size'])
{'123': {'state': 'alive', 'size': '123456'}, '456': {'state': 'alive', 'size': 
'987'}}
>>> 
>>> # example 2 - 'myID' as key
... # 'myID' also goes to the inner dictionary
... parse_to_dict(xml, ['myID','myID','state','size'])
{'123': {'myID': '123', 'state': 'alive', 'size': '123456'}, '456': {'myID': '45
6', 'state': 'alive', 'size': '987'}}
\end{verbatim}
    \end{example}
  }
\end{itemize}

\begin{itemize}
  \item{ \verb$create_response(method_name, tag_names, elements, payload, single = False)$ \linebreak
  Creates a SOAP XML payload from a dictionary of tag names and list of values.
  \begin{itemize}
    \item{\verb$method_name$ is the name of the method which will be used as a prefix in the name of the ''Response'' tag}
    \item{\verb$tag_names$ is a list of names which will be used in the specified order as tag names}
    \item{\verb$elements$ is a dictionary where the key will be tagged as the first tag name 
and the value is a list whose items will be tagged in the order of the \verb$tag_names$ list}
    \item{\verb$payload$ is an XMLNode that the response will be added to}
    \item{\verb$single$ indicates whether there is only one value per key}
  \end{itemize}  
    \begin{example}
      \caption{create\_response}\label{crespex}
\begin{verbatim}
>>> import arc
>>> from arcom.service import create_response
>>> 
>>> method_name = 'dummy'
>>> # create tag_names; 'myID' will be the key
... tag_names = ['myID', 'state', 'size']
>>> # create elements
... # elements of the lists in this dictionary are values and will be tagged 
... # according to names found in tag_names except for the first element
... # e.g.: 'alive' will be tagged with 'state'
... elements = {'123': ['alive', '123456'], '456': ['alive', '987']}
>>> # create empty payload
... payload = arc.PayloadSOAP(arc.NS())
>>> 
>>> # create response
... response = create_response(method_name, tag_names, elements, payload)
>>> 
>>> # show it
... print response.GetXML(True)
<soap-env:Envelope xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xm
lns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w
3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <dummyResponse>
      <dummyResponseList>
        <dummyResponseElement>
          <myID>123</myID>
          <state>alive</state>
          <size>123456</size>
        </dummyResponseElement>
        <dummyResponseElement>
          <myID>456</myID>
          <state>alive</state>
          <size>987</size>
        </dummyResponseElement>
      </dummyResponseList>
    </dummyResponse>
  </soap-env:Body>
</soap-env:Envelope>
\end{verbatim}
    \end{example}
  }
\end{itemize}

\begin{itemize}
  \item{ \verb$node_to_data(node, names, single = False, string = True)$ \linebreak
  Get some children of an XMLNode and return them in a list in the specified order using the first one as a key.
  \begin{itemize}
    \item{\verb$node$ is an XMLNode that has some children}
    \item{\verb$names$ is a list of the names of those children we want to extract; first string in this list will always be the key}
    \item{\verb$single$ indicates whether only one value is needed; if so, do not put it into a list}
    \item{\verb$string$ indicates whether string contents of nodes are needed - not the nodes themselves}
  \end{itemize}  
    \begin{example}
      \caption{node\_to\_data - 1}\label{n2dex1}
\begin{verbatim}
>>> from arc import XMLNode
>>> from arcom.service import node_to_data
>>> 
>>> # create node
... xml = XMLNode('''
... <myElement>
...   <myID>0</myID>
...   <refID>abc</refID>
...   <section>states</section>
...   <property>spares</property>
...   <value>2</value>
...   <dummy>foo</dummy>
...   <changeType>set</changeType>
... </myElement>
... ''')
>>> 
>>> # create names
... # 'myID' will be the key
... # all the other names will be in a list in the specified order
... # 'dummy' will be left out
... names = ['myID', 'refID', 'changeType', 'section', 'property', 'value']
>>> 
>>> # call node_to_data
... node_to_data(xml,names)
('0', ['abc', 'set', 'states', 'spares', '2'])
\end{verbatim}
    \end{example}
    \begin{example}
      \caption{node\_to\_data - 2}\label{n2dex2}
\begin{verbatim}
>>> from arc import XMLNode
>>> from arcom.service import node_to_data
>>> 
>>> # create node
... xml = XMLNode('''
... <getRequest>
...   <GUID>11</GUID>
...   <myID>99</myID>
... </getRequest>
... ''')
>>> 
>>> # create names
... # 'myID' will be the key
... names = ['myID', 'GUID']
>>> 
>>> # call node_to_data
... # GUID is the single value so do not put it in a list
... node_to_data(xml,names, True)
('99', '11')
\end{verbatim}
    \end{example}
  }
\end{itemize}

\begin{itemize}
  \item{ \verb$get_data_node(node)$ \linebreak
  Gets the data node from the \verb$Body$ of a SOAP message where the first child node 
  of the \verb$Body$ refers to the method being called. E.g.:
\begin{verbatim}
Request:
        <soap-env:Envelope>
          <soap-env:Body>
            <method>
              <data>Value</data>
            </method>
          </soap-env:Body>
        </soap-env:Envelope>

Data node:
          <data>Value</data>
\end{verbatim}
    \begin{example}
      \caption{get\_data\_node}\label{gdnex}
\begin{verbatim}
>>> from arc import XMLNode
>>> from arcom.service import get_data_node
>>> 
>>> # create node
... xml = XMLNode('''
... <Envelope>
...   <Body>
...     <method>
...       <data>Value</data>
...     </method>
...   </Body>
... </Envelope>
... ''')
>>> 
>>> # call get_data_node
... dn = get_data_node(xml)
>>> 
>>> # show result
... dn.GetXML()
'<data>Value</data>'
\end{verbatim}
    \end{example}
  }
\end{itemize}

\end{flushleft}

\subsection{arcom.threadpool}
\label{athreadpool}
Module ''arcom.threadpool'' provides simple thread pool support.
Consists of classes ThreadPool, ThreadPoolThread and ReadWriteLock.
ThreadPool could be used to create a pool of threads, then it accepts 
tasks that will be dispatched to the next available thread.
ThreadPoolThread could be used to retrieve a task and execute it.
ReadWriteLock is a lock object that allows many simultaneous ''read locks'', 
but only one ''write lock.''

\begin{flushleft}

\begin{itemize}
  \item{ \verb$class ThreadPool$ \linebreak
  ThreadPool is a flexible thread pool class. It creates a pool of threads, 
  then accepts tasks that will be dispatched to the next available thread.
  }
  \begin{itemize}
    \item{ \verb$setThreadCount(self, newNumThreads)$ \linebreak
    Sets the current pool size.  It does so by acquiring the resizing lock, 
    then calling the private version of this method to grow or shrink the pool.
    }
  \end{itemize}

  \begin{itemize}
    \item{ \verb$getThreadCount(self)$ \linebreak
    Returns the number of threads in the pool.
    }
  \end{itemize}

  \begin{itemize}
    \item{ \verb$queueTask(self, task, args=None, taskCallback=None)$ \linebreak
    Inserts a task into the queue. Task must be callable; 
    args and taskCallback may be None.
    }
  \end{itemize}

  \begin{itemize}
    \item{ \verb$getNextTask(self)$ \linebreak
    Retrieves the next task from the task queue.  For use only by ThreadPoolThread 
    objects contained in the pool.
    }
  \end{itemize}

  \begin{itemize}
    \item{ \verb$joinAll(self, waitForTasks = True, waitForThreads = True)$ \linebreak
    Clears the task queue and terminates all pooled threads,
    optionally allowing the tasks and threads to finish.
    }
  \end{itemize}

\end{itemize}

\begin{itemize}
  \item{ \verb$class ThreadPoolThread(threading.Thread)$ \linebreak
  ThreadPoolThread is a pooled thread class.
  }
  \begin{itemize}
    \item{ \verb$run(self)$ \linebreak
    Until told to quit, retrieve the next task and execute it, calling the callback if any.
    }
  \end{itemize}

  \begin{itemize}
    \item{ \verb$goAway(self)$ \linebreak
    Exit the run loop next time through.
    }
  \end{itemize}

\end{itemize}

\begin{itemize}
  \item{ \verb$class ReadWriteLock$ \linebreak
  ReadWriteLock is a lock object that allows many simultaneous ''read locks'', 
  but only one ''write lock''.
  }
  \begin{itemize}
    \item{ \verb$acquire_read(self)$ \linebreak
    Acquires a read lock. Blocks only if a thread has acquired the write lock.
    }
  \end{itemize}

  \begin{itemize}
    \item{ \verb$release_read(self)$ \linebreak
    Releases a read lock.
    }
  \end{itemize}

  \begin{itemize}
    \item{ \verb$acquire_write(self)$ \linebreak
    Acquires a write lock. Blocks until there are no acquired read or write locks.
    }
  \end{itemize}

  \begin{itemize}
    \item{ \verb$release_write(self)$ \linebreak
    Releases a write lock.
    }
  \end{itemize}

\end{itemize}

  Two examples are pressented below. In the first one, four waitTasks with different 
  wait times are queued while there are three threads. In the second one, a counter
  is incremented by four addTasks on four threads. (Here a ReadWriteLock is used to
  make sure that only one thread has write access to the counter at a time.)
  (Complete source code can be found in Appendix \ref{ThreadPoolTestCode} of this document.)
  \begin{example}
    \caption{arcom.threadpool}\label{arctpex}
\begin{verbatim}
$./threadpooltest.py 

Example1 - waitTask
(1): WaitTask starting
WaitTask sleeping for 4 seconds
(2): WaitTask starting
WaitTask sleeping for 1 seconds
(3): WaitTask starting
WaitTask sleeping for 6 seconds
Callback called for Waiter (2)
(4): WaitTask starting
WaitTask sleeping for 2 seconds
Callback called for Waiter (4)
Callback called for Waiter (1)
Callback called for Waiter (3)

Example2 - addTask
COUNTER before join:  0
(5): Added 10 to counter, counter is now 10
(6): Added 10 to counter, counter is now 20
(7): Added 10 to counter, counter is now 30
(8): Added 10 to counter, counter is now 40
(6): Added 10 to counter, counter is now 50
(5): Added 10 to counter, counter is now 60
(7): Added 10 to counter, counter is now 70
(8): Added 10 to counter, counter is now 80
(5): Added 10 to counter, counter is now 90
(7): Added 10 to counter, counter is now 100
(6): Added 10 to counter, counter is now 110
(8): Added 10 to counter, counter is now 120
Callback called for ('addTask', 10)
Callback called for ('addTask', 10)
Callback called for ('addTask', 10)
Callback called for ('addTask', 10)
COUNTER after join:  120
\end{verbatim}
  \end{example}

\end{flushleft}

\subsection{arcom.XMLTree}
\label{axtree}
Module ''arcom.XMLTree'' provides the XMLTree class to convert from XML to native Python structures and vice versa.
Furthermore, it provides utility functions and some basic query methods for XMLTree structures.
\begin{flushleft}

\begin{itemize}
  \item{ \verb$class XMLTree$ \linebreak
    With the help of the XMLTree class XML can be converted to native Python structures and vice versa.
    It also provides some useful functions to handle these structures.
    \begin{itemize}
      \item{\begin{verbatim}
XMLTree(from_node = None, from_string = '', from_tree = None, rewrite = {}, 
        forget_namespace = False) \end{verbatim}
        \begin{itemize}
          \item{\verb$from_node$ is an XMLNode that could be converted to XMLTree}
          \item{\verb$from_string$ is a string representation of an XMLNode that could be converted to XMLTree}
          \item{\verb$from_tree$ is a tree structure or an XMLTree object that could be converted to XMLTree}
          \item{\verb$rewrite$ is a dictionary; if an XML node has a name which is a key 
                in this dictionary then it will be renamed as the value of that key; note though, 
                when \verb$from_tree$ is used, this parameter is ignored}
          \item{\verb$forget_namespace$ tells whether the XMLTree should not contain the namespace prefixes; 
                note though, when \verb$from_tree$ is used, this parameter is ignored}
        \end{itemize}
        The parameter \verb$from_tree$ has the highest priority; if it is not None, then \verb$from_string$ and 
        \verb$from_node$ are ignored. If \verb$from_tree$ is None but \verb$from_node$ is given, 
        then \verb$from_string$ is ignored. If only \verb$from_string$ is given, then it will be the choosen one.
      }
    \end{itemize}
    Some examples of creating an XMLTree are shown below.
    \begin{example}
      \caption{Creating an XMLTree}\label{crxt}
\begin{verbatim}
>>> from arc import XMLNode
>>> from arcom.xmltree import XMLTree
>>> 
>>> # create XMLTree sources
... # xmlstr - will be used to create an XMLTree from string
... # xmlnodestr - will be used to create 'node' (an XMLNode)
... # node - will be used to create an XMLTree from XMLNode
... # treestruct - for creating XMLTree from tree structure
... xmlstr = '<echo><say>Hello!</say></echo>'
>>> xmlnodestr = '<node><subnode>Subnode</subnode></node>'
>>> node = XMLNode(xmlnodestr)
>>> treestruct = ('root', [('leaf','Leaf')])
>>> 
>>> # from_tree has the highest priority
... t1 = XMLTree(from_node = node, from_string = xmlstr, from_tree = treestruct) 
>>> t1.get()
[('root', [('leaf', 'Leaf')])]
>>> 
>>> # no from_tree supplied; from_node will be used
... t2 = XMLTree(from_node = node, from_string = xmlstr)
>>> t2.get()
[('node', [('subnode', 'Subnode')])]
>>> 
>>> # from_string only
... t3 = XMLTree(from_string = xmlstr)
>>> t3.get()
[('echo', [('say', 'Hello!')])]
\end{verbatim}
    \end{example}
    \begin{example}
      \caption{XMLTree - forget namespace}\label{xtfn}
\begin{verbatim}
>>> from arc import XMLNode
>>> from arcom.xmltree import XMLTree
>>> 
>>> # Create XMLTree objects to demonstrate
... # the use of forget namespace feature
... # node - is an XMLNode
... # tree - is an XMLTree that is created from 'node'
... node = XMLNode('<soap-env:Envelope xmlns:hash="urn:hash" \
... xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" \
... xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" \
... xmlns:xsd="http://www.w3.org/2001/XMLSchema" \
... xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\
... <soap-env:Body>\
... <hash:get>\
... <hash:IDs>\
... <hash:ID>0</hash:ID>\
... <hash:ID>1</hash:ID>\
... <hash:ID>2</hash:ID>\
... </hash:IDs>\
... </hash:get>\
... </soap-env:Body>\
... </soap-env:Envelope>')
>>> 
>>> tree = XMLTree(node)
>>> # show tree structure
... print tree
('soap-env:Envelope', [('soap-env:Body', [('hash:get', [('hash:IDs', [('hash:ID
', '0'), ('hash:ID', '1'), ('hash:ID', '2')])])])])
>>> 
>>> # forget_namespace is ignored when from_tree is used
... tree2 = XMLTree(from_tree = tree, forget_namespace = True)
... print tree2
('soap-env:Envelope', [('soap-env:Body', [('hash:get', [('hash:IDs', [('hash:ID
', '0'), ('hash:ID', '1'), ('hash:ID', '2')])])])])
>>> 
>>> # forget_namespace with from_node
... tree3 = XMLTree(from_node = node, forget_namespace = True)
>>> # it works as expected
... print tree3
('Envelope', [('Body', [('get', [('IDs', [('ID', '0'), ('ID', '1'), ('ID', '2')
])])])])
>>> 
>>> # forget_namespace with from_string
... strnode = '<myns:foo xmlns:myns="urn:foo"><myns:dummy>Hello, World!</myns:dummy>\
... </myns:foo>'
>>> tree4 = XMLTree(from_string = strnode, forget_namespace = True)
>>> # it also works
... print tree4
('foo', [('dummy', 'Hello, World!')])
\end{verbatim}
    \end{example}
    Some examples of creating an XMLTree with the rewrite feature are shown below.
    \begin{example}
      \caption{XMLTree - rewrite}\label{xtrew}
\begin{verbatim}
>>> from arc import XMLNode
>>> from arcom.xmltree import XMLTree
>>> 
>>> # Create XMLTree objects to demonstrate
... # the use of rewrite feature
>>> strnode = '<myns:foo xmlns:myns="urn:foo"><myns:dummy>Hello, World!</myns:dummy>\
... </myns:foo>'
>>> tree = XMLTree(from_string = strnode,\
...                rewrite = {'myns:foo':'myns:boo'},\
...                forget_namespace = False)
>>> 
>>> # 'myns:foo' is turned into 'myns:boo'
... print tree
('myns:boo', [('myns:dummy', 'Hello, World!')])
>>> 
>>> # combine with forget_namespace
... tree2 = XMLTree(from_string = strnode,\
...                 rewrite = {'foo':'boo'},\
...                 forget_namespace = True)
>>> # 'forget_namespace' is True so namespace prefix 'myns' is being stripped off
... # ('myns:foo' -> 'foo'; 'myns:dummy' -> 'dummy')
... # then 'foo' is turned into 'boo' 
... print tree2
('boo', [('dummy', 'Hello, World!')])
\end{verbatim}
    \end{example}

    \begin{itemize}
      \item{ \verb$add_to_node(self, node, path = None)$ \linebreak
      Adds a tree structure to an XMLNode. Structure is added as a child of the target XMLNode.
        \begin{itemize}
          \item{\verb$node$ is the target XMLNode}
          \item{\verb$path$ selects the part of the XMLTree to be added}
        \end{itemize}
      }
    \end{itemize}

    \begin{example}
      \caption{XMLTree - add\_to\_node}\label{xtadd2n}
\begin{verbatim}
>>> from arc import XMLNode
>>> from arcom.xmltree import XMLTree
>>> 
>>> node = XMLNode('<node/>')
>>> 
>>> # create XMLTree
... tree = XMLTree(from_string = '<root><dummy/><hello>World</hello></root>')
>>> 
>>> # from 'tree' add 'dummy' to 'node'
... tree.add_to_node(node, '/root/dummy')
>>> 
>>> # show result
... print node.GetXML(True)
<node>
  <dummy></dummy>
</node>
>>> 
>>> # from 'tree' add 'hello' to 'dummy' in 'node'
... dummy = node.Get('dummy')
>>> tree.add_to_node(dummy, '/root/hello')
>>> 
>>> # show result
... print node.GetXML(True)
<node>
  <dummy><hello>World</hello></dummy>
</node>
\end{verbatim}
    \end{example}

    \begin{itemize}
      \item{ \verb$pretty_xml(self, indent = ' ', path = None, prefix = '')$ \linebreak
      Returns a nicely formatted XML representation of the structure.
        \begin{itemize}
          \item{\verb$indent$ is a string that child nodes are indented with}
          \item{\verb$path$ selects the part of the XMLTree to be shown. Full structure is shown when \verb$path$ is None.}
          \item{\verb$prefix$ is a string that is put to the beginning of each line}
        \end{itemize}
      }
    \end{itemize}

    \begin{example}
      \caption{XMLTree - pretty\_xml}\label{xtpretty}
\begin{verbatim}
>>> from arcom.xmltree import XMLTree
>>> 
>>> # create XMLTree
... tree = XMLTree(from_string = '<root><Hello>World</Hello></root>')
>>> 
>>> # select entire tree
... # indent children with space character
... # apply prefix for every new line
... print tree.pretty_xml(indent=' ', path='', prefix='# ')
# <root>
#  <Hello>World</Hello>
# </root>
>>> 
>>> # note that it is possible to select multiple parts
... # create an example XMLTree to demonstrate that
... tree2 = XMLTree(from_string = '<root><sub><Hello>World</Hello></sub>\
... <sub><dummy>foo</dummy></sub></root>')
>>> 
>>> # show '/root/sub'
... print tree2.pretty_xml(indent=' ', path='/root/sub', prefix='# ')
# <sub>
#  <Hello>World</Hello>
# </sub>
# <sub>
#  <dummy>foo</dummy>
# </sub>
\end{verbatim}
    \end{example}

    \begin{itemize}
      \item{ \verb$__str__(self)$ \linebreak
      Returns string representation of the structure. Each node is represented by a dictionary where the name
      of the node serves as the key and the value for this key is a list of child nodes of that node.
      }
    \end{itemize}

    \begin{example}
      \caption{XMLTree - \_\_str\_\_}\label{xtstr}
\begin{verbatim}
>>> from arcom.xmltree import XMLTree
>>> 
>>> # create XMLTree
... tree = XMLTree(from_string = '<root><dummy>foo</dummy></root>')
>>> 
>>> # show tree
... # print will result in __str__ being called
... # when trying to convert XMLTree to string
... print tree
('root', [('dummy', 'foo')])
\end{verbatim}
    \end{example}

    \begin{itemize}
      \item{ \verb$get(self, path = None)$ \linebreak
      Returns the parts of the XMLTree that match \verb$path$.
      If \verb$path$ is not given, it defaults to the root node.
      This function always returns a list.
      }
    \end{itemize}

    \begin{example}
      \caption{XMLTree - get}\label{xtget}
\begin{verbatim}
>>> from arcom.xmltree import XMLTree
>>> 
>>> # create tree structure
... tree = \
... ('root',\
...   [('trunk',\
...     [('leaf','1'),\
...      ('leaf','2')]\
...   )]\
... )
>>> 
>>> # create XMLTree from tree structure
... xt = XMLTree(from_tree = tree)
>>> 
>>> # if called with path being None
... # get() selects the root node
... xt.get()
[('root', [('trunk', [('leaf', '1'), ('leaf', '2')])])]
>>> 
>>> # Path is just a plain path.
... # Empty tag name matches everything, so - in this particular case -
... # all expressions below will produce the same result.
... xt.get('/root/trunk/leaf')
[('leaf', '1'), ('leaf', '2')]
>>> xt.get('//trunk/leaf')
[('leaf', '1'), ('leaf', '2')]
>>> xt.get('/root//leaf')
[('leaf', '1'), ('leaf', '2')]
>>> xt.get('/root/trunk/')
[('leaf', '1'), ('leaf', '2')]
>>> xt.get('///leaf')
[('leaf', '1'), ('leaf', '2')]
>>> xt.get('///')
[('leaf', '1'), ('leaf', '2')]
\end{verbatim}
    \end{example}

    \begin{itemize}
      \item{ \verb$get_trees(self, path = None)$ \linebreak
      Returns XMLTree object for each subtree that match \verb$path$.
      This function always returns a list.
      }
    \end{itemize}

    \begin{example}
      \caption{XMLTree - get\_trees}\label{xtgettrees}
\begin{verbatim}
>>> from arcom.xmltree import XMLTree
>>> 
>>> # create tree structure
... tree = \
... ('trunk',\
...   [( 'branch',\
...      [('leaf','1'),\
...       ('leaf','2')]\
...    ),\
...    ( 'branch',\
...      [('leaf','3')]\
...    )]\
... )
>>> 
>>> # create XMLTree from tree structure
... xt = XMLTree(from_tree = tree)
>>> 
>>> # get branches ('/trunk/branch') in a list
... blist = xt.get_trees('/trunk/branch')
>>> 
>>> # show branches in blist
... for b in blist:
...     print b
... 
('branch', [('leaf', '1'), ('leaf', '2')])
('branch', [('leaf', '3')])
>>> # get leaves ('/trunk/branch/leaf') in a list
... llist = xt.get_trees('/trunk/branch/leaf')
>>> 
>>> # show leaves in llist
... for l in llist:
...     print l
... 
('leaf', '1')
('leaf', '2')
('leaf', '3')
\end{verbatim}
    \end{example}

    \begin{itemize}
      \item{ \verb$get_value(self, path = None, *args)$ \linebreak
      Returns the value of the selected part. This means that if node N is
      the first node matched by \verb$path$ then the value of N (i.e. the list of
      its child nodes or its content if it has no child) is returned. If there is no match, 
      and a default value is given, it will be returned instead.
      }
    \end{itemize}

    \begin{example}
      \caption{XMLTree - get\_value}\label{xtgetval}
\begin{verbatim}
>>> from arcom.xmltree import XMLTree
>>> 
>>> # create tree structure
... ts = ('branch',[('leaf','1')])
>>> 
>>> # create XMLTree from tree structure
... tree = XMLTree(from_tree = ts)
>>> 
>>> # get_value for '/branch/leaf'
... # will return the value from 'leaf'
... tree.get_value('/branch/leaf')
'1'
>>> 
>>> # get_value for '/branch'
... # will return the value from 'branch'
... # ie the list of its children
... tree.get_value('/branch')
[('leaf', '1')]
>>> 
>>> # get_value for a path that does not match
... # provide a default value of 'N/A'
... tree.get_value('/dummy','N/A')
'N/A'
\end{verbatim}
    \end{example}

    \begin{itemize}
      \item{ \verb$add_tree(self, tree, path = None)$ \linebreak
      Adds a new subtree to a path. This will actually add \verb$tree$ to the first node that matches \verb$path$.
      (Root node of \verb$tree$ will be a new child of the node matched by \verb$path$.)
      }
    \end{itemize}

    \begin{example}
      \caption{XMLTree - add\_tree}\label{xtaddtree}
\begin{verbatim}
>>> from arcom.xmltree import XMLTree
>>> 
>>> # create tree structure
... ts = \
... ('root',\
...   [ ('branch',\
...       [ ('leaf','1'),\
...         ('leaf','2')\
...       ]\
...     ),\
...     ('branch',\
...       [ ('leaf','3'),\
...         ('leaf','4')\
...       ]\
...     )\
...   ]\
... )
>>> 
>>> # create XMLTree from tree structure
... tree = XMLTree(from_tree = ts)
>>> 
>>> # add a new leaf ('leaf','5') to '/root/branch'
... # the new leaf will be added to the first node 
... # matched by path ('/root/branch') 
... tree.add_tree(('leaf','5'), '/root/branch')
>>> 
>>> # show tree
... print tree
('root', [('branch', [('leaf', '1'), ('leaf', '2'), ('leaf', '5')]), ('branch', 
[('leaf', '3'), ('leaf', '4')])])
\end{verbatim}
    \end{example}

    \begin{itemize}
      \item{ \verb$get_values(self, path = None)$ \linebreak
      Returns the value (i.e. the list of child nodes or the content if one has no child) 
      for all matched nodes selected by \verb$path$. This function always returns a list.
      Note that unlike \verb$get_value$ this one takes all matched nodes into account.
      Furthermore this one does not accept a default value to return.
      }
    \end{itemize}

    \begin{example}
      \caption{XMLTree - get\_values}\label{xtgetvals}
\begin{verbatim}
>>> from arcom.xmltree import XMLTree
>>> 
>>> # create tree structure
... ts = \
... ('root',\
...   [ ('branch',\
...       [ ('leaf','1'),\
...         ('leaf','2')\
...       ]\
...     ),\
...     ('branch',\
...       [ ('leaf','3'),\
...         ('leaf','4')\
...       ]\
...     )\
...   ]\
... )
>>> 
>>> # create XMLTree from tree structure
... tree = XMLTree(from_tree = ts)
>>> 
>>> # get values of branches ('/root/branch') in a list
... # this will return the lists of children of the branches
... tree.get_values('/root/branch')
[[('leaf', '1'), ('leaf', '2')], [('leaf', '3'), ('leaf', '4')]]
>>> 
>>> # get values of leaves ('/root/branch/leaf') in a list
... # this will return the values of leaves
... tree.get_values('/root/branch/leaf')
['1', '2', '3', '4']
>>> 
>>> # try a path that does not match
... # this will return an empty list
... tree.get_values('/dummy')
[]
\end{verbatim}
    \end{example}

    \begin{itemize}
      \item{ \verb$get_dict(self, path = None, keys = {})$ \linebreak
      This method is designed to restore a set of \verb$(key, value)$ pairs stored 
      in an XML structure. It returns a dictionary from the first node matched by \verb$path$.
      \verb$keys$ is a dictionary which filters and translates the keys
      (e.g. if \verb$keys$ is {'my:node':'node'}, it will only return
      'my:node', and will call it 'node'). The value for this key will be 
      the text content of that node or the list of its child nodes.
      (Note though that \verb$get_dict$ was designed with simple text content in mind.)
      }
    \end{itemize}

    \begin{example}
      \caption{XMLTree - get\_dict}\label{xtgetdict}
\begin{verbatim}
>>> from arcom.xmltree import XMLTree
>>> 
>>> # create tree structure
... ts =\
... ('person',\
...   [ ('name', 'Alice'),\
...     ('id', '11'),\
...     ('job', 'Librarian')\
...   ]
... )
>>> 
>>> # create XMLTree from tree structure
... tree = XMLTree(from_tree = ts)
>>> 
>>> # get dictionary from '/person'
... # only name and job is to be returned
... tree.get_dict('/person',{'name':'name','job':'job'})
{'job': 'Librarian', 'name': 'Alice'}
\end{verbatim}
    \end{example}

    \begin{itemize}
      \item{ \verb$get_dicts(self, path = None, keys = {})$ \linebreak
      This method is designed to restore multiple sets of \verb$(key, value)$ pairs stored 
      in an XML structure. It returns a list of dictionaries from nodes matched by \verb$path$.
      \verb$keys$ is a dictionary which filters and translates the keys
      (e.g. if \verb$keys$ is {'my:node':'node'}, it will only return
      'my:node', and will call it 'node'). The value for this key will be 
      the text content of that node or the list of its child nodes.
      (Note though that \verb$get_dict$ was designed with simple text content in mind.)
      }
    \end{itemize}

    \begin{example}
      \caption{XMLTree - get\_dicts}\label{xtgetdicts}
\begin{verbatim}
>>> from arcom.xmltree import XMLTree
>>> 
>>> # create tree structure
... ts =\
... ('persons',\
...   [ ('person',\
...       [ ('name', 'Alice'),\
...         ('id', '11'),\
...         ('job', 'Librarian')\
...       ]\
...     ),\
...     ('person',\
...       [ ('name', 'Bob'),\
...         ('id', '12'),\
...         ('job', 'Bartender')\
...       ]\
...     )\
...   ]\
... )
>>> 
>>> # create XMLTree from tree structure
... tree = XMLTree(from_tree = ts)
>>> 
>>> # get dictionaries for '/persons/person'
... tree.get_dicts('/persons/person')
[{'job': 'Librarian', 'name': 'Alice', 'id': '11'}, 
{'job': 'Bartender', 'name': 'Bob', 'id': '12'}]
\end{verbatim}
    \end{example}

  }
\end{itemize}

\end{flushleft}

\section*{Appendices}
\addcontentsline{toc}{section}{Appendices}
\appendix
\section{Helper classes for LogStream function}
\label{LogStreamHelperFullCode}
\begin{verbatim}
%inline %{ 
class CPyOutbuf : public std::streambuf 
{ 
public: 
     CPyOutbuf(PyObject* obj) { 
         m_PyObj = obj; 
         Py_INCREF(m_PyObj); 
     } 
     ~CPyOutbuf() { 
         Py_DECREF(m_PyObj); 
     } 
protected: 
     int_type overflow(int_type c) { 
         // Call to PyGILState_Ensure ensures there is Python 
         // thread state created/assigned.
         PyGILState_STATE gstate = PyGILState_Ensure();
         PyObject_CallMethod(m_PyObj, (char*) "write", (char*) "c", c); 
         PyGILState_Release(gstate);
         return c; 
     } 
     std::streamsize xsputn(const char* s, std::streamsize count) { 
         // Call to PyGILState_Ensure ensures there is Python 
         // thread state created/assigned.
         PyGILState_STATE gstate = PyGILState_Ensure();
         PyObject_CallMethod(m_PyObj, (char*) "write", (char*) "s#", s, int(count)); 
         PyGILState_Release(gstate);
         return count; 
     } 
     PyObject* m_PyObj; 
}; 

class CPyOstream : public std::ostream 
{ 
public: 
     CPyOstream(PyObject* obj) : m_Buf(obj), std::ostream(&m_Buf) {} 
private: 
     CPyOutbuf m_Buf; 
}; 

%}
\end{verbatim}

\section{Dummy SecAttr made for use with make\_decision}
\label{DummySecAttrCode}
\begin{verbatim}
import arc
from arc import SecAttr
import sys

class DummySecAttr (SecAttr):
  "Minimalistic implementation of SecAttr."
  def __init__(self, identity = 'Anonymous'):
    SecAttr.__init__(self)
    self.identity = identity
  def Export(self, format = SecAttr.ARCAuth):
    if format != SecAttr.ARCAuth:
      return None
    else:
      ns = arc.NS({'ra':'http://www.nordugrid.org/schemas/request-arc'})
      res = arc.XMLNode(ns, 'ra:Request')
      ritem = res.NewChild('ra:RequestItem')
      sub = ritem.NewChild('ra:Subject')
      subattr = sub.NewChild('ra:SubjectAttribute')
      subattr.Set(self.identity)
      subattr.NewAttribute('Type').Set('string')
      subattr.NewAttribute('AttributeId').Set(\
      'http://www.nordugrid.org/schemas/policy-arc/types/tls/identity'\
      )
      # request read for temporary file
      rsrc = ritem.NewChild('ra:Resource')
      rsrc.Set('file:///home/test')
      rsrc.NewAttribute('Type').Set('string')
      rsrc.NewAttribute('AttributeId').Set('urn:arc:resource:file')
      ac = ritem.NewChild('ra:Action')
      ac.Set('read')
      ac.NewAttribute('Type').Set('string')
      ac.NewAttribute('AttributeId').Set(\
      'http://www.nordugrid.org/schemas/policy-arc/types/storage/action'\
      )
      return res
\end{verbatim}

\section{Dummy and DummyService - an example service based on arcom.service.Service}
\label{DummyServiceCode}
\begin{verbatim}
import arc

class Dummy:
  """ Dummy class that provides functionality """
  def foo(self, foomsg = ''):
      return ''.join(['Foo message is: ',str(foomsg)])

from arcom.service import Service

class DummyService(Service):
  """ DummyService class based on Service class in arcom.service 
      Functionality of Dummy is accessible through this service."""
  def __init__(self, cfg):
    """ Constructor of the DummyService
        
        DummyService(cfg)
        
        'cfg' is an XMLNode which contains the config of this service."""
    
    # set service name
    self.service_name = 'Dummy'
    
    # set name of provided method
    self.request_names = ['foo']
    
    # call the Service's constructor
    Service.__init__(self,\
                     [{'request_names' : self.request_names,\
                       'namespace_prefix': 'dmmy',\
                       'namespace_uri': 'urn:foo'}],\
                     cfg)
    
    self.dummy = Dummy()
    
  def foo(self, inpayload):
    # get request
    req = inpayload.Child()
    fooreq = str(req)
    
    # get the job done    
    foomsg = self.dummy.foo(fooreq)
    
    # create response
    out = self._new_soap_payload()
    response_node = out.NewChild('dmmy:fooResponse')    
    response_node.Set(foomsg)
    
    return out
\end{verbatim}

\section{arcom.threadpool test - threadpooltest.py}
\label{ThreadPoolTestCode}
\begin{verbatim}
#!/usr/bin/python
# arcom.threadpool test

import threading, traceback

from time import sleep

from arcom.threadpool import ThreadPool, ThreadPoolThread, ReadWriteLock

COUNTER = 0

# waitTask: just sleep for a number of seconds
def waitTask(data):
  num = data[0]
  time = data[1]
  print "(%d): WaitTask starting" % num
  print "WaitTask sleeping for %d seconds" % time
  sleep(time)
  return "Waiter (%d)" % num

locker = ReadWriteLock()

# addTask: increment COUNTER with inc
def addTask(data):
  num = data[0]
  inc = data[1]
  global COUNTER
  nadds = 3
  for i in range(nadds):
    # re-acquiring lock for every add
    # don't do this at home...
    locker.acquire_write()
    COUNTER += inc
    print "(%d): Added %d to counter, counter is now %d"%(num,inc,COUNTER)
    locker.release_write()
    # sleep a bit to give other threads enough time to acquire the lock 
    sleep(1)
  return "addTask", inc
    
# Both tasks use the same callback
def taskCallback(data):
  print "Callback called for", data

# Create a pool with three worker threads
pool = ThreadPool(3)

print "\nExample1 - waitTask"

# Insert tasks into the queue and let them run
pool.queueTask(waitTask, (1,4), taskCallback)
pool.queueTask(waitTask, (2,1), taskCallback)
pool.queueTask(waitTask, (3,6), taskCallback)
pool.queueTask(waitTask, (4,2), taskCallback)

pool.joinAll()

pool = ThreadPool(4)

print "\nExample2 - addTask"

pool.queueTask(addTask, (5,10), taskCallback)
pool.queueTask(addTask, (6,10), taskCallback)
pool.queueTask(addTask, (7,10), taskCallback)
pool.queueTask(addTask, (8,10), taskCallback)

print "COUNTER before join: ", COUNTER
# When all tasks are finished, allow the threads to terminate
pool.joinAll()
print "COUNTER after join: ", COUNTER
\end{verbatim}

\input{app/ex-2-1-1.tex}
\input{app/ex-2-1-2.tex}
\input{app/ex-2-1-3.tex}
\input{app/ex-2-1-4.tex}
\input{app/ex-2-1-5.tex}
\input{app/ex-3-1.tex}
\input{app/ex-3-2.tex}
\input{app/ex-3-3.tex}
\input{app/ex-3-4.tex}
\input{app/ex-3-5.tex}
\input{app/ex-3-6.tex}
\input{app/ex-3-7.tex}

\end{document}
