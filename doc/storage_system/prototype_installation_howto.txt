Installing ARC1 storage system from source
------------------------------------------

I've used a newly installed debian system and did the following steps.

    $ sudo aptitude install subversion
    $ mkdir arc
    $ cd arc
    $ svn co http://svn.nordugrid.org/repos/nordugrid/arc1/trunk arc1
    $ cd arc1
    $ less README

the README file lists the dependencies.

    $ sudo aptitude install build-essential
    $ sudo aptitude install autoconf
    $ sudo aptitude install automake
    $ sudo aptitude install libtool
    $ sudo aptitude install python-dev
    $ sudo aptitude install pkg-config
    $ sudo aptitude install libglibmm-2.4-dev
    $ sudo aptitude install libxml2-dev
    $ sudo aptitude install libssl-dev
    $ sudo aptitude install gettext
    $ sudo aptitude install libcppunit-dev

for python binding:

    $ sudo aptitude install swig

configuration:

    $ ./autogen.sh
    $ ./configure
    
    [...]
    Java binding:       no
    Python binding:     yes (2.4)
    
    Available third-party features:
    
    RLS:                no
    GridFTP:            no
    LFC:                no
    RSL:                no
    SAML:               no
    
    Included components:
    A-Rex service:      yes
    ISI service:        yes
    PDP service:        yes
    HTTPD service:      yes
    SCHED service:      yes
    PAUL service:       no
    
    $ make

I do not want to 'install' it, just run from the source directory.
I want to create some scripts outside the sourcetree:

    $ cd ..



Running the server
------------------

    $ pwd
    /home/zsombor/arc
    $ ln -s arc1/src/services/storage/service.example.xml service.xml
    $ cat service.xml
    [...]
            <Component name="tcp.service" id="tcp">
                <next id="http"/> 
                <tcp:Listen><tcp:Port>60000</tcp:Port></tcp:Listen>
            </Component>
            <Component name="http.service" id="http">
                <next id="soap">POST</next>
            </Component>
            <Component name="soap.service" id="soap">
                <next id="plexer"/>
            </Component>
            <Plexer name="plexer.service" id="plexer">
                <next id="hash">/Hash</next>
                <next id="catalog">/Catalog</next>
                <next id="manager">/Manager</next>
                <next id="element">/Element</next>
                <next id="byteio">/byteio</next>
            </Plexer>
    [...]

let's create a runner script:

    $ cat run.sh 
    export PYTHONPATH=./arc1/src/services:./arc1/python:./arc1/python/.libs
    ./arc1/src/hed/daemon/arched -f -c ./service.xml
    
    $ ./run.sh
    Hash constructor called
    CentralHash constructor called
    PickleStore constructor called
    datadir: ./hash_data
    Catalog constructor called
    Manager constructor called
    ByteIOBackend datadir: ./element_store
    ByteIOBackend transferdir: ./element_transfer
    PickleStore constructor called
    datadir: ./element_data
    Element constructor called
    ByteIO constructor called
    ByteIOService transfer dir: ./element_transfer
    [...]


Client tools
------------

so the server is running, we need some client tools

    $ ln -s arc1/src/services/storage/cli/storage storage
    $ ./storage
    USAGE:
      storage hash|catalog|manager|element <command> <arguments>
    $ ./storage manager
    Supported methods: stat, makeCollection, list, move, putFile, getFile, addReplica

we can use some bash completion:

    $ source arc1/src/services/storage/cli/storage_bash_completion

now you can type:
    $ ./storage m<TAB>

and it completes:

    $ ./storage manager

and:

    $ ./storage manager l<TAB>

to:

    $ ./storage manager list

which says:

    $ ./storage manager list 
    Usage: list <LN> [<LN> ...]
    
    $ ./storage manager list /
    list {'0': '/'}
    {'0': ({}, 'not found')}
    
    /: not found


Using the CLI client of the Manager
-----------------------------------

so, first we need a root collection, which will be the root of the global namespace

    $ ./storage manager makeCollection /
    makeCollection {'0': ('/', {('states', 'closed'): '0'})}
    {'0': 'done'}
    
    done
    $ ./storage manager list /
    list {'0': '/'}
    {'0': ({}, 'found')}
    
    /:

now we can create a sub-collection within

    $ ./storage manager makeCollection /subcoll
    makeCollection {'0': ('/subcoll', {('states', 'closed'): '0'})}
    {'0': 'done'}
    
    done
    $ ./storage manager list / /subcoll
    list {'1': '/subcoll', '0': '/'}
    {'1': ({}, 'found'), '0': ({'subcoll': ('adba6e13-709e-483a-be51-bfcae4218ef6', {('catalog', 'type'): 'collection'})}, 'found')}
    
    /subcoll:
    
    /:
        subcoll	<collection>

this means '/subcoll' is empty, and '/' has one entry which is a collection called 'subcoll'

lets upload some file:

    $ ./storage manager putFile run.sh /myfile
    putFile {'0': ('/myfile', {('states', 'checksum'): 'ea0daccc52d3fdc7228863b47900569e', ('states', 'checksumType'): 'md5', ('states', 'neededReplicas'): 2, ('states', 'size'): 121L}, ['byteio'])}
    {'0': ['done', 'http://localhost:60000/byteio/2fd75fae-7dbc-4c3b-806f-18935ebee6d7', 'byteio']}
    
    /myfile done
    Uploading from run.sh to http://localhost:60000/byteio/2fd75fae-7dbc-4c3b-806f-18935ebee6d7
    $ ./storage manager putFile run.sh /subcoll
    putFile {'0': ('/subcoll', {('states', 'checksum'): 'ea0daccc52d3fdc7228863b47900569e', ('states', 'checksumType'): 'md5', ('states', 'neededReplicas'): 2, ('states', 'size'): 121L}, ['byteio'])}
    {'0': ['LN exists', '', '']}
    
    /subcoll LN exists
    $ ./storage manager putFile run.sh /subcoll/
    putFile {'0': ('/subcoll/run.sh', {('states', 'checksum'): 'ea0daccc52d3fdc7228863b47900569e', ('states', 'checksumType'): 'md5', ('states', 'neededReplicas'): 2, ('states', 'size'): 121L}, ['byteio'])}
    {'0': ['done', 'http://localhost:60000/byteio/c1ca88be-2c2c-4b0b-8a67-19916a87333a', 'byteio']}
    
    /subcoll/run.sh done
    Uploading from run.sh to http://localhost:60000/byteio/c1ca88be-2c2c-4b0b-8a67-19916a87333a
    $ ./storage manager list / /subcoll
    list {'1': '/subcoll', '0': '/'}
    {'1': ({'run.sh': ('9b511fcb-e64e-4fb0-927b-2be96776028a', {('catalog', 'type'): 'file'})}, 'found'), '0': ({'myfile': ('54ed1fc4-1275-4889-8055-af24d3053f7a', {('catalog', 'type'): 'file'}), 'subcoll': ('adba6e13-709e-483a-be51-bfcae4218ef6', {('catalog', 'type'): 'collection'})}, 'found')}
    
    /subcoll:
        run.sh	<file>
    
    /:
        myfile	<file>
        subcoll	<collection>

get metadata of an entry:

    $ ./storage manager stat /myfile /subcoll
    stat {0: '/myfile', 1: '/subcoll'}
    {'1': {('states', 'closed'): '0', ('entries', 'run.sh'): '9b511fcb-e64e-4fb0-927b-2be96776028a', ('catalog', 'type'): 'collection'}, '0': {('states', 'checksumType'): 'md5', ('states', 'neededReplicas'): '2', ('states', 'size'): '121', ('states', 'checksum'): 'ea0daccc52d3fdc7228863b47900569e', ('locations', 'http://localhost:60000/Element 89d19f17-23e2-475a-bc3f-fca02c6b1425'): 'alive', ('locations', 'http://localhost:60000/Element 50c15c1c-7c07-41e8-8f07-a503e1bf7517'): 'alive', ('catalog', 'type'): 'file'}}
    /subcoll:
    states
      closed: 0
    catalog
      type: collection
    entries
      run.sh: 9b511fcb-e64e-4fb0-927b-2be96776028a
    /myfile:
    states
      checksumType: md5
      neededReplicas: 2
      size: 121
      checksum: ea0daccc52d3fdc7228863b47900569e
    catalog
      type: file
    locations
      http://localhost:60000/Element 89d19f17-23e2-475a-bc3f-fca02c6b1425: alive
      http://localhost:60000/Element 50c15c1c-7c07-41e8-8f07-a503e1bf7517: alive

move something within the namespace:

    $ ./storage manager move /myfile /subcoll/
    move {'0': ('/myfile', '/subcoll/', False)}
    {'0': ['moved']}
    
    moved
    $ ./storage manager list /subcoll
    list {'0': '/subcoll'}
    {'0': ({'run.sh': ('9b511fcb-e64e-4fb0-927b-2be96776028a', {('catalog', 'type'): 'file'}), 'myfile': ('54ed1fc4-1275-4889-8055-af24d3053f7a', {('catalog', 'type'): 'file'})}, 'found')}
    
    /subcoll:
        run.sh	<file>
        myfile	<file>

download a file:

    $ ./storage manager getFile downloaded_file /subcoll/myfile
    getFile {'0': ('/subcoll/myfile', ['byteio'])}
    {'0': ['done', 'http://localhost:60000/byteio/b569e8ca-2910-4528-9c2e-453f2eb1d4d2', 'byteio']}
    
    /subcoll/myfile done
    Downloading from http://localhost:60000/byteio/b569e8ca-2910-4528-9c2e-453f2eb1d4d2 to downloaded_file
    $ cat downloaded_file 
    export PYTHONPATH=./arc1/src/services:./arc1/python:./arc1/python/.libs
    ./arc1/src/hed/daemon/arched -f -c ./service.xml

Using Manager from python (ManagerClient)
-----------------------------------------

I often use an add-on to python called 'ipython', but you can use the basic python interactive interpreter as well.

    $ sudo aptitude install ipython
    $ PYTHONPATH=./arc1/src/services:./arc1/python:./arc1/python/.libs ipython
    Python 2.4.4 (#2, Apr 15 2008, 23:43:20) 
    Type "copyright", "credits" or "license" for more information.
    
    IPython 0.7.2 -- An enhanced Interactive Python.
    ?       -> Introduction to IPython's features.
    %magic  -> Information about IPython's 'magic' % functions.
    help    -> Python's own help system.
    object? -> Details about 'object'. ?object also works, ?? prints more.
    In [1]: 

lets import the ManagerClient class:

    In [1]: from storage.client import ManagerClient
    
you can always ask help with a question mark after an object name (classes and methods are objects as well):
    
    In [2]: ManagerClient?
    Type:		classobj
    String Form:	storage.client.ManagerClient
    Namespace:	Interactive
    File:		/home/zsombor/arc/arc1/src/services/storage/client.py
    Docstring:
        Client for the Storage Manager service. 
    
    Constructor information:
    Definition:	ManagerClient(self, url, print_xml=False)
    Docstring:
        Constructior of the client.
        
        ManagerClient(url, print_xml = False)
        
        url is the URL of the Manager service
        if print_xml is true this will print the SOAP messages

let's create a ManagerClient object with the URL of the service

    In [3]: m = ManagerClient('http://localhost:60000/Manager')
    
    In [4]: m
    Out[4]: <storage.client.ManagerClient instance at 0xb724cf8c>

you can use TAB here as well:
    In [6]: m.<TAB>
    m.__class__       m.addReplica      m.host            m.ns              m.putFile
    m.__doc__         m.call            m.list            m.path            m.stat
    m.__init__        m.call_raw        m.makeCollection  m.port            m.url
    m.__module__      m.getFile         m.move            m.print_xml       
    
    In [6]: m.l<TAB>
    In [6]: m.list

and ask for help with the question mark:

    In [6]: m.list?
    [...]
    Docstring:
        List the contents of a collection.
        
        list(requests, neededMetadata = [])
        
        requests is a dictionary with requestID as key and Logical Name as value
        neededMetadata is a list of (section, property) pairs
            if neededMetadata is empty, list will return all metadata for each collection-entry
            otherwise just those values will be returnd which has a listed (section, property)
            if a property is empty means that all properties will be listed from that section
        returns a dictionary with requestID as key and (entries, status) as value, where
            entries is a dictionary with the entry name as key and (GUID, metadata) as value
            status is the status of the request
    [...]
    
the docstring tells everything. let's list some collections with specifying that we only need the 'catalog' section of the metadata
    
    In [9]: m.list({'0':'/', '1':'/subcoll'},[('catalog','')])
    Out[9]: 
    {'0': ({'subcoll': ('adba6e13-709e-483a-be51-bfcae4218ef6',
                        {('catalog', 'type'): 'collection'})},
           'found'),
     '1': ({'myfile': ('54ed1fc4-1275-4889-8055-af24d3053f7a',
                       {('catalog', 'type'): 'file'}),
            'run.sh': ('9b511fcb-e64e-4fb0-927b-2be96776028a',
                       {('catalog', 'type'): 'file'})},
           'found')}

let's move our file:

    In [11]: m.move({'a': ['/subcoll/myfile','/run.sh',False]})
    Out[11]: {'a': ['moved']}
    
    In [12]: m.stat({'xxx' : '/'})
    Out[12]: 
    {'xxx': {('catalog', 'type'): 'collection',
             ('entries', 'run.sh'): '54ed1fc4-1275-4889-8055-af24d3053f7a',
             ('entries', 'subcoll'): 'adba6e13-709e-483a-be51-bfcae4218ef6',
             ('states', 'closed'): '0'}}

Using other services with the CLI
---------------------------------

The users usually don't need to access the other services but the Manager.
But while developing the services these clients are very useful.

let's see what we can do with the Catalog service:

    $ ./storage catalog 
    Supported methods: new get traverseLN modifyMetadata
    $ ./storage catalog get
    Usage: get <GUID> [<GUID> ...] neededMetadata [<section> [<property>] ...] 
    $ ./storage catalog get 0
    get ['0'] []
    {'0': {('states', 'closed'): '0', ('entries', 'run.sh'): '54ed1fc4-1275-4889-8055-af24d3053f7a', ('catalog', 'type'): 'collection', ('entries', 'subcoll'): 'adba6e13-709e-483a-be51-bfcae4218ef6'}}

the root collection always has the GUID '0' so we could get that, now we know the GUID of the '/run.sh', which is 54ed1fc4-1275-4889-8055-af24d3053f7a

    $ ./storage catalog get 54ed1fc4-1275-4889-8055-af24d3053f7a
    get ['54ed1fc4-1275-4889-8055-af24d3053f7a'] []
    {'54ed1fc4-1275-4889-8055-af24d3053f7a': {('states', 'checksumType'): 'md5', ('states', 'neededReplicas'): '2', ('states', 'size'): '121', ('states', 'checksum'): 'ea0daccc52d3fdc7228863b47900569e', ('locations', 'http://localhost:60000/Element 89d19f17-23e2-475a-bc3f-fca02c6b1425'): 'alive', ('locations', 'http://localhost:60000/Element 50c15c1c-7c07-41e8-8f07-a503e1bf7517'): 'alive', ('catalog', 'type'): 'file'}}

we can use the traverseLN method to translate Logical Names to a list of GUIDs along the path:

    $ ./storage catalog traverseLN /subcoll/run.sh
    traverseLN {'0': '/subcoll/run.sh'}
    {'0': ({('states', 'checksumType'): 'md5', ('states', 'neededReplicas'): '2', ('states', 'size'): '121', ('states', 'checksum'): 'ea0daccc52d3fdc7228863b47900569e', ('catalog', 'type'): 'file', ('locations', 'http://localhost:60000/Element 4177e062-50cc-42b9-bfbb-9841e4ee595d'): 'alive', ('locations', 'http://localhost:60000/Element dd43dfb0-4389-40fd-ac41-378de24d4a9e'): 'alive'}, '9b511fcb-e64e-4fb0-927b-2be96776028a', '/subcoll/run.sh', '', True, [('', '0'), ('subcoll', 'adba6e13-709e-483a-be51-bfcae4218ef6'), ('run.sh', '9b511fcb-e64e-4fb0-927b-2be96776028a')])}

we could modify the metadata of any entry using the Catalog. this actually create a hardlink to a directory:

    $ ./storage catalog modifyMetadata 0 set entries othername adba6e13-709e-483a-be51-bfcae4218ef6
    modifyMetadata {'0': ['0', 'set', 'entries', 'othername', 'adba6e13-709e-483a-be51-bfcae4218ef6']}
    {'0': 'set'}
    $ ./storage manager list /
        run.sh	<file>
        othername	<collection>
        subcoll	<collection>
    $ ./storage manager list /othername
        run.sh	<file>
    $ ./storage manager list /subcoll
        run.sh	<file>

let's check the Hash service which is the actual metadata store.
the Catalog stores everything in the Hash service using the GUIDs as IDs:

    $ ./storage hash get
    ./arc1/src/services/storage/cli/hash_client.py:get
    Usage: get <ID> [<ID> ...] neededMetadata [<section> [<property>] ...]
    $ ./storage hash get 0
    ./arc1/src/services/storage/cli/hash_client.py:get:0
    get ['0'] []
    {'0': {('states', 'closed'): '0', ('entries', 'run.sh'): '54ed1fc4-1275-4889-8055-af24d3053f7a', ('catalog', 'type'): 'collection', ('entries', 'subcoll'): 'adba6e13-709e-483a-be51-bfcae4218ef6'}}

the Element service stores the replicas of the files:

    $ ./storage manager stat /run.sh
    [...]
    locations
      http://localhost:60000/Element 89d19f17-23e2-475a-bc3f-fca02c6b1425: alive
      http://localhost:60000/Element 50c15c1c-7c07-41e8-8f07-a503e1bf7517: alive

a replica location is a serviceID and referenceID, the serviceID is currently a URL
let's check one of the referenceIDs:

    $ ./storage element stat 89d19f17-23e2-475a-bc3f-fca02c6b1425
    stat {'0': '89d19f17-23e2-475a-bc3f-fca02c6b1425'}
    {'0': {'referenceID': '89d19f17-23e2-475a-bc3f-fca02c6b1425', 'checksumType': 'md5', 'checksum': 'ea0daccc52d3fdc7228863b47900569e', 'localID': 'dba5b5d1-d311-4f64-a2e7-dd951b34c1bf', 'acl': '', 'state': 'alive', 'GUID': '54ed1fc4-1275-4889-8055-af24d3053f7a', 'size': '121'}}

and let's get it:

    $ ./storage element get 89d19f17-23e2-475a-bc3f-fca02c6b1425
    get {'0': [('referenceID', '89d19f17-23e2-475a-bc3f-fca02c6b1425'), ('protocol', 'byteio')]}
    Downloading: http://localhost:60000/byteio/ecb7ad5e-8755-4aad-b16b-a7cd9ef989ab
    Checksum is ea0daccc52d3fdc7228863b47900569e
    ***
    export PYTHONPATH=./arc1/src/services:./arc1/python:./arc1/python/.libs
    ./arc1/src/hed/daemon/arched -f -c ./service.xml
    
    ***
    actual checksum is ea0daccc52d3fdc7228863b47900569e

it just prints the content of the file to the screen.

Using other services from python with client.py
-----------------------------------------------

The storage.client package contains not just the ManagerClient but clients for all the other services.
Currently they are not very well documented.

after starting ipython:

    In [1]: import storage.client
    
    In [2]: storage.client.<TAB>
    [...]
    storage.client.ByteIOClient       
    storage.client.CatalogClient      
    storage.client.Client             
    storage.client.ElementClient      
    storage.client.HashClient         
    storage.client.ManagerClient      
    storage.client.NotifyClient       
    [...]


the HashClient:

    In [2]: h = storage.client.HashClient('http://localhost:60000/Hash')
    
    In [3]: h.get([0])
    Out[3]: 
    {'0': {('catalog', 'type'): 'collection',
           ('entries', 'othername'): 'adba6e13-709e-483a-be51-bfcae4218ef6',
           ('entries', 'run.sh'): '54ed1fc4-1275-4889-8055-af24d3053f7a',
           ('entries', 'subcoll'): 'adba6e13-709e-483a-be51-bfcae4218ef6',
           ('states', 'closed'): '0'}}

the CatalogClient:

    In [4]: c = storage.client.CatalogClient('http://localhost:60000/Catalog')
    
    In [5]: c.traverseLN({'0':'/othername/run.sh'})
    Out[5]: 
    {'0': ({('catalog', 'type'): 'file',
            ('locations', 'http://localhost:60000/Element 4177e062-50cc-42b9-bfbb-9841e4ee595d'): 'alive',
            ('locations', 'http://localhost:60000/Element dd43dfb0-4389-40fd-ac41-378de24d4a9e'): 'alive',
            ('states', 'checksum'): 'ea0daccc52d3fdc7228863b47900569e',
            ('states', 'checksumType'): 'md5',
            ('states', 'neededReplicas'): '2',
            ('states', 'size'): '121'},
           '9b511fcb-e64e-4fb0-927b-2be96776028a',
           '/othername/run.sh',
           '',
           True,
           [('', '0'),
            ('othername', 'adba6e13-709e-483a-be51-bfcae4218ef6'),
            ('run.sh', '9b511fcb-e64e-4fb0-927b-2be96776028a')])}
    
the ElementClient:

    In [9]: e = storage.client.ElementClient('http://localhost:60000/Element')
    In [11]: e.stat({'q':'89d19f17-23e2-475a-bc3f-fca02c6b1425'})
    Out[11]: 
    {'q': {'GUID': '54ed1fc4-1275-4889-8055-af24d3053f7a',
           'acl': '',
           'checksum': 'ea0daccc52d3fdc7228863b47900569e',
           'checksumType': 'md5',
           'localID': 'dba5b5d1-d311-4f64-a2e7-dd951b34c1bf',
           'referenceID': '89d19f17-23e2-475a-bc3f-fca02c6b1425',
           'size': '121',
           'state': 'alive'}}

let's get the file from the Manager:

    In [17]: m = storage.client.ManagerClient('http://localhost:60000/Manager')
    In [21]: m.getFile({'1':['/run.sh', ['byteio']]})
    Out[21]: 
    {'1': ['done',
           'http://localhost:60000/byteio/fb418bd6-ca7a-4c03-875b-45be520eb2e0',
           'byteio']}

now we have a byteio URL: http://localhost:60000/byteio/fb418bd6-ca7a-4c03-875b-45be520eb2e0
let's grab it with the ByteIOClient:

    In [22]: b = storage.client.ByteIOClient('http://localhost:60000/byteio/fb418bd6-ca7a-4c03-875b-45be520eb2e0')
    In [24]: b.read()
    Out[24]: 'export PYTHONPATH=./arc1/src/services:./arc1/python:./arc1/python/.libs\n./arc1/src/hed/daemon/arched -f -c ./service.xml\n'
    
    
Adding an echo service to the system
------------------------------------

there is an example Echo service in the subversion which was written in python:

$ cat arc1/src/services/echo_python/EchoService.py 
import arc
import time

class EchoService:

    def __init__(self, cfg):
        print "EchoService (python) constructor called"
        # get the response-prefix from the config XML
        self.prefix = str(cfg.Get('prefix'))
        # get the response-suffix from the config XML
        self.suffix = str(cfg.Get('suffix'))
        print "EchoService (python) has prefix '%s' and suffix '%s'" % (self.prefix, self.suffix)

    def process(self, inmsg, outmsg):
        print "EchoService (python) 'Process' called"
        # time.sleep(10)
        # get the payload from the message
        inpayload = inmsg.Payload()
        print "EchoService (python) got:", inpayload.GetXML()
        # we want to use members of the 'urn:echo' namespace
        # so we need to know which namespace prefix was assigned to it
        # we get the namespace prefix
        echo_ns = inpayload.NamespacePrefix('urn:echo')
        # then we can get 'prefix:echo/prefix:say'
        echo_op = inpayload.Get(echo_ns + ':echo')
        say = str(echo_op.Get(echo_ns + ':say'))
        # put it between the response-prefix and the response-suffix
        hear = self.prefix + say + self.suffix
        # create an answer payload
        outpayload = arc.PayloadSOAP(arc.NS({'echo':'urn:echo'}))
        # here we defined that 'echo' prefix will be the namespace prefix of 'urn:echo'
        # and we create a node at '/echo:echoResponse/echo:hear' and put the string in it
        outpayload.NewChild('echo:echoResponse').NewChild('echo:hear').Set(hear)
        # put the payload into the outgoing message
        outmsg.Payload(outpayload)
        # return with STATUS_OK
        return arc.MCC_Status(arc.STATUS_OK)

If we want to start this we need to edit the service.xml config file:

    add /Echo to the plexer:

        <Plexer name="plexer.service" id="plexer">
            <next id="echo">/Echo</next>
            <next id="hash">/Hash</next>
            <next id="catalog">/Catalog</next>
            <next id="manager">/Manager</next>
            <next id="element">/Element</next>
            <next id="byteio">/byteio</next>
        </Plexer>

    create Service node for it:
        
        <Service name="pythonservice" id="echo">
            <ClassName>echo_python.EchoService.EchoService</ClassName>
            <Prefix>TADAA! </Prefix>
        </Service>

    the ClassName is manditory, here 'echo_python' is the directory name (module),
    the first 'EchoService' is the name of the .py file (package),
    the second 'EchoService' is the name of the class within the package
    
We could create a small shellscript to test it:

    $ cat echo_test.sh 
    MESSAGE='<?xml version="1.0"?><soap-env:Envelope xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:star="urn:echo"><soap-env:Body><star:echo><star:say>HELLO</star:say></star:echo></soap-env:Body></soap-env:Envelope>'
    echo Request:
    echo $MESSAGE
    echo
    echo Response:
    curl -d "$MESSAGE" http://localhost:60000/Echo
echo

    $ chmod +x echo_test.sh 
   
    $ ./echo_test.sh 
    Request:
    <?xml version="1.0"?><soap-env:Envelope xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:star="urn:echo"><soap-env:Body><star:echo><star:say>HELLO</star:say></star:echo></soap-env:Body></soap-env:Envelope>
    
    Response:
    <soap-env:Envelope xmlns:echo="urn:echo" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap-env:Body><echo:echoResponse><echo:hear>TADAA! HELLO</echo:hear></echo:echoResponse></soap-env:Body></soap-env:Envelope>

The answer has a "TADAA! HELLO" string in it.


Client tools in python
----------------------

Let's call it from python! I use ipython as usual:

    In [1]: from storage.client import Client
    
    In [2]: Client?
    Type:		classobj
    String Form:	storage.client.Client
    Namespace:	Interactive
    File:		/Users/zsombor/Development/arc/arc1/src/services/storage/client.py
    Docstring:
        Base Client class for sending SOAP messages to services 
    
    Constructor information:
    Definition:	Client(self, url, ns, print_xml=False)
    Docstring:
        The constructor of the Client class.
        
        Client(url, ns, print_xml = false)
        
        url is the URL of the service
        ns contains the namespaces we want to use with each message
        print_xml is for debugging, prints all the SOAP messages to the screen

We need a namespace object with the namespace of the Echo service, which is currently 'urn:echo', and we want to call it 'echo':

    In [4]: import arc
    
    In [5]: ns = arc.NS({'echo':'urn:echo'})

Now 'ns' contains the namespace object, we could create the Client:

    In [6]: echo_client = Client('http://localhost:60000/Echo', ns, print_xml = True)
    
We want it to print out the SOAP messages for debug: print_xml = True

We could create an XML object to send:

    In [32]: xml = arc.XMLNode("""<soap-env:Envelope xmlns:echo="urn:echo" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap-env:Body><echo:echo><echo:say>HI!</echo:say></echo:echo></soap-env:Body></soap-env:Envelope>""")
    
    In [34]: print xml.GetXML()
    <soap-env:Envelope xmlns:echo="urn:echo" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap-env:Body><echo:echo><echo:say>HI!</echo:say></echo:echo></soap-env:Body></soap-env:Envelope>

Then we could call the service with the call_raw method of the Client:

    In [35]: echo_client.call_raw(xml)
    Out[35]: 
    ('<soap-env:Envelope xmlns:echo="urn:echo" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap-env:Body><echo:echoResponse><echo:hear>TADAA! HI!</echo:hear></echo:echoResponse></soap-env:Body></soap-env:Envelope>',
     200,
     'OK')

There is an XMLTree class which can be used to create simple XML structures from python lists:

    In [9]: from storage.xmltree import XMLTree
    
    In [11]: tree = XMLTree(from_tree =
                ('echo:echo', [
                    ('echo:say', 'HI!')
                ])
             )
             
It is the same as:

    In [36]: tree = XMLTree(from_tree = ('echo:echo', [('echo:say','HI!')]))

just with a few newlines to look better.

This XMLTree can be serialized as a simple XML document:

    In [18]: print tree.pretty_xml()
    <echo:echo>
      <echo:say>HI!</echo:say>
    </echo:echo>

There is no attributes support in XMLTree, just plain XML tags with text contents.

So now we have an XMLTree with the actual message, we could use the 'call' method of the client,
which will print the XML documents because of the 'print_xml = True' argument when we created it.

    In [19]: echo_client.call(tree)
    Request:
            #   <soap-env:Body>
            #       <echo:echo>
            #           <echo:say>HI!</echo:say>
            #       </echo:echo>
            #   </soap-env:Body>
    
    Response:
            #   <soap-env:Envelope>
            #       <soap-env:Body>
            #           <echo:echoResponse>
            #               <echo:hear>TADAA! HI!</echo:hear>
            #           </echo:echoResponse>
            #       </soap-env:Body>
            #   </soap-env:Envelope>
    
    Out[19]: 
    ('<soap-env:Envelope xmlns:echo="urn:echo" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap-env:Body><echo:echoResponse><echo:hear>TADAA! HI!</echo:hear></echo:echoResponse></soap-env:Body></soap-env:Envelope>',
     200,
 'OK')

And if we do not need the HTTP status messages and we need the answer as an XMLTree, we could ask 'call' to return only that:

In [21]: print echo_client.call(tree, True)
    Request:
            #   <soap-env:Body>
            #       <echo:echo>
            #           <echo:say>HI!</echo:say>
            #       </echo:echo>
            #   </soap-env:Body>
    
    Response:
            #   <soap-env:Envelope>
            #       <soap-env:Body>
            #           <echo:echoResponse>
            #               <echo:hear>TADAA! HI!</echo:hear>
            #           </echo:echoResponse>
            #       </soap-env:Body>
            #   </soap-env:Envelope>
    
    ('echoResponse', [('hear', 'TADAA! HI!')])


To summarize the whole thing, here is the shortest example of calling the echo service from python:

    In [1]: import arc
    In [2]: ns = arc.NS({'echo':'urn:echo'})
    In [3]: from storage.xmltree import XMLTree
    In [4]: tree = XMLTree(from_tree = ('echo:echo', [('echo:say','HI!')]))
    In [5]: from storage.client import Client
    In [6]: echo_client = Client('http://localhost:60000/Echo', ns)
    In [7]: print echo_client.call(tree, True)

    ('echoResponse', [('hear', 'TADAA! HI!')])

Meanwhile the server log has:

    EchoService (python) 'Process' called
    EchoService (python) got: <soap-env:Envelope xmlns:echo="urn:echo" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><soap-env:Body><echo:echo><echo:say>HI!</echo:say></echo:echo></soap-env:Body></soap-env:Envelope>
