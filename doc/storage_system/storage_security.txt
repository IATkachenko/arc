Security in the ARC1 storage system
===================================

Architecture
------------

The ARC storage system consists of several services. Most of the services (A-Hash, Librarian, Shepherd) are 'internal' services in a way that the end-user of the storage system never communicate with them directly. But these internal services are communicating with eachother, so they have to know who to trust. This is the 'inter-service authorization' part of the security archiecture. The end-users always connects to one of the Bartender services, which will decide if the user has permissions to do something or not. This is the 'high-level authorization' part. None of these services is capable of actually storing files, we need additional services for this: the storage element services. These can be native ARC services (such as the Hopi service) or third-party services (such as the apache http server, or dcache). A Shepherd service and a storage element service together form a storage node in the ARC storage system. For each supported storage element service we need a Shepherd-backend (currently we have one for Hopi and one for apache), when the Bartender asks the Shepherd to initiate a file transfer (upload or download) the Shepherd uses these backends to set up the storage element for the transfer, and to create the transfer URL. Then the user will connects directly to the storage element. This means that for each supported storage element service we have to figure out how to make that service aware of the identity and rights of our users. We call this part 'transfer-level authorization'.

Inter-service authorization
---------------------------

In a deployment of the ARC storage system, we could have several A-Hash, Librarian, Shepherd and Bartender services. The Bartenders send requests to the Librarians and the Shepherds, the Shepherds communciate with the Librarians, the Librarians talk with the A-Hashes. If any of these services get compromised or a new rouge service gets inserted in the system, we loose security completely. That's why it is vital for each service to authorize the services before sending or accepting requests.

e.g. when a user connects to a Bartender and wants to download a file, the Bartender asks the Librarian about the metadata of the file which contains the access policies, and the Bartender makes decision based on the response from the Librarian. If this Librarian is compromised and e.g. always returns that everybody has access to every file and collection, then the Bartender will make wrong decisions. Or if somebody can somehow insert a rouge Bartender into the system, then he can do anything, because a Bartender has rights to access and modify all metadata and to initiate file transfers, etc.

The services commincates via HTTPS protocol, which means that they should provide an X.509 certificate for each connection, and they can examine the other service's certificates. This also means that we have to configure these services to know where their X.509 certificates are. The current method for this is to write the path of the certificate into the configuration of each services.

Let's examine the situation from the Librarian's point of view. The Librarian will get requests from Bartenders and Shepherds, and it needs an A-Hash to get the information which needed to reply these requests. The Librarian has to be sure that it can trust the information which it gets from the A-Hash. A very simple but inflexible solution: write the DN of the A-Hash into the configuration of the Librarian service. When the Librarian establishes the connection to the A-Hash it can check that the DN of the A-Hash is the same which is configured, and the Librarian must of course trust the CA which signed the certicate of A-Hash. So if you want to insert your rouge A-Hash into the system, you need to obtain a certificate from a trusted CA with that DN, or get the actual private key from the server - both seems very unlikely.
If we will have multiple A-Hashes (all are part of the same logical database) then if we just write one of them into the Librarian's config, then if that particular A-Hash is down, the Librarian cannot fulfil the requests even though the other A-Hashes could reply. So we could write the DNs of all the A-Hashes into the config of the Librarian. This makes the process of adding a new A-Hash a bit difficult, we have to include the DN of the new A-Hash into the config of each Librarian. Now the Librarian gets a request from a Bartender. It has to be sure that this Bartender is one of the trusted Bartenders before acting as requested or returning any information. This also can be achieved with putting the DNs of all the trusted Bartenders into the config of each Librarian. This solution is only suitable if we have a fixed set of services and if we don't frequently add or remove services from the system.

An other option could be using a private CA for a deployment of the ARC storage system. We could issue certificates for all the services and all could be signed by this CA, and then we only have to put the DN of the CA into the configuration of the services. Then all the storage services will automatically trust every other service whose certificate is signed by this ARC storage CA. This CA would be private in a sense that we only use it for the storage services and nothing else.

It is possible to use the A-Hash to store the identity of the trusted services. Then each service could retreive a list of DNs from the A-Hash when starting. For this we have to include one or more trusted A-Hash nodes in the configuration of each service, and when the service initializes it can get the corresponding object from the A-Hash which contains the list of trusted services. (The detailed way of doing this is not designed yet.) This and the other solutions could be used at the same time which could provide both flexibility and simplicity.

Transfer-level authorization
----------------------------

When the Bartender decides that a user indeed has permission to download a file, then it chooses a location (a Shepherd on a storage node), and initiate the transfer by the Shepherd. The Shepherd communicates with the storage element service on the storage node, prepares the transfer, and creates a transfer URL (TURL), which is a direct URL to the storage element service (Hopi, apache, etc.). Then this TURL is returned to the user, then the user connects directly to the storage element. The simplest architecture would be this: the storage element could be configured in a way that it serves everybody. If new TURLs are generated for each request, and if this TURLs are long enough to be unguessable (and the TURLs are returned to the user via secure channel), then this could be taken as a one-time password solution. Currently the Hopi service is implemented in a way, that it only accepts the first HTTP connection to an URL, so if the user starts downloading the file, nobody else can do it, and before the user starts downloading the file nobody can guess the TURL.

If we want more than that, we need to have access to all the different storage element services and change the access control rules on the storage element servic itself. For example if we use the Hopi service as a storage element service, and 'User1' wants to get a file, User1 connects to the Bartender, which asks the Shepherd which controls this Hopi service, and the Shepherd will modify the access control of the given file, so when the user later connects with the given TURL to the Hopi service the user can use its own certificate, the Hopi service will know that this user has rights to get the file. In this case we need some mechinasim which will remove the user from the authorized users of the file after the download finished, or after a given amount of time. For this, we need to add some more methods to the interface of Shepherd backends, and implement this access control rule change mechanism for each supported storage element service.

e.g.
We have a Hopi service which stores a file - this file is called 'abc' on the Hopi service (this is its referenceID), and this file is readable by noone. This file is a replica of a file called '/joe' which is a Logical Name.
When User1 wants to get '/joe' and the Bartender chooses the replica which is on our Hopi, the Bartender asks the Shepherd which is next to our Hopi, and the Shepherds will modify the access control rules of the Hopi, adding the DN of User1 to this file.
Now this file is readable by User1. Then User1 gets a TURL, and connects to our Hopi directly with this TURL to get the file, our Hopi will see that User1 is permitted to get the file, so User1 will get the file. After User1 got the file, we want to change the access control rules of this file back to the original (when nobody can read it). If we can detect when User1 finished the download, then this can be triggered. If we cannot detect, then we can use a timeout mechanism.

High-level authorization
------------------------

The ARC storage system has a component called Librarian, which is storing all the metadata about files and collections in the system (and uses the A-Hash service as a database, so "stored in the A-Hash" and "stored at the Librarian" means the same). The access control rules are stored among these metadata. The format of the access control rules is the following:

DN1: +action, +action, -action, ....
DN2: +action, -action, -action, ....
...

There are DNs (Distingushed Names as used in the X509 certificates) listed and for each DN there is a list of actions, each prefixed with a + or - character which indicates that the given action is allowed or not allowed for the given DN.

The list of actions:
- read: user can get the list of entries in the collection; user can download the file
- addEntry: user can add a new entry to the collection;
- removeEntry: user can remove any entry from the collection 
- delete: user can delete the collection if it is empty; user can delete a file
- modifyPolicy: user can modify the policy of the file/collection
- modifyStates: user can modify some special metadata of the file/collection (close the collection, number of needed replica of the file)
- modifyMetadata: user can modify the arbitrary metadata section of the file/collection (these are key-value pairs)

Additionaly, each file and collection has an 'owner' which is a user who always can modify the access control rules.

If we have a collection with a Logical Name of '/niif/projects/jupiter', and we have this rule among its metadata:

/C=HU/O=NIIF/CN=zsombor@niif.hu: +read, -removeEntry

Which means that a user who has the identity '/C=HU/O=NIIF/CN=zsombor@niif.hu' is allowed to read the contents of this file and not allowed to removeEntry. So when this user is contacting a Bartender to get the content of the collection of '/niif/projects/jupiter', then the Bartender gets the metadata of the collection from the Librarian, and now the Bartender has the access control rules which are effective to this collection.

Now the Bartender wants to use the policy evaluator framework of the HED, so it will convert this simple representation to the native ARC policy XML format, something like this:

>>> print storage.common.AuthPolicy({'/C=HU/O=NIIF/CN=zsombor@niif.hu': ['+read', '-removeEntry']}).get_policy()

<Policy xmlns="http://www.nordugrid.org/schemas/policy-arc" CombiningAlg="Deny-Overrides">
  <Rule Effect="Deny">
    <Description>/C=HU/O=NIIF/CN=zsombor@niif.hu is not allowed to removeEntry</Description>
    <Subjects>
      <Subject>
        <Attribute AttributeId="http://www.nordugrid.org/schemas/policy-arc/types/tls/identity" Type="string">/C=HU/O=NIIF/CN=zsombor@niif.hu</Attribute>
      </Subject>
    </Subjects>
    <Actions>
      <Action AttributeId="http://www.nordugrid.org/schemas/policy-arc/types/storage/action" Type="string">removeEntry</Action>
    </Actions>
  </Rule>
  <Rule Effect="Permit">
    <Description>/C=HU/O=NIIF/CN=zsombor@niif.hu is allowed to read</Description>
    <Subjects>
      <Subject>
        <Attribute AttributeId="http://www.nordugrid.org/schemas/policy-arc/types/tls/identity" Type="string">/C=HU/O=NIIF/CN=zsombor@niif.hu</Attribute>
      </Subject>
    </Subjects>
    <Actions>
      <Action AttributeId="http://www.nordugrid.org/schemas/policy-arc/types/storage/action" Type="string">read</Action>
    </Actions>
  </Rule>
</Policy>

Then the Bartender needs to create a 'request' which is also an XML document containing the information who wants to do what.
Something like this:

 <Request>
   <RequestItem>
    <Subject>
       <Attribute AttributeId="http://www.nordugrid.org/schemas/policy-arc/types/tls/identity" Type="string">/C=HU/O=NIIF/CN=zsombor@niif.hu</Attribute>
    </Subject>
    <Action AttributeId="http://www.nordugrid.org/schemas/policy-arc/types/storage/action" Type="string">read</Action>
   </RequestItem>
 </Request>

The <Subject> part is retrieved from the security framework by exporting the Security Attributes of the message, it should contain everything we know about the user, the DN, any attributes from the certificate of the user, VO membership, etc. These information are extracted by the MCCs and/or Security Handlers.

The <Action> part is filled by the Bartender, e.g. the 'list' method needs a 'read' permission, so it will put that action into the request. 

Now the Bartender creates an Evaluator, adds the policy to it, and then call the 'evaluate' method with the request. Then the Evaluator returns the decision.