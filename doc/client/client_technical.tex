\documentclass{book}
%\documentclass{article}                            %for shorter notes
\usepackage{graphicx}                              %for PNG images (pdflatex)
%\usepackage{graphics}                              %for EPS images (latex)
\usepackage[linkbordercolor={1.0 1.0 0.0}]{hyperref} %for \url tag
\usepackage{color}                                 %for defining custom colors
\usepackage{framed}                                %for shaded and framed paragraphs
\usepackage{textcomp}                              %for various symbols, e.g. Registered Mark
\usepackage{geometry}                              %for defining page size
\usepackage{longtable}                             %for breaking tables
%
\geometry{verbose,a4paper,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2cm}
\hypersetup{
  pdfauthor = {Author Name},
  pdftitle = {Paper title},
  pdfsubject = {Paper subject},
  pdfkeywords = {Paper,keyword,comma-separated},
  pdfcreator = {PDFLaTeX with hyperref package},
  pdfproducer = {PDFLaTeX}
}
%
\bibliographystyle{IEEEtran}                       %a nice bibliography style
%
\def\efill{\hfill\nopagebreak}%
\hyphenation{Nordu-Grid}
\setlength{\parindent}{0cm}
\setlength{\FrameRule}{1pt}
\setlength{\FrameSep}{8pt}
\addtolength{\parskip}{5pt}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\arraystretch}{1.3}
\newcommand{\dothis}{\colorbox{shadecolor}}
\newcommand{\globus}{Globus Toolkit\textsuperscript{\textregistered}~2~}
\newcommand{\GT}{Globus Toolkit\textsuperscript{\textregistered}}
\newcommand{\ngdl}{\url{http://ftp.nordugrid.org/download}~}
\definecolor{shadecolor}{rgb}{1,1,0.6}
\definecolor{salmon}{rgb}{1,0.9,1}
\definecolor{bordeaux}{rgb}{0.75,0.,0.}
\definecolor{cyan}{rgb}{0,1,1}
%
%----- DON'T CHANGE HEADER MATTER
\begin{document}
\def\today{\number\day/\number\month/\number\year}

\begin{titlepage}

\begin{tabular}{rl}
\resizebox*{3cm}{!}{\includegraphics{ng-logo.png}}
&\parbox[b]{2cm}{\textbf \it {\hspace*{-1.5cm}NORDUGRID\vspace*{0.5cm}}}
\end{tabular}

\hrulefill

%-------- Change this to NORDUGRID-XXXXXXX-NN

{\raggedleft NORDUGRID-XXXXXXX-NN\par}

{\raggedleft \today\par}

\vspace*{2cm}

%%%%---- The title ----
{\centering \textsc{\Large Paper title}\Large \par}
\vspace*{0.5cm}
    
%%%%---- A subtitle, if necessary ----
{\centering \textit{\large Paper subtitle}\large \par}
    
\vspace*{1.5cm}
%%%%---- A list of authors ----
    {\centering \large Paper author\footnote{authors@address} \large \par}
    
%%%%---- An abstract - if style is article ----
%\begin{abstract}
%The abstract
%\end{abstract}
\end{titlepage}

\tableofcontents                          %Comment if use article style
\newpage
\chapter{Preface}
\label{sec:intro}

This document describes from a technical viewpoint a plugin based client library for the new 
Web Service (WS) based Advanced Resource Connector (ARC) middleware. The library is capable of 
handling resource discovery, job submission and job control and interoperates with several 
different grid flavours. The support for different grid flavours is enabled through the modular 
design using plugins specialized for each supported middleware, and presently supported are ARC0 
(ARC classic), ARC1 and the gLite middlewares. Future extensions to support additional middlewares 
involve plugin compilation only i.e. no recompilation of main libraries or client.

Using the library a set of command line tools have been built which puts the library's functionality 
at the fingertips of users. While this documentation will illustrate how such command line tool can be 
built, the main documention of the command line tools is given in the client user manual [ref].

Finally the library has been designed with care for later usage within a graphical user interface. This 
particularly applies to the job management part.

\chapter{Resource Discovery and Information Retrieval}
\label{sec:TargetDiscovery}
Almost every day a new grid cluster is purchased and made available around the world (either to the 
general public or restricted to authorized users). More available clusters create a need for better and 
faster resource discovery and information retrieval, making this task an utmost important component of the 
new client library.

The new client library's resource discovery and information retrieval component consists of three classes, one 
of which a base class for further grid middleware specific specialization (plugin):

\begin{itemize}
\item{{\bf TargetGenerator} is responsible for loading TargetRetriever plugins in accordance with the input URLs. 
e.g. if an URL pointing to an ARC1 resource is given the TargetRetrieverARC1 is loaded. When queried for resources 
(``targets'') the TargetGenerator passes the request to the loaded TargetRetrievers running them as individual threads 
for improved performance. The TargetGenerator keeps records of by TargetRetriever found servers and services 
(index or computing) in order to avoid multiple queries. Accepted targets are stored in the FoundTargets array kept by 
the TargetGenerator.}

\item{{\bf TargetRetriever} is base class for TargetRetriever grid middleware specializations. Contains the pure 
virtual method GetTargets which is to be implemented by the specialized class. While it is not mandatory it is recommended 
that the specialized class divides this function into two components: QueryIndex and InterrogateTarget. The former is 
responsible for querying index servers, and if the result yields an addresss to a different index server then the 
specialized TargetRetriever should call itself recursively with the found url. Discovered computing services are sent 
to the InterrogateTarget function (or if the TargetRetriever was initialized with a computing service url then it should 
jump directly to this point) which collects the detailed information about the service.}

\item{{\bf ExecutionTarget} is the class representation of a computing resource (queue) capable of running a grid job. It
serves as input to the broker which is foreseen to be able to select between different ExecutionTargets from different 
grid flavours without apriori knowing their difference. The ExecutionTarget class mimics the glue2 information model (with 
a flattened structure), and thus a mapping between attributes from other information systems into the glue2 format is needed. 
Appendix XX shows the current mapping for the production ARC, ARC1 and gLite middlewares. All information can be printed by 
invoking the ExecutionTarget's ``Stat'' command which prints all variables (if they have been filled during the information 
retrieval process).

Following a broker decision jobs are to be submitted. Since all information about the selected computation resides within the 
selected ExecutionTarget, the ExecutionTarget is capable of returning a submitter (see next section) capable of submitting a 
job to the resource which is represents.}
\end{itemize}

Figure \ref{fig:ResDisc} depicts how the classes work together in a command chain to discover all resources registered with 
a certain information server. Below a description of each step is given:

\begin{figure}[ht]
\centering{{\scalebox{0.75}{\includegraphics{TargetDiscovery.png}}}
\caption{\label{fig:ResDisc}Diagram depicting the process of resource discovery.} }
\end{figure}

\begin{enumerate}
\item{The TargetGenerator takes three URL arrays as input. First array contains individually selected clusters, while the 
second array contains individually selected index servers (1a). The last array contains a list of rejected clusters. This 
list is parsed through alias resolve before being inserted as filter to the storage of found services (1b).}
\item{The complete list of URLs pointing to services and index servers.}
\item{For each URL a TargetRetriever plugin is loaded using the HED ? loader. The TargetRetriever is initialized 
with the URL and the information about wether the URL points to a service or an index server.}
\item{An external call is received calling for targets to be prepared. Call is propagated to all loaded TargetRetrievers.}
\item{The call for targets is processed by each TargetRetriever in parallel. If the TargetRetriever is initialized with an 
index server URL it first registers at the Index Servers store kept by the TargetGenerator. If allowed to register, data 
is read out from the server and processed.}
\item{The TargetRetriver finds a registered service and contacts the Found Services store kept by the TargetGenerator to check 
if the service in question has been found be another TargetRetriever. (Services often registers at more than one index server, 
thus different TargetRetrievers may discover the same service.)}
\item{If registered in the Found Services store the TargetRetriever progresses to interrogate the service.}
\item{Found and processed ExecutionTargets are stored in the Found Targets store kept by the TargetGenerator for later usage 
(e.g. status printing or job submission).}
\item{Index servers often registers with other index servers creating a nested hierarchical information structure. For this 
reasons a TargetRetriever interpreting the read out result from an index server may encounter other index servers. In that 
event the TargetRetriever calls itself recursively creating a new thread for the new URL. This ensures optimum speed and 
performance for resource discovery.}
\end{enumerate}

The example above outlines how the TargetRetriever works when initialized with an URL pointing to and index server. However, 
as indicated it also accepts service URLs in which case the TargetRetriever will try to register the service and if allowed 
read all its details through the InterrogateTarget method.

\chapter{Job Submission and Management}
\label{sec:JobManagement}
\section{Submission}
Job submission starts with the resource discovery and target preparation as outlined in the section above. Not before a list 
of possible targets (which allows the user) is available is the job description read in order to enable bulk job submission of 
widely different jobs without having to reperform the resource discovery. The job submission makes use of the following classes:

\begin{itemize}
\item{{\bf Broker} is not yet implemented and thus not described here.}

\item{{\bf JobDescription} is responsible for handling all job descriptions. Thus it is capable of handling the xRSL, JDL and 
JSDL job description languages and to some extent also translate between them. Validation (syntax and semantical) is performed 
automatically when the source is set. Features easy retrieval of list of local input files which should be uploaded to the 
computing service.}

\item{{\bf Submitter} is base class for grid specific specializations (plugin).  It submits job(s) to a service and 
uploads (by the job needed) local input files. Returns an XML node containing all needed information about the job 
for later job management. The Submitter is returned by the ExecutionTarget selected for job execution and thus the 
ExecutionTarget populates (through XML config element) the Submitter with information about submission endpoint (URL) 
and job description languages ``spoken'' by the target.}

\end{itemize}

\begin{figure}[ht]
\centering{{\scalebox{0.75}{\includegraphics{JobSubmission.png}}}
\caption{\label{fig:JobSub}Diagram depicting the process of submitting a job to a computing service, including finding the 
best possible resource for the job.} }
\end{figure}

Figure \ref{fig:JobSub} shows a job submission sequence and below a description of each step is given:

\begin{enumerate}
\item{The TargetGenerator has prepared a list of targets. Depending on the URLs provided to the TargetGenerator the list of 
found targets may be empty or contain several targets. Targets may even represent more than one grid flavour. The list of 
found targets are taken as input to the Broker.}
\item{In order to choose between services the Broker needs to know the specific job requirements, thus the JobDescription is 
needed as input to the brokering process.}
\item{The broker outputs a ordered list of ExecutionTargets according to the provided JobDescription.}
\item{As explained in Section~\ref{sec:TargetDiscovery} each ExectionTarget has a method to return a specialized Submitter 
capable of submitting jobs to the service it represents. Thus the best suitable ExecutionTarget for the job is asked to return 
a Submitter for the submission.}
\item{The Submitter takes the JobDescription as input and uploads it to the computing service.}
\item{The Submitter identifies local input files from the JobDescription and uploads them to the computing service.}
\end{enumerate}

\section{Management}
Information about active jobs is stored in a local xml file which is used for later job management. As this file may contain 
information about jobs running on completely different grid flavours, job management should be handled using plugins similar to 
resource discovery and job submission. The following classes are used:

\begin{itemize}
\item{{\bf JobSupervisor} is responsible for loading the appropriate JobController for managing a job running on a specific 
grid flavour. In order to match a job identification string (jobid) with a grid flavour a lookup in the local xml file is 
performed. The JobSupervisor main functionality is to return a list of JobControllers which are capable of managing all jobs 
addressed by a certain command.}

\item{{\bf JobController} is both base class for grid specific specializations, but also the implementor of all public functionality 
offered by the JobControllers. In other words all virtual functions of the JobController are private. Upon initialization the 
JobController reads into and fills a local store of jobs called JobsStore.
The public functions of the 
JobController offer to get (download), clean, cancel, etc one or more jobs and uses the private specializations for issueing the command. 
This ensures consistency in how the commands are handled }

\item{{\bf Job} is }
\end{itemize}

\chapter{Data Management}
\label{sec:DataManagement}

\chapter{Specialized Classes (Grid Flavour Plugins)}
\label{sec:plugins}
\section{ARC0 Plugins}
\section{ARC1 Plugins}
\section{gLite Plugins}

\chapter{Building Command Line Interfaces}
\label{sec:cli}

\bibliography{grid}
\end{document}
