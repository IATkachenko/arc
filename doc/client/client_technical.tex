\documentclass{book}
%\documentclass{article}                            %for shorter notes
\usepackage{graphicx}                              %for PNG images (pdflatex)
%\usepackage{graphics}                              %for EPS images (latex)
\usepackage[linkbordercolor={1.0 1.0 0.0}]{hyperref} %for \url tag
\usepackage{color}                                 %for defining custom colors
\usepackage{framed}                                %for shaded and framed paragraphs
\usepackage{textcomp}                              %for various symbols, e.g. Registered Mark
\usepackage{geometry}                              %for defining page size
\usepackage{longtable}                             %for breaking tables
%
\geometry{verbose,a4paper,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2cm}
\hypersetup{
  pdfauthor = {Author Name},
  pdftitle = {Paper title},
  pdfsubject = {Paper subject},
  pdfkeywords = {Paper,keyword,comma-separated},
  pdfcreator = {PDFLaTeX with hyperref package},
  pdfproducer = {PDFLaTeX}
}
%
\bibliographystyle{IEEEtran}                       %a nice bibliography style
%
\def\efill{\hfill\nopagebreak}%
\hyphenation{Nordu-Grid}
\setlength{\parindent}{0cm}
\setlength{\FrameRule}{1pt}
\setlength{\FrameSep}{8pt}
\addtolength{\parskip}{5pt}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\arraystretch}{1.3}
\newcommand{\dothis}{\colorbox{shadecolor}}
\newcommand{\globus}{Globus Toolkit\textsuperscript{\textregistered}~2~}
\newcommand{\GT}{Globus Toolkit\textsuperscript{\textregistered}}
\newcommand{\ngdl}{\url{http://ftp.nordugrid.org/download}~}
\definecolor{shadecolor}{rgb}{1,1,0.6}
\definecolor{salmon}{rgb}{1,0.9,1}
\definecolor{bordeaux}{rgb}{0.75,0.,0.}
\definecolor{cyan}{rgb}{0,1,1}
%
%----- DON'T CHANGE HEADER MATTER
\begin{document}
\def\today{\number\day/\number\month/\number\year}

\begin{titlepage}

\begin{tabular}{rl}
\resizebox*{3cm}{!}{\includegraphics{ng-logo.png}}
&\parbox[b]{2cm}{\textbf \it {\hspace*{-1.5cm}NORDUGRID\vspace*{0.5cm}}}
\end{tabular}

\hrulefill

%-------- Change this to NORDUGRID-XXXXXXX-NN

{\raggedleft NORDUGRID-XXXXXXX-NN\par}

{\raggedleft \today\par}

\vspace*{2cm}

%%%%---- The title ----
{\centering \textsc{\Large Paper title}\Large \par}
\vspace*{0.5cm}
    
%%%%---- A subtitle, if necessary ----
{\centering \textit{\large Paper subtitle}\large \par}
    
\vspace*{1.5cm}
%%%%---- A list of authors ----
    {\centering \large Paper author\footnote{authors@address} \large \par}
    
%%%%---- An abstract - if style is article ----
%\begin{abstract}
%The abstract
%\end{abstract}
\end{titlepage}

\tableofcontents                          %Comment if use article style
\newpage
\chapter{Preface}
\label{sec:intro}

This document describes from a technical viewpoint a plugin based client library for the new 
Web Service (WS) based Advanced Resource Connector (ARC) middleware. The library consists of 
a set of C++ classes for 

\begin{itemize}
\item{handling proxy, user and host certificates,}
\item{performing resource discovery and information retrieval,}
\item{job submission and management and}
\item{data handling.}
\end{itemize}

All capabilities are enabled for three different grid flavours (Production ARC, ARC1 and gLite) 
through the modular design using plugins specialized for each supported middleware. Future 
extensions to support additional middlewares involve plugin compilation only i.e. no recompilation 
of main libraries or client.

Using the library a set of command line tools have been built which puts the library's functionality 
at the fingertips of users. While this documentation will illustrate how such command line tool can be 
built, the main documention of the command line tools is given in the client user manual [ref].

In the following we will give a functionality overview in Section~\ref{sec:FuncOver} while all technical 
details will be given in Section~\ref{sec:Implementation}. Section~\ref{sec:cli} will through examples 
show how command line interfaces can be built upon the library.

\chapter{Functionality Overview}
\label{sec:FuncOver}
The new ARClib makes extensive use of plugins for command handling. These plugins are handled by a set 
of higher level classes which thus are the ones to offer the plugin functionality to external calls. In 
this section an overview of the library's main functionality is given which also introduces the most 
important higher level classes.
\section{Resource Discovery and Information Retrieval}
\label{sec:TargetDiscovery}
With the increasing number of grid clusters around the world, a reliable and fast resource discovery and 
information retrieval capability is of crucial importance for a user interface. The new ARClib resource 
discovery and information retrieval component consists of three classes; The TargetGenerator, the 
TargetRetriever and the ExecutionTarget. Of these the TargetRetriever is a base class for further grid 
middleware specific specialization (plugin).

Figure \ref{fig:ResDisc} depicts how the classes work together in a command chain to discover all resources 
registered with a certain information server. Below a description of each step is given:

\begin{figure}[ht]
\centering{{\scalebox{0.75}{\includegraphics{TargetDiscovery.png}}}
\caption{\label{fig:ResDisc}Diagram depicting the process of resource discovery and information retrieval.} }
\end{figure}

\begin{enumerate}
\item{The TargetGenerator takes three URL arrays as input. First array contains individually selected clusters, while the 
second array contains individually selected index servers (1a). The last array contains a list of rejected clusters. This 
list is parsed through alias resolve before being inserted as filter to the storage of found services (1b).}
\item{The complete list of URLs pointing to services and index servers.}
\item{For each URL a TargetRetriever plugin is loaded using the HED ? loader. The TargetRetriever is initialized 
with the URL and the information about wether the URL points to a service or an index server.}
\item{An external call is received calling for targets to be prepared. Call is propagated to all loaded TargetRetrievers.}
\item{The call for targets is processed by each TargetRetriever in parallel. If the TargetRetriever is initialized with an 
index server URL it first registers at the Index Servers store kept by the TargetGenerator. If allowed to register, data 
is read out from the server and processed.}
\item{The TargetRetriver finds a registered service and contacts the Found Services store kept by the TargetGenerator to check 
if the service in question has been found be another TargetRetriever. (Services often registers at more than one index server, 
thus different TargetRetrievers may discover the same service.)}
\item{If registered in the Found Services store the TargetRetriever progresses to interrogate the service.}
\item{Found and processed ExecutionTargets are stored in the Found Targets store kept by the TargetGenerator for later usage 
(e.g. status printing or job submission).}
\item{Index servers often registers with other index servers creating a nested hierarchical information structure. For this 
reasons a TargetRetriever interpreting the read out result from an index server may encounter other index servers. In that 
event the TargetRetriever calls itself recursively creating a new thread for the new URL. This ensures optimum speed and 
performance for resource discovery.}
\end{enumerate}

The example above outlines how the TargetRetriever works when initialized with an URL pointing to and index server. However, 
as indicated it also accepts service URLs in which case the TargetRetriever will try to register the service and if allowed 
read all its details through the InterrogateTarget method.

\section{Job Submission}
\label{sec:JobSubmission}
Job submission starts with the resource discovery and target preparation as outlined in the section above. Not before a list 
of possible targets (which allows the user) is available is the job description read in order to enable bulk job submission of 
widely different jobs without having to reperform the resource discovery. The job submission makes use of the following classes:

\begin{figure}[ht]
\centering{{\scalebox{0.75}{\includegraphics{JobSubmission.png}}}
\caption{\label{fig:JobSub}Diagram depicting the process of submitting a job to a computing service, including finding the 
best possible resource for the job.} }
\end{figure}

Figure \ref{fig:JobSub} shows a job submission sequence and below a description of each step is given:

\begin{enumerate}
\item{The TargetGenerator has prepared a list of targets. Depending on the URLs provided to the TargetGenerator the list of 
found targets may be empty or contain several targets. Targets may even represent more than one grid flavour. The list of 
found targets are taken as input to the Broker.}
\item{In order to choose between services the Broker needs to know the specific job requirements, thus the JobDescription is 
needed as input to the brokering process.}
\item{The broker outputs a ordered list of ExecutionTargets according to the provided JobDescription.}
\item{As explained in Section~\ref{sec:TargetDiscovery} each ExectionTarget has a method to return a specialized Submitter 
capable of submitting jobs to the service it represents. Thus the best suitable ExecutionTarget for the job is asked to return 
a Submitter for the submission.}
\item{The Submitter takes the JobDescription as input and uploads it to the computing service.}
\item{The Submitter identifies local input files from the JobDescription and uploads them to the computing service.}
\end{enumerate}

\section{Job Management}
Information about active jobs is stored in a local xml file which is used for later job management. As this file may contain 
information about jobs running on completely different grid flavours, job management should be handled using plugins similar to 
resource discovery and job submission. The following classes are used:

\section{Data Handling}
\label{sec:DataHandling}

\chapter{Implementation}
\label{sec:Implementation}
Clever text here.
\section{Generic Classes}
\subsection{TargetGenerator} The TargetGenerator is responsible for loading TargetRetriever plugins in accordance with the 
input URLs. e.g. if an URL pointing to an ARC1 resource is given the TargetRetrieverARC1 is loaded. When queried for resources 
(``targets'') the TargetGenerator passes the request to the loaded TargetRetrievers running them as individual threads 
for improved performance. The TargetGenerator keeps records of by TargetRetriever found servers and services 
(index or computing) in order to avoid multiple queries. Accepted targets are stored in the FoundTargets array kept by 
the TargetGenerator.

\subsection{TargetRetriever} The TargetRetriever is base class for TargetRetriever grid middleware specializations. Contains the pure 
virtual method GetTargets which is to be implemented by the specialized class. While it is not mandatory it is recommended 
that the specialized class divides this function into two components: QueryIndex and InterrogateTarget. The former is 
responsible for querying index servers, and if the result yields an addresss to a different index server then the 
specialized TargetRetriever should call itself recursively with the found url. Discovered computing services are sent 
to the InterrogateTarget function (or if the TargetRetriever was initialized with a computing service url then it should 
jump directly to this point) which collects the detailed information about the service.

\subsection{ExecutionTarget} The ExecutionTarget is the class representation of a computing resource (queue) capable of running a grid job. It
serves as input to the broker which is foreseen to be able to select between different ExecutionTargets from different 
grid flavours without apriori knowing their difference. The ExecutionTarget class mimics the glue2 information model (with 
a flattened structure), and thus a mapping between attributes from other information systems into the glue2 format is needed. 
Appendix XX shows the current mapping for the production ARC, ARC1 and gLite middlewares. All information can be printed by 
invoking the ExecutionTarget's ``Stat'' command which prints all variables (if they have been filled during the information 
retrieval process).

Following a broker decision jobs are to be submitted. Since all information about the selected computation resides within the 
selected ExecutionTarget, the ExecutionTarget is capable of returning a submitter (see next section) capable of submitting a 
job to the resource which is represents.

\subsection{Broker} is not yet implemented and thus not described here.

\subsection{JobDescription} The JobDescription is responsible for handling all job descriptions. Thus it is capable of handling the xRSL, JDL and 
JSDL job description languages and to some extent also translate between them. Validation (syntax and semantical) is performed 
automatically when the source is set. Features easy retrieval of list of local input files which should be uploaded to the 
computing service.

\subsection{Submitter} Submitter is base class for grid specific specializations (plugin).  It submits job(s) to a service and 
uploads (by the job needed) local input files. Returns an XML node containing all needed information about the job 
for later job management. The Submitter is returned by the ExecutionTarget selected for job execution and thus the 
ExecutionTarget populates (through XML config element) the Submitter with information about submission endpoint (URL) 
and job description languages ``spoken'' by the target.

\subsection{JobSupervisor} is responsible for loading the appropriate JobController for managing a job running on a specific 
grid flavour. In order to match a job identification string (jobid) with a grid flavour a lookup in the local xml file is 
performed. The JobSupervisor main functionality is to return a list of JobControllers which are capable of managing all jobs 
addressed by a certain command.

\subsection{JobController} is both base class for grid specific specializations, but also the implementor of all public functionality 
offered by the JobControllers. In other words all virtual functions of the JobController are private. Upon initialization the 
JobController converts the information stored in the local XML to Jobs which are stored in a JobControler internal store called JobsStore. 
The public functions of the JobController offer to get (download), clean, cancel, etc one or more jobs and uses the private specializations 
for issueing the command. This ensures consistency in how the commands are handled between the different grid flavours. Jobs that are 
permanently removed following a command are removed from both the JobStore and local xml file. Thus it is foreseen that the JobControllers 
may be used in a future graphical user interface where it becomes a persistent object continously monitoring jobs.

\subsection{Job} is generic job class for storing all job related information. Attributes are derived from the glue2 information model 
and thus a mapping is needed for non glue2 compliant grid middlewares. Appendix XX shows the present mapping schema.

\subsection{UserConfig}

\section{Specialized Classes (Grid Flavour Plugins)}
\label{sec:plugins}
\subsection{ARC0 Plugins}
\subsection{ARC1 Plugins}
\subsection{gLite Plugins}

\section{Support Classes}
\subsection{URL}
\subsection{Logger}

\chapter{Building Command Line Interfaces}
\label{sec:cli}

\bibliography{grid}
\end{document}
