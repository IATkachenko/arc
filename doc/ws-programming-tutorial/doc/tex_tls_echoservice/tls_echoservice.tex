\chapter{TLS echoservice}

The web services of the previous chapters have one mayor drawback: the communication between the two endpoints is insecure.
For that reason the current and the next chapter will discuss how to create a secure web service.
In general, security in a network can be subdivided into the following categories:~\cite{TANNENBAUM_2001}\task{verfiy citation}
\begin{itemize}
	\item \textbf{Confidentiality} --- Protection of the data against passiv attacks (such as publicise message content)
	
	\item \textbf{Authentication} --- Verification of the Authenticity  of the communications partner.

	\item \textbf{Integrity} --- Protection against interception and manipulation,replay,insertion, etc.  of a message.

	\item \textbf{Non-repudiation} --- Preventing the sender to repudiate the message transmitted by him.

	\item \textbf{Access control} --- Restrict the access to ressources.

	\item \textbf{Availability} --- Ensure a system is always usable which is challenged by several attacks.

\end{itemize}
%1-21   Gebräuchliche Dienste
%     Identifizierung           Vermerk
%     Berechtigung              Zugriff
%     Lizenz/Zertifizierung     Gültigkeitsprüfung
%     Unterschrift              Zeitpunkt des Auftretens
%     Bezeugung                 Abstimmung
%     Übereinstimmung           Eigentum
%     Zuverlässigkeit           Registrierung
%     Quittungen                Genehmigung/Verbot
%     Bestätigung des Ursprungs Privatsphäre
%
% Nach Sicherheit in verteilten Systemen, ITM Lübeck
Ideally, all six categories should have been achieved by such an application (though the last category, availability, is difficult to realise).
In the present chapter, the security will be put into practice by extending the protocol stack with an additional security layer called TLS (Transport Layer Security).
Due to the location after the TCP and the HTTP layer, the layer is only capable to limit the access to the grid to a certain set of users.\task{What do you mean here? SM}
Nevertheless, it provides the security categories: confidentiality, authentication, integrity, non-repudiation and access control.


In the next section gives a basic understanding of the working principale of the TLS. Emphasis is put on the security concept and not on an exact description of the technical realisation in order to enable newcomers an entry to  this area.


% It is recommand to satifiy as much categories as possible. 
%authentication , confidentiality and integrity protection of TCP-based communication --- non-repudiation due to private key, access control to our service.


\section{Transport Layer Security}


The TLS is a protocol which provides a secure connection between two endpoints.
It is based directly on the TCP/IP layers and uses typically an asymmetric encryption to establish the connection (alternatively a symmetric pre-shared key may be used).
After the communication has been successfully established, both participants are switching to another encryption method which is based on a new negotiated symmetric key.
%    1. Peer negotiation for algorithm support
%    2. Key exchange and authentication
%    3. Symmetric cipher encryption and message authentication   - from wikipedia
%
%


Symmetric and asymmetric encryption are the two main classes of cryptographic algorithms.
In case of symmetric encryption, both participants are holding the same secret key to encrypt and decrypt a plain text.
The principle is to reverse the process of encryption for decrypting the text.
Symmetric encryption can be ranked as being very secure but its downside is that the key distribution is very difficult in practice.
The key has to be shared previously, ideally over a secure channel which is may either be a complete diffrent medium (i.e. a letter, speech) or a channel which has been encrypted with another secret key.
Asymmetric encryption follows a diffrent functional principle.
While the symmetric encryption utilise one shared secret, the asymmetric ecryption is based on two keys: a private key and public key.
As the names imply, the private key is kept secret and is never shared while the public key is available to everyone.
Messages encrypted with the public key can only be decrypted with the private key and conversely, messages encrypted with the private key can only be decrypted with the public key. 
The Figure~\ref{fig:asymmetric_encryption} illustrates the circumstances of the case.
\begin{figure}[htb]
	\centering%epstopdf async.eps
	\subfloat[Texttext\label{fig:cgd}]
		{\includegraphics[width=12cm]{tex_tls_echoservice/async.pdf}}\\
	\subfloat[Texttext\label{fig:cgd}]
		{\includegraphics[width=12cm]{tex_tls_echoservice/async2.pdf}}
	\label{fig:asymmetric_encryption}
	\mycaption{specific}{general}
\end{figure}
\task{Maybe the term service has to be replaced by server}

At startup of the communication process, A (Alice) who desires a secure connection transmits her public key to B (Bob).
Bob is now able to encrypt his messages such that only Alice is able to decrypt them.
As one can see, this first approach already provides confidentiality and integrity of messages.

Neither Non-repudiation, authentication and consequently nor access control are established because the identity of Alice is not proven.
In order to be able to check identities, so called certificates have been introduced.
Certificates render the possibility to validate the identity of its owner.
They are signed by a certificate authority (CA), the identity of which can be verified by another CA or that is pre-configured to be trusted.

A certificate is composed of the identity of the owner, his public key, the name of the CA who signed the certificate and the signature of the CA which is a hash-value of the certificate encrypted with the private key of the CA. 
Furthermore, the algorithms used to create the certificate are added.
If a certificate can be resolved to a trusted CA, the identity of the certificate owner is considered to be proven. 
In general, a set of trusted CAs is already defined in the operation system.
To obtain a certificate, a certificate request has to be submitted to a CA.
The CA verifies the identity of the requesting person and the requested certificate will be signed.
Figure~\ref{fig:certificate_request} shows the procedure of gaining a certificate.
For instructions on the actual commands on the UNIX shell, you may follow instructions on \url{http://ca.nordugrid.org}.
\begin{figure}[htb]
	\centering%epstopdf certificates.eps
 	\includegraphics[width=13cm]{tex_tls_echoservice/certificates.pdf}
	\mycaption{specific}{general}
	\label{fig:certificate_request}
\end{figure}
In the first step, a private and a public key will be generated by the requester.
The public key together with a textual description of the identity depict the request which will be transmitted to a CA.
After the CA successfully verified the validity of the request, the identity of the CA and the name of the used encryption algorithms are added.
The collected data will represent the plain text of the certificate.
In order to ensure the integrity of the text, a hash value will be created.
This is a fixed-sized short string which is generated by an algorithm based on an arbitrary long given text.
The algorithm is designed such that a small change in the text will cause the hash value to change almost like a random function.
Thus, the hash value can be used a fingerprint of the text.
The CA signs the plain certificate by encrypting its hash value with its private key.
Finally the signed certifcate will be returned to the requester.
If an outside person wants to verify the certificate owner, the encrypted hash value has to be decrypted by the public key of the CA and a hash value has to be created with the same algorithm in order to compare them.


Figure~\ref{fig:verification_of_certificates} shows a usecase in which Alice wants to resolve the identity of Bob.
Alice submits her request to Bob along with a challange consisting of a random number $n$. 
The random number ensures that it is not possible to repeat a message (integrity).
Bob encrypts the number with his private key and returns it together with his certificate.
Alice uses the public key of Bob to decrypt the challenge. 
If the decrypted number is equal to the transmitted number, Alice can reason that the identity of Bob is to be trusted in case she is trusting the CA which has signed Bobs certificate. 

In the given example, Alice only trusts the CA 2 but not CA 1.
To resolve the identity of CA 1, Alice establishes a connection to CA 1 and submits another random number $n$ as a challenge.
The CA 1 encrypts the challenge with its private key and sends the result along with its certificate back to Alice.
Alice successfully validates the certificate of CA 1.
Since the certificate was signed by CA 2 which is pre-configured to be trusted, she als trusts CA 1 and in conclusion the identity of B.
In summary, Alice knows she is talking to Bob.
If Bob also wants to be sure who he's talking to, then the same procedure has to be done to confirm the identity of Alice.
The TLS mode in which both endpoints are ensuring themselves to whom they are talking to is called \textit{bilateral connection mode}.


When the client is aware of the service authentity, the confidential treatment of his data is given such that one can be sure the data won't be revealed to a third party (service-sided confidentiality). 
On the other side, if the service is aware of the client authentity, the access to the service can be controlled (access control) and the service can verify that the results will only be passed back to the right person (client-sided confidentiality). 
As one can see confidentiality, authentication, integrity and non-repudiation are now given.

\begin{figure}[htb]
	\centering%epstopdf verification.eps 
	\includegraphics[width=13cm]{tex_tls_echoservice/verification.pdf}
	\mycaption{specific}{general}
	\label{fig:verification_of_certificates}
\end{figure}

Certificates have several advantages.
They are scaling very good with the amount of users because CAs can create new sub-CAs such that the load is balanced (certificates of a CA may be cached).
Furthermore no critical information is exchanged during the establishment of a connection (in particular no secret key is shared which may get intercepted).
Instead, a set of pre-configured CAs which will be in general provided by the operation system is needed.
In respect of ARC it is obvious that the access to the grid shall be under control of its administrator.
To do so, the administrators have to establish their own CA such which is in charge of creating certificates for a set of users.
Many universities have prepared local certificate authorities.
And every user can establish his own. 

The identity of the created CA have to be added to the directory of pre-configured CAs.
The ARC source code comes with two shell scripts to create a CA and related certificates.
Several publicly availble tools for certificate handling haven been prepared, e.g. (like \textit{openssl}),
which allow the certificate handling also for the advanced UNIX users.
Certificates in general, however, have found entry to regular computer users, for instance with the FernUniversity Hagen (https://ca.fernuni-hagen.de/) who use that technology for their remote students to hand in exercises.

A CA which controls the access to a grid can be considered as a virtual organsiation (VO).
It may involve organisations close to the leading organisation as well as structure which are not formally associated with it.
In most cases the basic idea is to share ressources. \task{this para will need some overhaul - SM}

\clearpage
\section{Service}

In order to create a secure bilateral connection we hence need two certificates: a client certificate and a service certificate.
The CA for the certificate has to be pre-configured on the counterpart and furthermore, the owner of the certificate has to hold the fitting private key. 
Altogether six files are needed:
\begin{tabular}{l@{-}p{9cm}}
clientCA   & The CA which guarantees for the identity of the client \\
clientCERT & The certificate of the client. \\
clientKEY  & Secret key of the client to read messages, encrypted by the public key in the certificate! \\
\\
serverCA   & The CA which guarantees for the identity of the server \\
serverCERT & The certificate of the server. \\
serverKEY  & Secret key of the client to read messages, encrypted by the public key in the certificate! \\
\end{tabular}

The server needs: its  serverCERT and serverKEY and some kind of root CA knowing the client.
Client needs its clientCERT and clientKEY and some kind of root CA knowing the server.

\task{RENAMING into~ARC service configuration file}
\task{echo service client configuration file}

%The first two goals can be reached by encrypting the channel/connection between client and server. An approach 
%sich bewähren / behaupten
%which stand the test of time is to introduce a TLS (Transport Layer Security) also known as SSL (Secure Sockets Layer).
%Authenticity, Confidentiality, Integrity
%The client wants to reassure himself to send his vulnerable data only to the server who can prove its correct identity.
%Furthermore a prove of authenticity is needed. % Sich versichern, dass das Gegenüber der ist, für welchen er sich ausgibt
%It .... does fancy stuff ...
%
%
%Authorization:  The server on the other side takes an interest in limitate its ressources to a close circle of users. Above all no %foreign clients shall be able to use the services.\\

One can add the TLS in client and server by simply extending the arched configuration file and a small modification of the client.

WARNING: If the program fails, check if one of your certificates has expired.
If so, create new one using the script files in the directory 'certFactory'.

Chalked up to the modularity of HED, the security can easily be extend to our given example.
Each Message Chain Component (MCC) or service has a common interface for implementing various pluggable components (plug-ins) called SecHandler.
The SecHandler components provide a method for processing messages traveling through Message Chains of the HED. 

Each MCC or Service usually implements two queues of SecHandlers – one for incoming messages and one for outgoing, which are called “incoming” and “outgoing”, respectively.
All SecHandler components attached to the queue are executed sequentially. 
If any of them fails, message processing fails as well. 
Each SecHandler is configured inside the arched configuration file that is used for configuring whole chain of MCCs 
Some of the currently implemented SecHandler components make use of pluggable and configurable sub-modules called Policy Decision Point (PDP).
PDPs can process ARC specific Request and Policy documents which are also written in XML format~\cite{QIANG_2008}..


4 types:
                <KeyPath>./clientKey.pem</KeyPath>
                <CertificatePath>./clientCert.pem</CertificatePath>
                <CACertificatePath>./serviceCA.pem</CACertificatePath>

\lstsetCPP
\lstinputlisting
	[
	label=lst:tls_echo_service_cpp,
	caption={[HED configuration file for the Arc intern echo service. Filename: arcecho\_no\_ssl.xml]
	\textbf{HED configuration file for the Arc intern echo service. Filename: arcecho\_no\_ssl.xml\textcolor{white}{hmf}}}
	]
{../src/services/tlsechoservice/tlsechoservice.cpp}




\lstsetARCHEDXML
\lstinputlisting
	[
	label=lst:tls_echo_arched_xml,float=htb,
	caption={[HED configuration file for the Arc intern echo service. Filename: arcecho\_no\_ssl.xml]
	\textbf{HED configuration file for the Arc intern echo service. Filename: arcecho\_no\_ssl.xml\textcolor{white}{hmf}}}
	]
{../src/services/tlsechoservice/arched_tls_echoservice.xml}


\lstsetKSH
\begin{lstlisting}[
label=lst:tls_echo_arched_invoke,float=htb,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
$ rm -f /var/log/arched.log
$ arched -c arched_echoservice.xml  && echo jo ||echo n
$ tail -n100 -f /var/log/arched.log
$ killall arched
\end{lstlisting}




\clearpage
\section{Client}

\lstsetCPP
\lstinputlisting
	[
	label=lst:tls_echo_client_cpp,
	caption={[HEC configuration file]
	\textbf{HEC configuration file\textcolor{white}{hmf}}}
	]
{../src/clients/tlsechoclient/tlsechoclient.cpp}



Folgender XML Aufruf und Antwort soll \textit{automatisch} generiert werden:

%[caption={[]WegDamit},language=XML,basicstyle=\scriptsize,breaklines=true,label=lst:request] 





Zertifikate
Zustände (Nutzer wiedererkennen, arbeit aufnehmen)




\lstsetKSH
\begin{lstlisting}[
label=lst:tls_echo_client_invoke,float=htb,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
$ ./echoclient
Tue Feb 17 17:04:08 2009
\end{lstlisting}






\lstsetJUSTXML
\begin{lstlisting}[
label=lst:tls_echo_request_XML,float=htb,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
<soap-env:Envelope xmlns:tlsecho="urn:tlsecho" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <tlsecho:tlsechoRequest>
      <tlsecho:say operation="ordinary">text_to_be_transmitted</tlsecho:say>
    </tlsecho:tlsechoRequest>
  </soap-env:Body>
</soap-env:Envelope>
\end{lstlisting}






\lstsetJUSTXML
\begin{lstlisting}[
label=lst:tls_echo_response_XML,float=htb,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
<soap-env:Envelope xmlns:tlsecho="urn:tlsecho" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <tlsecho:tlsechoResponse>
      <tlsecho:hear>[ text_to_be_transmitted ]</tlsecho:hear>
    </tlsecho:tlsechoResponse>
  </soap-env:Body>
</soap-env:Envelope>
\end{lstlisting}

