\chapter{The time webservice}


The first implementation of a Web Service which will be presented in this tutorial realises a simple time service.
In case the service receives a request, it will respond with a string containing the systemtime.
For simplicity the service will not parse the request but always return the current time.
In the following subsections the C++ implementation first the service and than the client will be developed.


\section{Service}

In Arc-1 the services are implementated as plugins such that they can easily be included by modifiying the HED configuration file as it was to be seen in Listing~\ref{lst:arched_arcecho_xml}.
The Listing~\ref{lst:time_arched_cpp}.shows the implementation of the time service plugin.
The proper class definition is defined in the corresponding header file which isn't shown here.
The key element for each plugin is the struct PluginDescriptor named PLUGINS\_TABLE\_NAME, see line\ref{lst_code:time_cpp_ptn}. 
%The struct defines basic entities of the service and provides a pointer to the method which is able to create an instance of the time service plugin. 
Within the struct a unique plugin name, the type of the plugin, its version and the pointer to the function which returns the time service instance has to be defined.
The function which returns the pointer to an instance of the service needs to have the PluginArgument as a parameter. 
The actual Time Web Service is implemented within the namespace ArcService. The constructor can be found in line~\ref{lst_code:time_cpp_constructor}, the deconstructor in line~\ref{lst_code:time_cpp_deconstructor} and the method required by the inherited class \textit{Service} file in line~\ref{lst_code:time_cpp_process}. For the Time service is very simple, only the function process needs to be implemented. It gets the incoming and the outgoing message as references and returns a class representing the status the service achieved. 
\lstsetCPP
\lstinputlisting
	[
	label=lst:time_arched_cpp,
	caption={[C++ implementation of the time service. Filename: timeservice.cpp]
	\textbf{C++ implementation of the time service. Filename: timeservice.cpp}}
	]
{../src/services/timeservice/timeservice.cpp}
The service first determines the current time and than creates a SOAP message using the object \textit{PayloadSOAP} on line~\ref{lst_code:time_cpp_process_payloadSOAP}. The class \textit{PayloadSOAP} is able to create a XML message which is conform to the SOAP protocol (The apperance of the generated request and response will be discussed later). I case of the presented time service the payload consists out of two elements nested into one another. The element \textit{text} holds the element child which again holds the string containing the current time.
Within the line~\ref{lst_code:time_cpp_process_message_payload} the payload is passed to the message. 
The message processing is now completed and the function returns its success status on line~\ref{lst_code:time_cpp_return}.
The source code has to be compiled to a dynamic library named \textit{libtimeservice.so}.\\


After the service has been implemented and compiled, it needs to be loaded into the HED. A suitable HED configuration file is to be seen in Listing~\ref{lst:time_arched_xml}. 
\lstsetARCHEDXML
\begin{program}
\lstinputlisting
	[
	label=lst:time_arched_xml,
	caption={[HED configuration for the time service. Filename: arched\_timeservice.xml]
	\textbf{HED configuration for the time service. Filename: arched\_timeservice.xml}}
	]
{../src/services/timeservice/arched_timeservice.xml}
\end{program}
A new path element has been introduced into the element \textit{ModuleMananger}, line~\ref{lst_code:arched_time_moduleManager}. It assigns the location to the compliled dynamic library. 
On line~\ref{lst_code:arched_time_plugin} the library is explict mentioned to be loaded.
Another important change has been done within the \textit{Plexer} element in line~\ref{lst_code:arched_time_plexer_next}. A rule has been introduced which redirects the request to the Time Web Service, if the path of URL is \textit{time}.\\


To run the service again the arched command shown in~\ref{lst:arched_timeservice_ksh} has to be used.
\lstsetKSH
\begin{program}
\begin{lstlisting}[
label=lst:arched_timeservice_ksh,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
$ arched -c arched_timeservice.xml && echo Daemon started || echo Daemon start failed
Daemon started
\end{lstlisting}
\end{program}



\section{Client}

\task{\#ifdef HAVE\_CONFIG\_H\#include <config.h>\#endif - habe ich entfernt... macht keinen Sinn, da keine weiteren Macros im Source Code enthalten sind... oder?}
In the next step a simple client needs to be implemented whose task is to interprete the returned message of the client.
The client needs to have the same protocol stack as the daemon but in contrast to it, it does not need the ability to be loaded as a plugin. As one will see, the creation of this protocol stack on client side is very simple.
The source code of the client consists primarily of the main function and is to be seen in Listing~\ref{lst:time_client_cpp}.
In line~\ref{lst_code:time_client_cpp_logger} the logger is initialized and redirected to the standard error stream.
For the components of the protocol stack are likewise loaded dynamically, one need to specify the installation directory in line~\ref{lst_code:time_client_cpp_init} too.
\task{remark in \textbf{introduction}, what the plexer is for. In our case: to have several services running on one port!!!!!!!!}
The URL of the service is defined in line~\ref{lst_code:time_client_cpp_url}. It fits to the HED configuration file which was shown in Listing~\ref{lst:time_arched_xml}. The daemon is listing on port 60000 and is running on the localhost. The service itself uses HTTP and can be reached by using the path \textit{time}.
Line~\ref{lst_code:time_client_cpp_config} loads the standard config file which is usually almost empty. As a result, no additional security procedures will later be linked into the client sided stack. The protocol stack is created in line~\ref{lst_code:time_client_cpp_client}. Thanks to the URL the information for the configuration can be completed.
The constructor of the class \textit{ClientSOAP} creates a SOAP client which uses HTTP, addresses the port 60000 on localhost. If i.e. HTTPS would have been used, the stack would have been extended by a TLS layer.
Now the client stack is ready, one can create a request to the service. In line~\ref{lst_code:time_client_cpp_message_reqeust} a message which corresponds to the Listing~\ref{lst:time_client_request} is created. The message gets processed by the command in line~\ref{lst_code:time_client_cpp_message_response}. If everything was fine, the message will finally be send to the standard out in line~\ref{lst_code:time_client_cpp_message_answer}.

\lstsetCPP
\lstinputlisting
	[
	label=lst:time_client_cpp,
	caption={[HED configuration file for the Arc intern echo service. Filename: arcecho\_no\_ssl.xml]
	\textbf{HED configuration file for the Arc intern echo service. Filename: arcecho\_no\_ssl.xml\textcolor{white}{hmf}}}
	]
{../src/clients/timeclient/timeclient.cpp}





The data is enveloped by an element called \textit{Envelope} .. See german wiki

\lstsetJUSTXML
\begin{minipage}[t]{\textwidth}
\begin{lstlisting}[
label=lst:time_client_request,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
<soap-env:Envelope xmlns:time="urn:time" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <time>
      <timeRequest></timeRequest>
    </time>
  </soap-env:Body>
</soap-env:Envelope>
\end{lstlisting}
\end{minipage}


\lstsetJUSTXML
\begin{minipage}[t]{\textwidth}
\begin{lstlisting}[
label=lst:time_client_response,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
<soap-env:Envelope xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <time>
      <timeResponse>Wed Feb 18 11:20:30 2009</timeResponse>
    </time>
  </soap-env:Body>
</soap-env:Envelope>
\end{lstlisting}
\end{minipage}




\lstsetKSH
\begin{minipage}[t]{\textwidth}
\begin{lstlisting}[
label=st:time_client_ksh,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
$ ./timeclient
Wed Feb 18 11:20:30 2009
\end{lstlisting}
\end{minipage}












