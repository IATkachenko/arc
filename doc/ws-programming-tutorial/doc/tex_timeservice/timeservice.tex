\chapter{The time webservice}


The first implementation of a Web Service will be a simple time service. 
In case that the service receives a request of a client, it will respond with a string containing the system time.
For simplicity the service will not parse the request but always return the current time.
In the following subsections the implementation of the service and the client will be presented. 


\section{Service}

In Arc the services are implementated as plugins such that they can easily be included or excluded by modifiying the HED configuration file as it was to be seen in Listing~\ref{lst:arched_arcecho_xml}.
Listing~\ref{lst:time_arched_cpp} contains the C++ implementation of the time service plugin.
The proper class definition of the object \textit{TimeService} is defined in the corresponding header file which is not shown here. It inherits from an object called \textit{Service} defined in the Arc library.
The key element for each plugin is the struct \textit{PluginDescriptor} named \textit{PLUGINS\_TABLE\_NAME} to be seen in line~\ref{lst_code:time_cpp_ptn}. 
%The struct defines basic entities of the service and provides a pointer to the method which is able to create an instance of the time service plugin.
Within the struct a unique plugin name, the type of the plugin, its version and a pointer to a function which returns the instance of the time service has to be defined.
The function which returns the pointer of the instance is desclared in line~\ref{lst_code:time_cpp_get_service}. 
The interface demands an object \textit{PluginArgument} as a parameter but because we are writing a plugin which inherits from \textit{Service}, we are able to expect the \textit{PluginArgument} to be a \textit{ServicePluginArgument}.
%	In the first line of the service the object is downcasted with the operator dynamic_cast
The \textit{ServicePluginArgument} provides access to the HED configuration and the message chain of the service.
%       operator Config* (void) { return config_; };
%       operator ChainContext*   			an interface to manipulate chains stored in Loader
%
%
%
%
The time service uses the namespace \textit{ArcService}. The constructor can be found in line~\ref{lst_code:time_cpp_constructor} and the deconstructor in line~\ref{lst_code:time_cpp_deconstructor}.%
\lstsetCPP%
\lstinputlisting[
	label=lst:time_arched_cpp,
	caption={[C++ implementation of the time service. Filename: timeservice.cpp]
	\textbf{C++ implementation of the time service. Filename: timeservice.cpp}}
	]%
{../src/services/timeservice/timeservice.cpp}%
In the context of the simple service they don't contribute with any functionality.
The method \textit{process} which is required by the inherited class \textit{Service} is defined in line~\ref{lst_code:time_cpp_process} and realises the desired service. 
The parameters \textit{inmsg} and \textit{outmsg} are references to the incoming and outgoing messages. Furthermore the method \textit{process} returns the object \textit{MCCStatus} which is representing the result of the service achieved. 
Within the method \textit{process}, the service first determines the current time and than creates a SOAP payload using the object \textit{PayloadSOAP} on line~\ref{lst_code:time_cpp_process_payloadSOAP}. 
The object \textit{PayloadSOAP} provides enough functionality to create a XML message which is conform to the SOAP protocol 
(The apperance of the generated request and response will be discussed later on page~\pageref{lst:time_client_request}). 
%
%
In the current case the payload consists of two elements nested into one another. The element \textit{time} holds the element \textit{timeResponse} which again holds the string containing the current time.
Within the line~\ref{lst_code:time_cpp_process_message_payload} the payload is stored in the message. 
In case nothing unexpected happened during the message is processed, the function returns with an \textit{MCCStatus} set to \textit{OK} as to be seen in line~\ref{lst_code:time_cpp_return}.\\


%The service has to be compiled into a dynamic library named \textit{libtimeservice.so}, in order
%To run the service, one has to compile the source code into a dynamic library named \textit{libtimeservice.so}.\\
%After the service is shipped into the library \textit{libtimeservice.so} it needs to be copied into the directory \textit{/tmp/arc/tutorial/lib} so it can be found by the \textit{ModuleManager} of the HED. 

In order to run the service, it has to be compiled into a dynamic library named \textit{libtimeservice.so}.
The library has be to be copied into the directory \textit{/tmp/arc/tutorial/lib} such that it can be found by the \textit{ModuleManager} of the HED.
A suitable HED configuration file which engages the time service is to be seen in Listing~\ref{lst:time_arched_xml}.A new path element has been introduced into the element \textit{ModuleMananger} in line~\ref{lst_code:arched_time_moduleManager}. It assigns the location of the created dynamic library.
On line~\ref{lst_code:arched_time_plugin} the library is explict mentioned to be loaded as a plugin.
Another important change has been done within the \textit{Plexer} element in line~\ref{lst_code:arched_time_plexer_next}. A rule has been introduced which redirects the request to the time service, if the path of URL is \textit{time}.\\ 
\lstsetARCHEDXML
\lstinputlisting
	[
	label=lst:time_arched_xml,float=htb,
	caption={[HED configuration for the time service. Filename: arched\_timeservice.xml]
	\textbf{HED configuration for the time service. Filename: arched\_timeservice.xml}}
	]
{../src/services/timeservice/arched_timeservice.xml}




To start the service the \textit{arched} command which is shown in Listing~\ref{lst:arched_timeservice_ksh} has to be used.
It is recommended to examine the log file \textit{/var/log/arched.log} if the HED configuration file has been modified in order to  assert the start was successful
%To check the start of the HED it is recommended to examine the log file \textit{/var/log/arched.log}.\\
\lstsetKSH
\begin{lstlisting}[
label=lst:arched_timeservice_ksh,float=htb,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
$ arched -c arched_timeservice.xml && echo Daemon started || echo Daemon start failed
Daemon started
\end{lstlisting}



\section{Client}

%\task{\#ifdef HAVE\_CONFIG\_H\#include <config.h>\#endif - habe ich entfernt... macht keinen Sinn, da keine weiteren Macros im Source Code enthalten sind... oder?}
In the next step a simple client needs to be implemented whose task is to interprete the returned message of the client.
The client needs to have the same protocol stack as the daemon but in contrast to it, it does not need the ability to be loaded as a plugin. As one will see, the creation of this protocol stack on client side is very simple.
The source code of the client consists primarily of the main function and is to be seen in Listing~\ref{lst:time_client_cpp}.
In line~\ref{lst_code:time_client_cpp_logger} the logger is initialized and redirected to the standard error stream.
For the components of the protocol stack are likewise loaded dynamically, one need to specify the installation directory in line~\ref{lst_code:time_client_cpp_init} too.
\task{remark in \textbf{introduction}, what the plexer is for. In our case: to have several services running on one port!!!!!!!!}
The URL of the service is defined in line~\ref{lst_code:time_client_cpp_url}. It fits to the HED configuration file which was shown in Listing~\ref{lst:time_arched_xml}. The daemon is listing on port 60000 and is running on the localhost. The service itself uses HTTP and can be reached by using the path \textit{time}.
Line~\ref{lst_code:time_client_cpp_config} loads the standard config file which is usually almost empty. As a result, no additional security procedures will later be linked into the client sided stack. The protocol stack is created in line~\ref{lst_code:time_client_cpp_client}. Thanks to the URL the information for the configuration can be completed.
The constructor of the class \textit{ClientSOAP} creates a SOAP client which uses HTTP, addresses the port 60000 on localhost. If i.e. HTTPS would have been used, the stack would have been extended by a TLS layer.
Now the client stack is ready, one can create a request to the service. In line~\ref{lst_code:time_client_cpp_message_reqeust} a message which corresponds to the Listing~\ref{lst:time_client_request} is created. The message gets processed by the command in line~\ref{lst_code:time_client_cpp_message_response}. If everything was fine, the message will finally be send to the standard out in line~\ref{lst_code:time_client_cpp_message_answer}.

\lstsetCPP
\lstinputlisting
	[
	label=lst:time_client_cpp,
	caption={[HED configuration file for the Arc intern echo service. Filename: arcecho\_no\_ssl.xml]
	\textbf{HED configuration file for the Arc intern echo service. Filename: arcecho\_no\_ssl.xml\textcolor{white}{hmf}}}
	]
{../src/clients/timeclient/timeclient.cpp}



Once the HED is running, the service can 

The data is enveloped by an element called \textit{Envelope} .. See german wiki

\lstsetJUSTXML
\begin{lstlisting}[
label=lst:time_client_request,float,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
<soap-env:Envelope xmlns:time="urn:time" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <time>
      <timeRequest></timeRequest>
    </time>
  </soap-env:Body>
</soap-env:Envelope>
\end{lstlisting}


\lstsetJUSTXML
\begin{lstlisting}[
label=lst:time_client_response,float,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
<soap-env:Envelope xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <time>
      <timeResponse>Wed Feb 18 11:20:30 2009</timeResponse>
    </time>
  </soap-env:Body>
</soap-env:Envelope>
\end{lstlisting}





\lstsetKSH
\begin{minipage}[t]{\textwidth}
\begin{lstlisting}[
label=st:time_client_ksh,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
$ ./timeclient
Wed Feb 18 11:20:30 2009
\end{lstlisting}
\end{minipage}












