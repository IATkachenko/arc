\chapter{The time webservice}


The first implementation of a Web Service will be a simple time service. 
In case that the service receives a request of a client, it will respond with a string containing the system time.
For simplicity the service will not parse the request but always return the current time.
In the following subsections the implementation of the service and the client will be presented. 


\section{Service}

In Arc the services are implementated as plugins such that they can easily be included or excluded by modifiying the HED configuration file as it was to be seen in Listing~\ref{lst:arched_arcecho_xml}.
Listing~\ref{lst:time_arched_cpp} contains the C++ implementation of the time service plugin.
The proper class definition of the object \textit{TimeService} is defined in the corresponding header file which is not shown here. It inherits from an object called \textit{Service} defined in the Arc library.
The key element for each plugin is the struct \textit{PluginDescriptor} named \textit{PLUGINS\_TABLE\_NAME} to be seen in line~\ref{lst_code:time_cpp_ptn}. 
%The struct defines basic entities of the service and provides a pointer to the method which is able to create an instance of the time service plugin.
Within the struct a unique plugin name, the type of the plugin, its version and a pointer to a function which returns the instance of the time service has to be defined.
The function which returns the pointer of the instance is desclared in line~\ref{lst_code:time_cpp_get_service}. 
The interface demands an object \textit{PluginArgument} as a parameter but because we are writing a plugin which inherits from \textit{Service}, we are able to expect the \textit{PluginArgument} to be a \textit{ServicePluginArgument}.
%	In the first line of the service the object is downcasted with the operator dynamic_cast
The \textit{ServicePluginArgument} provides access to the HED 
%       operator Config* (void) { return config_; };
%       operator ChainContext*   			an interface to manipulate chains stored in Loader
%
%
%
%
 \textcolor{white}{newline}
\lstsetCPP%
\lstinputlisting[
	label=lst:time_arched_cpp,
	caption={[C++ implementation of the time service. Filename: timeservice.cpp]
	\textbf{C++ implementation of the time service. Filename: timeservice.cpp}}
	]%
{../src/services/timeservice/timeservice.cpp}%
configuration and the message chain of the service. The time service uses the namespace \textit{ArcService}. The constructor can be found in line~\ref{lst_code:time_cpp_constructor} and the deconstructor in line~\ref{lst_code:time_cpp_deconstructor}. In the context of the simple service they don't contribute with any functionality. Only the constructor is defining the XML null-namespace for the time service.
The method \textit{process} which is required by the inherited class \textit{Service} is defined in line~\ref{lst_code:time_cpp_process} and realises the desired service. 
The parameters \textit{inmsg} and \textit{outmsg} are references to the incoming and outgoing messages. Furthermore the method \textit{process} returns the object \textit{MCCStatus} which is representing the result of the service achieved. 
Within the method \textit{process}, the service first determines the current time and than creates a SOAP payload using the object \textit{PayloadSOAP} on line~\ref{lst_code:time_cpp_process_payloadSOAP}. 
The object \textit{PayloadSOAP} provides enough functionality to create a XML message which is conform to the SOAP protocol 
(The apperance of the generated request and response will be discussed later on page~\pageref{lst:time_client_request}). 
%
%
In the current case the payload consists of two elements nested into one another. The element \textit{time} holds the element \textit{timeResponse} which again holds the string containing the current time.
Within the line~\ref{lst_code:time_cpp_process_message_payload} the payload is stored in the message. 
In case nothing unexpected happened during the message is processed, the function returns with an \textit{MCCStatus} set to \textit{OK} as to be seen in line~\ref{lst_code:time_cpp_return}.\\


%The service has to be compiled into a dynamic library named \textit{libtimeservice.so}, in order
%To run the service, one has to compile the source code into a dynamic library named \textit{libtimeservice.so}.\\
%After the service is shipped into the library \textit{libtimeservice.so} it needs to be copied into the directory \textit{/tmp/arc/tutorial/lib} so it can be found by the \textit{ModuleManager} of the HED. 

In order to run the service, it has to be compiled into a dynamic library named \textit{libtimeservice.so}.
The library has be to be copied into the directory \textit{/tmp/arc/tutorial/lib} such that it can be found by the \textit{ModuleManager} of the HED.
A suitable HED configuration file which engages the time service is to be seen in Listing~\ref{lst:time_arched_xml}.A new path element has been introduced into the element \textit{ModuleMananger} in line~\ref{lst_code:arched_time_moduleManager}. It assigns the location of the created dynamic library.
On line~\ref{lst_code:arched_time_plugin} the library is explict mentioned to be loaded as a plugin.
Another important change has been done within the \textit{Plexer} element in line~\ref{lst_code:arched_time_plexer_next}. A rule has been introduced which redirects the request to the time service, if the path of URL is \textit{time}.\\ 
\lstsetARCHEDXML
\lstinputlisting
	[
	label=lst:time_arched_xml,float=htb,
	caption={[HED configuration for the time service. Filename: arched\_timeservice.xml]
	\textbf{HED configuration for the time service. Filename: arched\_timeservice.xml}}
	]
{../src/services/timeservice/arched_timeservice.xml}




To start the service the \textit{arched} command which is shown in Listing~\ref{lst:arched_timeservice_ksh} has to be used.
It is recommended to examine the log file \textit{/var/log/arched.log} if the HED configuration file has been modified in order to  assert the start was successful
%To check the start of the HED it is recommended to examine the log file \textit{/var/log/arched.log}.\\
\lstsetKSH
\begin{lstlisting}[
label=lst:arched_timeservice_ksh,float=htb,
caption={[Transformation in eine uniforme konzentrische Verteilung.]
         \textbf{Transformation in eine uniforme konzentrische Verteilung.\textcolor{white}{hmf}}}]
$ arched -c arched_timeservice.xml && echo Daemon started || echo Daemon start failed
Daemon started
\end{lstlisting}



\section{Client}

%\task{\#ifdef HAVE\_CONFIG\_H\#include <config.h>\#endif - habe ich entfernt... macht keinen Sinn, da keine weiteren Macros im Source Code enthalten sind... oder?}
This section is introducing the implementation of the client whose main task is to interprete the returned message.
In order to be able to communicate with the service providing daemon the client needs to use an identic protocol stack.
Likewise to the HED it will also be created dynamically using the MCCs.
But as one will see, the creation of the protocol stack on client side is very simple.
%
%
%
The source code of the client is to be seen in Listing~\ref{lst:time_client_cpp} and consists basically of one main function. Within the line~\ref{lst_code:time_client_cpp_logger} the object \textit{Logger} gets initialized. Due to the configuration of the the \textit{Logger} in the next lines, the messages passed to it will be redirected to the standard error stream.
%
For the components of the protocol stack are likewise loaded \textcolor{white}{newline}
\lstsetCPP
\lstinputlisting
	[
	label=lst:time_client_cpp,
	caption={[HED configuration file for the Arc intern echo service. Filename: arcecho\_no\_ssl.xml]
	\textbf{HED configuration file for the Arc intern echo service. Filename: arcecho\_no\_ssl.xml\textcolor{white}{hmf}}}
	]
{../src/clients/timeclient/timeclient.cpp}
 dynamically, one need to specify the installation directory of ARC in line~\ref{lst_code:time_client_cpp_init}.
%
The URL of the service is defined in line~\ref{lst_code:time_client_cpp_url}. It fits to the HED configuration file which was shown in Listing~\ref{lst:time_arched_xml}. 
The daemon is listing on port 60000 and is running on the localhost. The service itself uses HTTP and can be reached by using the path \textit{time}.
Line~\ref{lst_code:time_client_cpp_config} loads the standard config file which is usually almost empty. As a result, no additional security procedures will later be linked into the client sided stack. 
The protocol stack is created in line~\ref{lst_code:time_client_cpp_client}. 
Thanks to the service URL the information for the configuration is complete.
The constructor of the class \textit{ClientSOAP} creates a SOAP client which uses HTTP and addresses the port 60000 on localhost. If i.e. HTTPS would have been used, the stack would have been extended by an additional TLS protocol.
Once the client stack is ready, the request to the service can be created which is done in line~\ref{lst_code:time_client_cpp_message_reqeust}. Even the apperance of the message is unimportant to the service, the message is composed of two convoluted elements \textit{time} and \textit{timeReqest}.
%
The request will be processed in the next line by the method \textit{process} of the object \textit{client}.%in line~\ref{lst_code:time_client_cpp_message_response}. 
The object \textit{MCCStatus} which is returned by the method indicates the success of the processing.
After verifying the response, the message will passed to the standard out in line~\ref{lst_code:time_client_cpp_message_answer}.\\


The client has to be compilied to an ordinary binary so it can directly be executed from the command line.
Assure the service is running and use the client as to be seen in Listing~\ref{lst:time_client_ksh}.
\lstsetKSH
\begin{lstlisting}[
label=lst:time_client_ksh,float=htb,
caption={[Invokation of the time client.]
         \textbf{Invokation of the time client}}]
$ ./timeclient
Wed Feb 18 11:20:30 2009
\end{lstlisting}
The structure of the messages on SOAP level which are transmitted are shown in the Listings~\ref{lst:time_client_request} and \ref{lst:time_client_response}.
The enclosing element is \textit{Envelope} which may contain an element \textit{Header} and must contain an element \textit{Body}. %The namespace \textit{soap-env} is defined by the element \textit{envelope}
The data created by the object \textit{PayloadSOAP} is to be found within the \textit{Body}.
\lstsetJUSTXML
\begin{lstlisting}[
label=lst:time_client_request,float=htb,
caption={[Request message created by the client.]
         \textbf{Request message created by the client}}]
<soap-env:Envelope xmlns="urn:time" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <time>
      <timeRequest></timeRequest>
    </time>
  </soap-env:Body>
</soap-env:Envelope>
\end{lstlisting}


\lstsetJUSTXML
\begin{lstlisting}[
label=lst:time_client_response,float=htb,
caption={[Responce message of the service.]
         \textbf{Responce message of the service}}]
<soap-env:Envelope xmlns="urn:time" xmlns:soap-enc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:soap-env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap-env:Body>
    <time>
      <timeResponse>Wed Feb 18 11:20:30 2009</timeResponse>
    </time>
  </soap-env:Body>
</soap-env:Envelope>
\end{lstlisting}


















